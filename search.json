[{"title":"2022.11 and 2022.12","url":"/2022/12/17/2022.11%20and%202022.12/","content":"\n\n"},{"title":"My Blog","url":"/2022/12/16/My-Blog/","content":"我的Hexo博客来了！！！\n","categories":["随笔"]},{"title":"UVA11806题解","url":"/2022/12/17/UVA11806%E9%A2%98%E8%A7%A3/","content":"设满足“第一行没有石子”的方案集为 ，最后一行没有石子的方案集为 ，第一列没有石子的方案集为 ，最后一列没有石子的方案集为 ，全集为 ，则所求答案是“在  中但不在 任何一个集合中”的元素个数，可以用容斥原理求解。\n我们用二进制来表示  的所有搭配（ 对应于“空搭配”），如果在集合  或  中，相当于少了一列。假定最后剩了  行  列，方法数就是 。\n#include &lt;bits/stdc++.h&gt;using namespace std;const int mod=1000007;const int maxk=500;int c[maxk+10][maxk+10];int main(){    memset(c,0,sizeof(c));    c[0][0]=1;    for(int i=0;i&lt;=maxk;i++)    {        c[i][0]=c[i][i]=1;        for(int j=1;j&lt;i;j++)            c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;    }    int t;    cin&gt;&gt;t;    for(int kase=1;kase&lt;=t;kase++)    {        int n,m,k,sum=0;        cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;        for(int s=0;s&lt;16;s++)        {            int b=0,r=n,qaq=m;            if(s&amp;1)            {                r--;                b++;            }            if(s&amp;2)            {                r--;                b++;            }            if(s&amp;4)            {                qaq--;                b++;            }            if(s&amp;8)            {                qaq--;                b++;            }            if(b&amp;1) sum=(sum+mod-c[r*qaq][k])%mod;            else sum=(sum+c[r*qaq][k])%mod;        }        printf(\"Case %d: %d\\n\",kase,sum);    }    return 0;}\n","categories":["OI"],"tags":["题解"]},{"url":"/2022/12/18/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F/","content":"最好情况下\n\n\n冒泡排序\n图解：\n\n代码\nvoid bubble_sort(T arr[], int len){int i, j;  T temp;for (i = 0; i &lt; len - 1; i++)for (j = 0; j &lt; len - 1 - i; j++)if (arr[j] &gt; arr[j + 1])        {            temp = arr[j];            arr[j] = arr[j + 1];            arr[j + 1] = temp;        }}\n\n\n插入排序\n图解：\n\n代码：\nvoid InsertSort1(int A[],int n){int i,j,temp;for(i=1;i&lt;n;i++)    {if(A[i]&lt;A[i-1])        {temp=A[i];for(j=i-1;j&gt;=0&amp;&amp;A[j]&gt;temp;--j)            {A[j+1]=A[j];}A[j+1]=temp;}}}\n\n\n平均情况下\n\n\n快速排序\n图解：\n代码：\nvoid Quick_sort(int left,int right,int arr[]){if(left&gt;=right)return;int i,j,base,temp;i=left,j=right;base=arr[left];while(i&lt;j)    {while(arr[j]&gt;=base &amp;&amp; i&lt;j)j--;while(arr[i]&lt;=base &amp;&amp; i&lt;j)i++;if(i&lt;j)        {temp=arr[i];arr[i]=arr[j];arr[j]=temp;} }arr[left]=arr[i];arr[i]=base;Quick_sort(left,i-1,arr);Quick_sort(i+1,right,arr);}\n最坏情况下\n\n\n堆排序\n（等进神教我之后再填坑）\n\n\n归并排序\n\n代码：\nvoid merge(int low,int mid,int high){int i=low,j=mid+1,k=low;while (i&lt;=mid &amp;&amp; j&lt;=high){if (a[i]&lt;a[j])b[k++]=a[i++];elseb[k++]=a[j++];}while (i&lt;=mid)b[k++]=a[i++];while (j&lt;=high)b[k++]=a[j++];for (int i=low;i&lt;=high;i++)a[i]=b[i];}void mergesort(int x,int y){if (x&gt;=y) return;int mid=(x+y)/2;mergesort(x,mid);mergesort(mid+1,y);merge(x,mid,y);}\n\n"}]