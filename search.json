[{"title":"2022.11 and 2022.12","url":"/articles/covid-19/","content":"感慨万千。\r\n\r\n\r\n2022年11月，某组拍摄心理剧时空荡荡的教室\r\n\r\n\r\n\r\n2022年12月，疫情“放开”之后大面积感染，迫于形势不得不再次线上后，空荡荡的教室\r\n\r\n","categories":["随笔"]},{"title":"20221126 刷题总结","url":"/articles/summary-20221126/","content":"OpenJudge3089 爬楼梯\r\n注意while(cin&gt;&gt;n)前不要再写cin&gt;&gt;n了！！！\r\nOpenJudge1696 波兰表达式\r\n\r\nswitch函数：default表示不满足任何case条件的返回值\r\n如果题目中没有限制小数点后尾数，不要擅作主张\r\ndouble占位符是%f\r\n\r\nOpenJudge1750 全排列\r\n\r\n代表false，代表true\r\nbool默认初始化为（false）\r\n\r\nOpenJudge8758 2的幂次方表示\r\nif(a)和if(a!=0)等价，if(!a)和if(a==0)等价\r\n","categories":["OI"],"tags":["总结"]},{"title":"20230110 寒假集训日记","url":"/articles/20230110diary/","content":"\r\n开幕雷击（大雾）：DP时间复杂度：状态数每次转移方案数\r\n\r\n讲课人：银牌大佬lyn\r\n主要内容：\r\n\r\n背包问题\r\nLIS\r\nLCS\r\n区间DP\r\n\r\n","categories":["OI"],"tags":["集训日记"]},{"title":"20230111 寒假集训日记","url":"/articles/20230111diary/","content":"今日主要内容：\r\n\r\n状压DP\r\n一些小技巧\r\n\r\ngoto:mark;搭配mark:：可以快速跳出多层循环\r\nbitset：存储二进制数\r\n\r\nbitset&lt;n&gt; s，表示一个位的二进制数；\r\ns.count()：返回二进制中的数量\r\ns.any()：若所有位都为，返回false；若至少有一位为，返回true；\r\ns.none()：若所有位都为，返回true；若至少有一位为，返回false；\r\ns.set()：把每一位都变为；\r\ns.set(k,v)：把第位改为；\r\ns.reset()：把每一都位变为；\r\ns.reset(k)：把的第位改为；\r\ns.flip()：把所有位取反；\r\ns.flip(k)把的第位取反；\r\n\r\nexit(0)：记忆化搜索快速结束\r\ndouble a=(double)clock()/(double)CLOCKS_PER_SEC：记录程序运行时间、暴力法时及时限制时间停止\r\n\r\n\r\n","categories":["OI"],"tags":["集训日记"]},{"title":"Floyd算法进阶版学习笔记","url":"/articles/floyd/","content":"\r\n","categories":["OI"],"tags":["Floyd算法","最小环","传递闭包","笔记"]},{"title":"KMP学习笔记","url":"/articles/kmp/","content":"\r\n","categories":["OI"],"tags":["笔记","KMP","字符串"]},{"title":"BST学习笔记","url":"/articles/bst/","content":"前置芝士\r\n喜闻乐见的英语学习时间（大雾）。\r\n二叉查找树（BST），即Binary Search Tree。\r\n举个栗子：\r\n\r\n\r\nimage-20230104170517065\r\n\r\n性质\r\n\r\n树中每个结点被赋予了一个权值。\r\n若结点的左子树不空，则的左子树中所有节点的值均小于结点的值。\r\n若结点的右子树不空，则右子树中所有结点的值均大于结点的值。\r\n任意结点的左、右子树也分别是二叉搜索树。\r\n\r\n作用\r\n\r\n表示有序集合\r\n建立索引或优先队列\r\n维护有序数集\r\n\r\n操作\r\n遍历\r\n对于一棵已知的二叉查找树，从小到大输出其结点的值，只需对其进行二叉树的中序遍历，即递归地先输出其左子树，再输出其本身，然后输出其右子树。\r\n时间复杂度为。\r\n代码如下：\r\nvoid print(int p){    if(!p) return;    print(left[p]);    printf(\"%d\\n\",a[p]);    print(right[p]);}\r\n","categories":["OI"],"tags":["笔记","数据结构","BST"]},{"title":"My Blog","url":"/articles/beginning/","content":"我的博客来了！！！\r\n","categories":["随笔"]},{"title":"LCS学习笔记","url":"/articles/lcs/","content":"姊妹篇：LIS\r\nLCS（Longest Common\r\nSequence），顾名思义，就是最长公共子序列问题。\r\n咕了，卷题去了，明天填坑QwQ。\r\n","categories":["OI"],"tags":["笔记","LCS","DP"]},{"title":"LIS学习笔记","url":"/articles/lis/","content":"LIS（Longest Increasing\r\nSubsequence），顾名思义，就是最长上升子序列问题。\r\n在这里我们要区分一下子串和子序列的区别，很简单，子串连续，子序列可以不连续。然而就在几小时之前本蒟蒻还不知道\r\n简单来说，就是给出一个内容不重复的序列，求它的最长上升子序列。听君一席话，如听一席话\r\n下面介绍两种做法，的DP做法和的二分做法。\r\n DP\r\n我们用dp[i]表示以a[i]为结尾的LIS，剩下的自己理解就好啦QwQ学了优化之后就不会朴素做法了\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105, INF = 0x7f7f7f7f;int a[maxn],dp[maxn];int n,ans = -INF;int main(){    scanf(\"%d\",&amp;n);    for(int i=1;i&lt;=n;i++)        scanf(\"%d\",&amp;a[i]),dp[i] = 1;    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;i;j++)            if(a[j] &lt; a[i])                dp[i] = max(f[i],dp[j]+1);    for(int i=1;i&lt;=n;i++)         ans = max(ans,dp[i]);    cout&lt;&lt;ans;    return 0;}\r\n\r\n二分\r\n显然，对于一个LIS，要让它结尾的数尽量的小，才能使LIS最长。\r\n举个栗子：对于“5201314”，第一步为“5”；第二步发现，所以换为“2”；第三步发现，所以换为“0”；第四步发现，把放进去变为“05”；第五步发现，所以换为“03”，以此类推。\r\n对于这个的实现，我们可以巧妙地运用lower_bound函数进行二分查找，查找这个要放进去的值所在的区间。\r\n代码如下：\r\n#include &lt;bits/stdc++.h&gt;using namespace std;int a[105],f[105];//f is LISint main(){    int n;cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];    f[1]=a[1];    int len=1;    for(int i=2;i&lt;=n;i++)    {        if(a[i]&gt;f[len]) len++,f[len]=a[i];        else        {            int j=lower_bound(f+1,f+n+1,a[i])-f;            f[j]=a[i];        }    }    cout&lt;&lt;len;    return 0;}\r\n发现自己真的是鱼，差点没写出来\r\n","categories":["OI"],"tags":["笔记","DP","LIS","二分"]},{"title":"OI回忆录","url":"/articles/oi-memory/","content":"OI回忆录，顾名思义，是即将AFO的OIer写的回忆录。\r\n然鹅，目前为止我并没有AFO，写这篇OI回忆录，其实是因为最近看了太多很强的OIer退役了，多愁善感的基因令我也有些伤感——我也会有这一天，是在寒假集训结束后，模拟赛被薄纱而退役？还是苟到了CSP、NOIP，考完之后以一个对不起自己的成绩退役？还是……\r\n一些这样的文章，就有点儿伤感捏。\r\n高一上\r\n高一上，最先来的便是五科竞赛布道宣讲，自己一直对计算机很感兴趣，所以虽然父母想让选数学/物理但最后还是选了信息。（现在想想是好的毕竟我的数学和物理真的有点儿拉）\r\n当时新高一零基础的有个人吧（差不多）。\r\n开始gg讲的都是一些简单的东西，记得刚学的时候自己就像打了鸡血一样把OpenJudge上的题全部刷完了，好像还得到gg的表扬乐。然后我就摆了\r\n期中考试我寄了，寄的很彻底，在信竞队伍里垫底，当时其实有点儿迷茫，感觉自己好没用，当时好像还考了一场模拟赛，我虽然不是垫底但也有点儿拉胯。动力全无。\r\n期中考试之后，还剩个人，甚至连年级前的巨佬都AFO了。（后来又加入了一个）\r\n后来月的某天……算了这段是比较私人的东西就不写出来了。（大体可能就是看见了某个人然后莫名其妙地被激励了有了目标（?））自那之后努力了一段时间，每天中午不吃饭不睡觉地往机房跑（但是好像并没有学多少东西），网课的时候也在刷题，所以洛谷很快到了AC，乐。（然鹅还不是橙名呜呜呜）\r\n然后高一上就结束乐。记录一下当时会的东西（截止到2022/12/25）：\r\n\r\n寒假(1)\r\n","categories":["OI"],"tags":["回忆"]},{"title":"P1135题解","url":"/articles/solution-P1135/","content":"从起点开始，往上或者往下扩展，可以到达“按次按钮的地方”。这些“按次按钮的地方”再分别往上或往下扩展（前提是在大厦范围内，且没有访问过），就可以到达“按次按钮的地方”。\r\n使用广度优先搜索。\r\n代码如下：\r\n#include&lt;bits/stdc++.h&gt;  using namespace std;  struct node{    int floor,d;    //d是按钮次数};queue&lt;node&gt; q;int n,a,b;int k[1005],vis[1005];int main()  {      cin&gt;&gt;n&gt;&gt;a&gt;&gt;b;    for(int i=1;i&lt;=n;i++)    {        cin&gt;&gt;k[i];    }    q.push(node{a,0});    vis[a]=1;    node now;    while(!q.empty())    {        now=q.front();        q.pop();//出队        if(now.floor==b)        {            break;        }        for(int sign=-1;sign&lt;=1;sign+=2)        {            int dist=now.floor+k[now.floor]*sign;            if(dist&gt;=1&amp;&amp;dist&lt;=n&amp;&amp;vis[dist]==0)            {                q.push((node){dist,now.d+1});                vis[dist]=1;            }        }    }    if(now.floor==b)    {        cout&lt;&lt;now.d&lt;&lt;endl;    }    else    {        cout&lt;&lt;-1&lt;&lt;endl;    }    return 0;  }  \r\n","categories":["OI"],"tags":["题解","BFS"]},{"title":"P1091题解","url":"/articles/solution-P1091/","content":"我们按照由左而右和由右而左的顺序，将n个同学的身高排成数列\r\na为身高序列，其中a[i]为同学i的身高\r\nb为由左而右身高递增的人数序列，其中b[i]为同学1…同学i间（包括同学i）身高满足递增顺序的最多人数。显然\r\n同学的身高同学的身高\r\nc为由右而左身高递增的人数序列，其中c[i]为同学n…同学i间（包括同学i）身高满足递增顺序的最多人数。显然\r\n同学的身高同学的身高\r\n要使b[i]和c[i]最大，子问题的解b[j]和c[k]必须最大\r\n（，）（最优子结构性质）\r\n为求得b[i]和c[i]，必须一一查阅子问题的解\r\n（重迭子问题）\r\n代码： #include &lt;bits/stdc++.h&gt;using namespace std;int a[200],b[200],c[200];int main(){\tint n,i,j,maxx;\t\tmemset(b,0,sizeof(b));\tmemset(a,0,sizeof(a));\t\tcin&gt;&gt;n;\tfor(i=1;i&lt;=n;i++)\t{\t\tcin&gt;&gt;a[i];\t}\tfor(i=1;i&lt;=n;i++)\t{\t\tb[i]=1;\t\tfor(j=1;j&lt;=i-1;j++)\t\t{\t\t\tif((a[i]&gt;a[j])&amp;&amp;(b[j]+1&gt;b[i]))\t\t\t{\t\t\t\tb[i]=b[j]+1;\t\t\t}\t\t}\t}\tfor(i=n;i&gt;=1;i--)\t{\t\tc[i]=1;\t\tfor(j=i+1;j&lt;=n;j++)\t\t{\t\t\tif((a[j]&lt;a[i])&amp;&amp;(c[j]+1&gt;c[i]))\t\t\t{\t\t\t\tc[i]=c[j]+1;\t\t\t}\t\t}\t}\t\tmaxx=0;\tfor(i=1;i&lt;=n;i++)\t{\t\tif(b[i]+c[i]&gt;maxx)\t\t{\t\t\tmaxx=b[i]+c[i];\t\t}\t}\t\tcout&lt;&lt;n-maxx+1&lt;&lt;endl;\t\treturn 0;}\r\n","categories":["OI"],"tags":["题解","排序"]},{"title":"P1896题解","url":"/articles/solution-P1896/","content":"的棋盘，个国王，求使它们无法互相攻击的方案总数。\r\n设表示第行状态为a[j]且前行放了个国王的方案总数。\r\n\r\na[j]、a[k]分别表示一种摆放方式且a[k]、a[j]合法，等于加上a[j]这种摆放方式在这一行放置的国王数。\r\n基于状态压缩的思想，我们可以把、转化为二进制数，步骤如下：\r\n\r\n对于每一行，搜索得到合法状态；\r\n枚举上一行与这一行搭配合法的状态累加；\r\n\r\n这么做时间复杂度为，可以考虑优化。\r\n我们用表示列数为时一行的方案数，，初始化：，。\r\n首先进行预处理，代码如下：\r\nvoid prepare(){    int i,j,k;    sum=0,ans=0;    memset(f,0,sizeof(f));    for(i=0;i&lt;(1&lt;&lt;n);i++)//枚举行    {        if(i&amp;(i&lt;&lt;1)) continue;        k=0;        for(j=0;j&lt;n;j++)            if(i&amp;(1&lt;&lt;j)) k++;        sum++,s[sum]=i;//s记录可用状态的十进制表示        num[sum]=k;//num记录该状态下的国王数，sum为总状态数    }}\r\n然后进行DP操作：\r\nvoid dp(){    f[0][1][0]=0;    for(int i=1;i&lt;=N;i++)//枚举行        for(int j=1;j&lt;=sum;j++)//枚举第i行的状态            for(int l=0;l&lt;=K;l++)//枚举前i行国王数                if(l&gt;=num[j])                    for(int t=1;y&lt;=sum;t++)//枚举第i-1行                    {                    }}\r\n咕咕咕~\r\n","categories":["OI"],"tags":["题解","状压DP"]},{"title":"P1449题解","url":"/articles/solution-P1449/","content":"阅读一个后缀表达式的方法是：从左往右读式子，一旦遇到运算符，就往前取个数——这个取决于运算符有多少个参数——然后擦掉这些参数和这个运算符，把计算结果写在那里。接下来，重复刚才的操作，直到表达式中只剩下一个数为止。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;stack&lt;int&gt; n;int s=0,x,y;int main(){    char ch;    do    {        ch=getchar();        if(ch&gt;='0'&amp;&amp;ch&lt;='9')        {            s=s*10+ch-'0';        }        else if(ch=='.')        {            n.push(s);            s=0;        }        else if(ch!='@')        {            x=n.top();            n.pop();            y=n.top();            n.pop();            switch (ch)            {                case'+':n.push(x+y);break;                case'-':n.push(y-x);break;                case'*':n.push(x*y);break;                case'/':n.push(y/x);break;            }        }    }while(ch!='@');        printf(\"%d\\n\",n.top());    return 0;   }\r\n","categories":["OI"],"tags":["题解"]},{"title":"P1443题解","url":"/articles/solution-P1443/","content":"广度优先搜索，会优先考虑每种状态和初始状态的距离，形象点说，与初始状态越接近的情况就会越先考虑。再具体一点，每个时刻（阶段）要做的事情就是从上个时刻（阶段）每个状态扩展出新的状态。\r\n广度优先搜索使用队列实现：先将初始状态加入到空的队列中，然后每次取出队首，找出队首所能转移到的状态，再将其压入队列。如此反复，直到队列为空。这样就能保证一个状态在被访问的时候一定是采用的最短路径。\r\n就本题而言，先建立一个结构体数组用于存储扩展的结点。先让起点入队，然后在队列取状态逐个扩展。\r\n代码：\r\n#include&lt;bits/stdc++.h&gt;  using namespace std;  struct coord{    int x,y;};queue&lt;coord&gt; q;int ans[305][305];int walk[8][2]={{2,1},{1,2},{-1,2},{-2,1},{-2,-1},{-1,-2},{1,-2},{2,-1}};int main()  {      int m,n,sx,sy;    memset(ans,-1,sizeof(ans));    cin&gt;&gt;n&gt;&gt;m&gt;&gt;sx&gt;&gt;sy;    coord tmp={sx,sy};    q.push(tmp);    ans[sx][sy]=0;    while(!q.empty())    {        coord u=q.front();        int ux=u.x,uy=u.y;        q.pop();//出队        for(int k=0;k&lt;8;k++)        {            int x=ux+walk[k][0],y=uy+walk[k][1];            int d=ans[ux][uy];            if(x&lt;1||x&gt;n||y&lt;1||y&gt;m||ans[x][y]!=-1)            {                continue;            }            ans[x][y]=d+1;            coord tmp={x,y};            q.push(tmp);//入队        }    }    for(int i=1;i&lt;=n;i++,puts(\" \"))        for(int j=1;j&lt;=m;j++)            printf(\"%-5d\",ans[i][j]);    return 0;  }  \r\n","categories":["OI"],"tags":["题解","BFS"]},{"title":"P3156题解","url":"/articles/solution-P3156/","content":"直接建立一个数组按照顺序来记录按顺序到达的同学的学号，之后直接在数组中查询即可。建立数组的大小至少要超过最多可能的同学总数量（也就是）。这里可以使用STL容器的可变长度数组来记录。可变长度数组的头文件是&lt;vector&gt;，有以下的常用方法。\r\n\r\nvector&lt;int&gt; v(N,i)：建立一个可变长度数组v，内部元素类型为int；该可变数组最开始有N个元素，每个元素初始化为i。可以省略i（默认值为0），也可以把(N,i)同时省略，此时这个数组的长度就是0。\r\nv.push_back(a)：将元素a插入到数组v的末尾，并增加数组长度。\r\nv.pop_back：弹出队尾。\r\nv.size()：返回数组v的长度。\r\nv.resize(n,m)：重新调整数组大小为n，如果n比原来的小，则删除多余的信息；如果n比原来大，则新增的部分都初始化为m，其中m是可以省略的。\r\n\r\n可以通过数组初始化、使用push_back或者resize成员函数来增加数组长度。\r\n代码： #include &lt;bits/stdc++.h&gt;using namespace std;int n,m,tmp;int main(){    vector&lt;int&gt; stu;    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;n;i++)    {        cin&gt;&gt;tmp;        stu.push_back(tmp);    }    for(int i=0;i&lt;m;i++)    {        cin&gt;&gt;tmp;        cout&lt;&lt;stu[tmp-1]&lt;&lt;endl;    }    return 0;   }\r\n","categories":["OI"],"tags":["题解","STL"]},{"title":"RMQ学习笔记","url":"/articles/rmq/","content":"前置芝士\r\nRMQ，即Range Maximum(Minimum)\r\nQuery的缩写。（记住它叫RMQ就对了）\r\n顾名思义，RMQ就是询问某个区间内的最大值或最小值。\r\nST算法\r\n简介\r\nST算法通常用在要多次询问一些区间的最值的问题中。\r\n时间复杂度\r\n它可以做到的预处理，回答每个询问。\r\n使用条件\r\n使用ST算法的条件是没有修改操作，它适用于没有修改操作并且询问次数较多（级别甚至更大）的情况。\r\n原理\r\n动态规划。\r\n流程\r\n预处理\r\n我们用a[1…n]表示一组数。\r\n设表示从到这个范围内的最大值，也就是以为起点连续个数的最大值。由于元素个数为个，所以从中间平均分成两部分，每一部分的元素个数刚好为个，也就是说，把分为和。\r\n整个区间的最大值一定是左右两部分最大值的较大值，满足动态规划的最优化原理。\r\n状态转移方程：，边界条件为f[i][0]=a[i]。\r\n预处理时间复杂度：。\r\n询问\r\n要询问区间的最大值，则先求出最大的满足，那么区间。\r\n两个区间的元素个数都为，所以的最大值为，可以在内计算出来。\r\n虽然这两个区间有交集，但是对于求区间最值来说没有影响，这就是ST算法适用于求区间最值的原因。\r\n求区间最大值，直接给出表达式： \r\n技巧\r\n因为cmath库中的log2函数效率不高，通常还会使用递推预处理出这种区间长度各自对应的值。具体地，。\r\nST VS 线段树\r\n\r\nST算法的优势\r\n\r\n实现非常简单\r\n效率比线段树更高\r\n\r\n线段树的优势\r\n\r\n可以更好地维护动态的信息，而ST算法不易推广到动态\r\n可以维护更多的信息，而ST算法只能维护最值\r\n\r\n\r\n\r\n练手板子题\r\n\r\n友情提供板子题代码：\r\n#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=1e6+5,logn=20;int log[maxn],f[maxn][logn+5];int n,m,x,y;inline int read(){\tint x=0,f=1;\tchar ch=getchar();\twhile(ch&gt;'9'||ch&lt;'0'){if(ch=='-') f=-1;ch=getchar();}\twhile(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}\treturn x*f;}int main(){    n=read(),m=read();    for(int i=1;i&lt;=n;++i)    {        f[i][0]=read();    }    log[0]=-1;    for(int i=1;i&lt;=n;++i)        log[i]=log[i/2]+1;    for(int j=1;j&lt;=logn;++j)        for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;++i)            f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;j-1)][j-1]);    \t\t//注意加减乘除运算符的优先级高于位移运算符    while(m--)    {        x=read(),y=read();        int s=log[y-x+1];        printf(\"%d\\n\",max(f[x][s],f[y-(1&lt;&lt;s)+1][s]));    }    return 0;}\r\n完结撒花！\r\n","categories":["OI"],"tags":["笔记","数据结构","RMQ"]},{"title":"P3613题解","url":"/articles/solution-P3613/","content":"可以建立一个二维数组s[i,j]记录第个柜子中第个格子中的物品。根据本题的数据规模，需要定义一个大小为的int数组（字节，大约40GB），显然会超出内存限制。\r\n依然可以使用vector来解决。除了上面介绍过的方法，vector还支持下面的一些方法。\r\n\r\nvector&lt;int&gt;::iterator it：定义一个名字叫作it的迭代器。\r\nv.begin()：返回数组首元素（也就是v[0]）的指针（迭代器）。\r\nv.end()：返回数组v首元素末尾的下一个元素的指针（迭代器）。这个指针有点类似于空指针，不指向任何元素。\r\n\r\n除了使用数组下标，还能通过“迭代器”来访问数组中的元素。迭代器有点类似指针（虽然并不能完全画等号），这里的it就可以认为是一个指向vector中的元素的指针（下文中如果在谈到STL元素的指针，一般都指迭代器)。it可以++或者--变成前一个或后一个元素的指针，也能和指针一样用*it取该指针中的元素。\r\n由于迭代器和指针在表现方式上很接近，所以v[i]和*(v.begin()+i)是一样的，都是对应元素的值。其他STL容器的迭代器也有类似的性质。然而在算法竞赛中经常只把vector当作普通的可变数组来使用，比较少用到迭代器。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;int n,q,opt,i,j,k;int main(){    cin&gt;&gt;n&gt;&gt;q;    vector&lt;vector&lt;int&gt;&gt;locker(n+1);    while(q--)    {        cin&gt;&gt;opt;        if(opt==1)        {            cin&gt;&gt;i&gt;&gt;j&gt;&gt;k;            if(locker[i].size()&lt;j+1)            {                locker[i].resize(j+1);            }            locker[i][j]=k;        }        else        {            cin&gt;&gt;i&gt;&gt;j;            cout&lt;&lt;locker[i][j]&lt;&lt;endl;        }    }        return 0;   }\r\n","categories":["OI"],"tags":["题解","STL"]},{"title":"最短路学习笔记","url":"/articles/sssp/","content":"\r\n","categories":["OI"],"tags":["笔记","图论","最短路","SSSP"]},{"title":"SPFA算法学习笔记","url":"/articles/spfa/","content":"\r\n关于SPFA，它死了\r\n\r\n所以这篇博客没有什么写的必要了\r\n不过SPFA还是要学的，已经在学了，咕咕咕，学会了来填坑QwQ\r\n","categories":["OI"],"tags":["笔记","图论","SPFA"]},{"title":"Treap学习笔记","url":"/articles/treap/","content":"\r\n","categories":["OI"],"tags":["笔记","数据结构","Treap","平衡树"]},{"title":"UVA10881题解","url":"/articles/solution-UVA10881/","content":"如果把蚂蚁看成是没有区别的小点，那么只需独立计算出每只蚂蚁在时刻的位置即可。比如，有只蚂蚁，蚂蚁，蚂蚁，蚂蚁，则两秒钟之后，只蚂蚁分别为、和。\r\n注意，虽然从整体上讲，“掉头”等价于“对穿而过”，但对于每只蚂蚁而言并不是这样。蚂蚁的初始状态为，因此一定有一只蚂蚁在两秒钟之后处于的状态，但这只蚂蚁却不一定是蚂蚁。换句话说，我们需要搞清楚目标状态中“谁是谁”。\r\n所有蚂蚁的相对顺序是保持不变的，因此把所有目标位置从小到大排序，则从左到右的每个位置对应于初始状态下从左到右的每只蚂蚁。由于原题中蚂蚁不一定按照从左到右的顺序输入，还需要预处理计算出输入中的第只蚂蚁的序号order[i]。\r\n","categories":["OI"],"tags":["题解"]},{"title":"UVA11806题解","url":"/articles/solution-UVA11806/","content":"设满足“第一行没有石子”的方案集为 ，最后一行没有石子的方案集为 ，第一列没有石子的方案集为 ，最后一列没有石子的方案集为 ，全集为 ，则所求答案是“在  中但不在\r\n任何一个集合中”的元素个数，可以用容斥原理求解。\r\n我们用二进制来表示 \r\n的所有搭配（\r\n对应于“空搭配”），如果在集合  或\r\n 中，相当于少了一列。假定最后剩了\r\n 行  列，方法数就是 。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int mod=1000007;const int maxk=500;int c[maxk+10][maxk+10];int main(){    memset(c,0,sizeof(c));    c[0][0]=1;    for(int i=0;i&lt;=maxk;i++)    {        c[i][0]=c[i][i]=1;        for(int j=1;j&lt;i;j++)            c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;    }    int t;    cin&gt;&gt;t;    for(int kase=1;kase&lt;=t;kase++)    {        int n,m,k,sum=0;        cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;        for(int s=0;s&lt;16;s++)        {            int b=0,r=n,qaq=m;            if(s&amp;1)            {                r--;                b++;            }            if(s&amp;2)            {                r--;                b++;            }            if(s&amp;4)            {                qaq--;                b++;            }            if(s&amp;8)            {                qaq--;                b++;            }            if(b&amp;1) sum=(sum+mod-c[r*qaq][k])%mod;            else sum=(sum+c[r*qaq][k])%mod;        }        printf(\"Case %d: %d\\n\",kase,sum);    }    return 0;}\r\n","categories":["OI"],"tags":["题解","容斥原理"]},{"title":"UVA207题解","url":"/articles/solution-UVA207/","content":"第一个步骤是选出晋级选手，这涉及对所有选手“前两轮总得分”进行排序，接下来计算4轮总分，然后再排序一次，最后对排序结果依次输出。\r\n犯规选手要单独处理；在输出一行之前要检查有没有并列的情况，如有则要一并处理（包括计算奖金平分情况）。\r\nPS：这道题真的好麻烦！！！\r\n#include &lt;bits/stdc++.h&gt;using namespace std;#define REP(i,n) for(int i = 0; i &lt; (n); i++)const int maxn = 144;const int n_cut = 70;struct Player {    char name[25];    int amateur;    int sc[4];    int sc36, sc72, dq;    int rnds;} player[maxn];int n;double purse, p[n_cut];bool cmp1(const Player&amp; p1, const Player&amp; p2) {    if(p1.sc36 &lt; 0 &amp;&amp; p2.sc36 &lt; 0) return false;     if(p1.sc36 &lt; 0) return false;     if(p2.sc36 &lt; 0) return true;    return p1.sc36 &lt; p2.sc36;}bool cmp2(const Player&amp; p1, const Player&amp; p2) {    if(p1.dq &amp;&amp; p2.dq)     {        if(p1.rnds != p2.rnds) return p2.rnds &lt; p1.rnds;        if(p1.sc72 != p2.sc72) return p1.sc72 &lt; p2.sc72;        return strcmp(p1.name, p2.name) &lt; 0;    }    if(p1.dq) return false;    if(p2.dq) return true;    if(p1.sc72 != p2.sc72) return p1.sc72 &lt; p2.sc72;    return strcmp(p1.name, p2.name) &lt; 0;}void print_result() {    printf(\"Player Name          Place     RD1  RD2\");    printf(\"  RD3  RD4  TOTAL     Money Won\\n\");    printf(\"---------------------------------------\");    printf(\"--------------------------------\\n\");    int i = 0, pos = 0;    while(i &lt; n)     {        if(player[i].dq)         {            printf(\"%s           \",player[i].name);            REP(j,player[i].rnds) printf(\"%-5d\", player[i].sc[j]);            REP(j,4-player[i].rnds) printf(\"     \");            printf(\"DQ\\n\");            i++;            continue;        }        int j = i;        int m = 0;        bool have_money = false;        double tot = 0.0;         while(j &lt; n &amp;&amp; player[i].sc72 == player[j].sc72)         {            if(!player[j].amateur)             {                m++;                          if(pos &lt; n_cut)                 {                    have_money = true;                     tot += p[pos++];                }            }            j++;        }        int rank = i + 1;         double amount = purse * tot / m;         while(i &lt; j)         {            printf(\"%s \", player[i].name);            char t[5];            sprintf(t, \"%d%c\", rank, m &gt; 1 &amp;&amp; have_money &amp;&amp; !player[i].amateur ? 'T' : ' ');            printf(\"%-10s\", t);            REP(e,4) printf(\"%-5d\", player[i].sc[e]);            if(!player[i].amateur &amp;&amp; have_money)             {                printf(\"%-10d\", player[i].sc72);                printf(\"$%9.2lf\\n\", amount / 100.0);            }             else                printf(\"%d\\n\", player[i].sc72);            i++;        }    }}int main() {    int T;     char s[40];    gets(s);    sscanf(s,\"%d\",&amp;T);    while(T--)     {        gets(s);        gets(s);        sscanf(s,\"%lf\", &amp;purse);        REP(i,n_cut)         {            gets(s);            sscanf(s, \"%lf\", &amp;p[i]);        }        gets(s);        sscanf(s, \"%d\", &amp;n);        assert(n &lt;= 144);        REP(k,n)         {            gets(s);            strncpy(player[k].name, s, 20);                  player[k].name[20] = 0;            player[k].amateur = 0;            if(strchr(player[k].name, '*'))             {                player[k].amateur = 1;            }            player[k].sc36 = player[k].sc72 = player[k].dq=0;            memset(player[k].sc, -1, sizeof(player[k].sc));            REP(i,4)             {                char t[5];                REP(j,3) t[j] = s[20 + i*3 + j]; t[3] = '\\0';                if(!sscanf(t,\"%d\", &amp;player[k].sc[i]))                 {                    player[k].rnds = i;                    player[k].dq = -1;                    if(i &lt; 2) player[k].sc36 = -1;                    break;                 }                 else                 {                              player[k].sc72 += player[k].sc[i];                    if(i &lt; 2)                        player[k].sc36 += player[k].sc[i];                }            }        }        sort(player, player+n, cmp1);        assert(player[n_cut-1].sc36 &gt;= 0);        for(int i = n_cut-1; i &lt; n; i++)            if(i == n-1 || player[i].sc36 != player[i+1].sc36)             {                 n = i+1;                 break;             }        sort(player, player+n, cmp2);                print_result();            if(T) printf(\"\\n\");    }        return 0;}\r\n","categories":["OI"],"tags":["题解"]},{"title":"UVA673题解","url":"/articles/solution-UVA673/","content":"将这个字符串从左往右写，一旦遇到匹配上的括号，就把这对括号擦掉，就像“消消乐”一样。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;stack&lt;char&gt; s;int num;char trans(char a){    if(a==')')        return '(';    if(a==']')        return '[';    if(a=='}')        return '{';    return '\\0';}int main(){    cin&gt;&gt;num;    string p;    getline(cin,p);    while(num--)    {        while(!s.empty())        {            s.pop();        }        getline(cin,p);        for(int i=0;i&lt;p.size();i++)        {            if(s.empty())            {                s.push(p[i]);                continue;            }            if(trans(p[i])==s.top())                s.pop();            else                s.push(p[i]);        }        if(s.empty())            cout&lt;&lt;\"Yes\"&lt;&lt;endl;        else            cout&lt;&lt;\"No\"&lt;&lt;endl;    }        return 0;   }\r\n使用cin读入一个独占的数字后，其读入指针在这一行的末尾，如果希望读到第二行，则必须要假装读入这一行，可以使用getline，也可以使用getchar等。\r\n","categories":["OI"],"tags":["题解"]},{"title":"map——从零基础到入门","url":"/articles/map/","content":"map容器是一个映射表（key-value型），其内部实现是一棵红黑树。\r\nmap的key和value可以是任意类型。\r\nmap容器经常被当作Hash表使用，但是操作的时间复杂度为，略慢于传统Hash表。\r\n常见操作\r\n\r\nsize、empty、clear、begin、end、count\r\nh.find(x)：在变量名为h的map中查找key为的二元组。\r\ninsert、erase\r\n搭配迭代器\r\n添加注释小能手上线\r\nmap&lt;int,int&gt; h;h.insert(make_pair(1,2));map&lt;int,int&gt;::iterator it=h.begin(),itlow,itup;itlow=h.lower_bound('b');//itlow指向大于等于‘b’的第一个元素itup=h.upper_bound('d');//同理，指向大于‘d’键值的第一个元素pair&lt;int,int&gt; p=*it;h.erase(it);h.erase(make_pair(2,3));\r\n[]操作\r\nh[key]返回key映射到的value的引用，时间复杂度为。\r\n还可以对h[key]进行赋值操作，改变key对应的value。\r\n若查找的key不存在，执行h[key]后，h会自动新建一个二元组(key,zero)，zero表示一个广义零值，如整数，空字符串等。\r\n强烈建议在[]操作查询之前，先用find检查key的存在性。\r\n\r\n","categories":["OI"],"tags":["笔记","STL"]},{"title":"lowbit运算——从零基础到入门","url":"/articles/lowbit/","content":"前置芝士\r\n进制转换\r\n位运算\r\n定义\r\n定义为非负整数在二进制表示下“最低位的及其后面的所有”构成的数值。\r\n举个栗子，的二进制表示为，则。\r\n公式\r\n\r\n证明：略（这么短记住就好啦）。\r\n应用\r\n与Hash配合\r\n运算配合Hash，可以找出整数二进制表示下所有是的位，时间复杂度与的个数同级。\r\n实现：不断把赋值为，直至。\r\n举个栗子：，。把赋值为。，停止循环。在这个过程中减掉了和，即每一位上的后补后的数值。取和，就可以知道的第位和第位是。\r\n曾经说过，C++中的log2函数效率不够高，所以我们要预处理一个数组，用Hash代替运算。\r\n当较小时，可以建立一个数组h，令。\r\nconst int maxn=1&lt;&lt;20;int h[maxn+5];for(int i=1;i&lt;=20;i++) h[1&lt;&lt;i]=i;while(cin&gt;&gt;n){    while(n&gt;0) cout&lt;&lt;h[n&amp;-n]&lt;&lt;' ',n-=n&amp;-n;    cout&lt;&lt;endl;}\r\n还有一种方法，建立一个长度为的数组h，令（，互不相等，可以取遍）。\r\nint h[37];for(int i=0;i&lt;36;i++) h[(1ll&lt;&lt;i)%37]=i;while(cin&gt;&gt;n){    while(n&gt;0) cout&lt;&lt;h[(n&amp;-n)%37]&lt;&lt;' ',n-=n&amp;-n;    cout&lt;&lt;endl;}\r\n求某数中位是的位数的个数\r\n可以采用一种递推的做法，N[i]为数中的个数，N[i]=1+N[i-(i&amp;(-i))]。\r\n树状数组\r\n更多函数\r\n（下面的函数有的与机器或编译器版本相关，有的比赛禁止使用，所以不要滥用QwQ）\r\n\r\nint __builtin_ctz(unsigned int x)\r\nint __builtin_ctzll(unsigned long long x)\r\n返回的二进制表示下最低位的后边有多少个。\r\nint __builtin_popcount(unsigned int x)\r\nint __builtin_popcountll(unsigned long long x)\r\n返回的二进制表示下有多少位为。\r\n\r\n","categories":["OI"],"tags":["笔记","位运算","进制"]},{"title":"ncwzdlsdの奇怪错误合集","url":"/articles/allwrong/","content":"\n  b9db06ff55df720d4300c3b335ffbcfc0986359b1dbd1e7e9d58b8c0886cb35b3db7429b4bc33d8ad9ed4052ab226d19ddf0f3c73a33783b2ae45b560c50c6d3357b1d0eff800fdc4fb4be8b2262e3b8c29d78d7812f6ad72b44d371fdb2438b56bb02865b5d2582701e0ad75330eaf128c7f9fa96e02d1abcdcf61fb5a312c21b1abdb31dec9fa24bf7245897fd84e681aa9b7543a53f3f30b0ffaf24f6f7e2b417a97a72230cba16b9f15421277133972d3b0932d6300d124006730ac6a039d0ab9bf676e4c5c6ea5ceebe8f1f55d3f36e693328ac21929e808f1b4dbdea9941e43d9829a57f5ea1fc72c38cf8730dd819e207ce9496da3f80f563bdd681938e2964eff76c91353fed57a9c41e1de5a0db2bcf5f8cafd80fefc29bac4dd649fcc09c27511c265a7f01adfd42d3027e1244433996f85d738508b348734884d35ada79983bdb19503f87f66ddfaea4169a4e50c7f0c00063be1563eb75e3b2396d62deafcf050a8e364a2d4174a056818659f449ec8fb1b60e1439ff0857cecee80d0916b887da6fc4359a64838845d2d6b39275b802baa423517bf9adedb65c43873a4876b1df311b83ba1c5e0fa4c0a01490967de08ea6b90d5e3a35907abff5a14541e65ea997f961205edd48b65242cdb793e9aba7408c5262d3af740a768bc9dd2167cafebc8357eb46eccd07cc5239ccb831a8e16dfeb8ef982d003f501f23a11a2d5c1c6ccca2181d69e575eb78883f1a2c5f5cb7dd0f73312f1674350e6212ca6bcf8af7cdf2c9c54f68d6502422d55bfbdec64f26d001219d8e1b87d69d4a66638b8d8a14c4c56c34606449839c248c526d22689749427cfb44b822a9515895e54dd5d6004e65422a304367e7ab7f6495ee5902bf76a362b54b1624e2c230b5ebd82435b36f98de16c5273ef43a592681d4c9be53e973c631a04077e9b70f8fa3e308ea0c8ae3227e926bd886c07f460b5d73082270cad010e773607daa37f70eb2b77aadf4af3af84c96bd681d13259f96a1311312e64be88d8e5c24df0fa30367de71a8ae7d4cf1fe00da14d0fc427a774071a5a4e697e20a90d539a032004a5fe52bb0afe27a4fe38a5256b1282d61b624080e1a27d9cc1a5d29f24bf33442cef467c530a27046b544ae5d63c1f9d5f2df59961cca46dbf17a6a900ae4146ba1af068875e9089b736c1616e0cd872719710cc636ffd68424b46a64daf8731cc0050547dfab9211d500f16ff2df246b1c1b3c280dad40717d7e4e5d325660d9d88bc05aaf32c7db66f98bdacc1b7e3f8bcdbe8d88f28e98e45daa72ebf34f6fbe5f022764ba9eefd99c3c190e1bff93b970ef4c5ef1baf0ac8a01fb88c1ab65b74054ce455aa4c6929969258d765708731ba8f9da041a87e4878568802362450ed05f1391e5e2178e44d9bdfd3e12e821ea9cb46d1d8c133238da5fc12bc274194b9ebe6ea212ec15eb63ab177d7f1ebc2b486d6393bf9b77bf437e3c90ac89e968147f3c3dc5d571f71d04559a4d9936e1fce75152ea4f07e0ef0f8b0052e968cada1f30fa9ad41881e1d4536f64fb9df558714c0a5617c967357324e7fc49caf3021794b4b64013b1c29175ddfc41a85e403bbe3639cdaeed26053dbf58fc567adb94d95fa8072d4fe149efa3ff20fcad934cf233b1e119495eff7ce4bd96b869716ccf10a4da73fa8d20758aad258f43ac403220f7134f4d6ce8aad47f907b27031e54550d438c3c9cd96e7c5b831d2c389d09974514d36a65540856e52b4494e6dc0101c9f0f4c41c379fd1e01be72f13d66ad9fdfc4e73319dcb37731736bf63ee5b5e1363f40ab7e612a9f1b1e65c6e436d5c1b01af5524b96a6c9bbc2f97bcc37bd11742296ec28a046f3baf80781873f592308e147b22e127ab01e6632f0f05fca407e45493f652b9b39f744b06654956621928fe38e20f288d456c86387caae34632db574f22fc3946197830b58eaaa5302cf7d47afb12942da798c2d50bb77c6f9f40d8292dbd436af67047c975f9cee919781a972eca1d1042024ec087af341eb7258ba0fa79698ee45361e9c2d87035944c988b17d8f19dba016bbe4d6f8353047be10f76a1d6fb5c5e4926560197e64bceb4c03811caf5fdc30d00a9b9c9d34c2bf86f47de712033d0ad3a9124a872100ed7d650292b50aa8168badcd12aaa8653926734ce949953ddee3e75220fba53d153f7ce1b08d5b800e891ea5787be32112f3f68323a9ad8305a86d257b927901b084b0af57314f9a74de0f6bccf0775d73a0204fa059edfaf68e180ed298ce89243e8eb437741092420975b0cb192de88c73b77a5c501ed026e106cfdd8b6cc189e8ede4878156e8fbf977208e16f6bb0459f5cbc30c721bc42a1d2df1ac663f26ae6a8391af74c88144bccc58d382b2c837ec26383e2e22d693a82814948b5290f71ae5ee3cb8b3b6275bf690352bca6fa946a9285b079bde656204960083240bfe3bab2d1bc68080eaf91ace971cab0d1b7ba5441920daf98c96aa9e4f19adba551e5588141b930a8f9e3faee68ec3f6d28aa0a8e5ab767b86ff59057953964efb152177784288ae3bcf49448faebf53b9e63a8c7389412faa3347c2d27b248026d0994127415c376b35dad46632066b4e6451b7941bc93c7e0fca86779328f5c05d2787009dbd606803ba01491e8f045b4eed7c7f482da14b10f63e6dac6e6a92f4cd6d7fab411338fe57f2fd88764f3f77c03d83a45b143c7f76b396ef7f73cffc332c4c0a1d1f4e36e06ebeba0f17f6ee0d4ddd977f5b63eeb8bf0a4001ff6fa4062e672d87ff6a44729b79c6a9811cbf3170a283077526fd9fe0c97b117bee440dc5409e97d9ef114e9d370cc6449ad00c9720f4743e01cb362bc7a001b7c897f\n  \n    \n      \n      \n        错误太蠢，加密了QAQ\n      \n    \n  \n\n","categories":["OI"],"tags":["总结"]},{"title":"lower_bound和upper_bound——从零基础到入门","url":"/articles/stlbound/","content":"\r\nlower_bound(begin,end,val)：在值有序的数组连续地址[begin,end)中找到第一个位置并返回其地址，使得val插入在这个位置前面，整个数组仍然保持有序。\r\nupper_bound(begin,end,val)：在值有序的数组连续地址[begin,end)中找到最后一个位置并返回其地址，使得val插入在这个位置前面，整个数组仍然保持有序。\r\n\r\n假如排序后的数组名为a，可以认为其返回值减去数组名a（其实等于a[0]）刚好等于所要找的元素的数组下标。\r\n我们可以用lower_bound和upper_bound求数的出现次数，即upper_bound()-lower_bound()。\r\n完结撒花！\r\n","categories":["OI"],"tags":["笔记"]},{"title":"vector——从零基础到入门","url":"/articles/vector/","content":"\r\n来自于一个邻接表建图建了半天没建明白的蒟蒻，他现在已经改用结构体存图了\r\nSTL大法好\r\n\r\nvector可理解为变长数组，它的内部实现基于倍增思想。\r\n前置芝士\r\n设，为vector的实际长度和最大长度。\r\n向vector加入元素前，若，则在内存申请的连续空间，并把内容转移到新的地址上（同时释放旧的空间），再执行插入。从vector中删除元素后，若，则释放一半的空间。\r\nvector支持随机访问，即对于任意的下标，可以像数组一样用取值。\r\n但它不是链表，不支持在任意位置插入。为了保证效率，元素的增删一般应该在末尾进行。\r\n声明\r\n#include &lt;vector&gt;vector&lt;int&gt; a;vector&lt;int&gt; b[233];//第一维长233，第二维长度动态变化struct rec{}vector&lt;rec&gt; c;\r\n操作\r\nvector&lt;int&gt; a;a.empty();//返回一个bool类型，表明a是否为空a.resize(10);//将a的元素个数调整为10，多删少补，值随机a.resize(10,2);//将a的元素个数调整为10，多删少补，值为2a.reserve(100);//将a的容量扩展为100a.swap(b);//将a和b中的元素整体交换reverse(a.begin(),a.end());//将元素翻转，逆序排列a.size();//返回vector的实际长度（包含的元素个数）a.clear();//把vector清空a.back()//返回尾a.front();//返回首a.insert(a,begin()+i,qwq);//在第i个元素后面插入qwqa.push_back(qwq);//尾部插入qwqa.pop_back();//删除尾a.at(i);//访问i号元素a.erase(a.begin()+i);//删除第i+1个元素a.erase(a.begin()+i,a.end()+j);//删除区间[i,j-1]\r\n","categories":["OI"],"tags":["笔记","STL","vector"]},{"title":"rope——从零基础到入门","url":"/articles/rope/","content":"众所周知，可以用STL里的rope实现简单的可持久化数据结构。\r\n","tags":["数据结构","STL"]},{"title":"位运算——从零基础到入门","url":"/articles/bit-operation/","content":"\r\n左移：左移一位，相当于某数乘以。比如左移位变为  变为，表示为。因此左移位,相当于该数乘以。\r\n右移：右移一位，相当于某数除以，比如右移1位变为  变为，表示为。因此右移位，相当于该数除以。\r\n与运算：按位进行“与”运算，两数同一位都为时结果为，否则为。例如：&amp;=。与任何数都为。\r\n或运算：按位进行“或”运算，两数同一位都为时结果为，否则为。例如：|=。\r\n非运算：按位取反。例如~=；\r\n\r\n若当前状态为s，对s有下列操作。 1. 判断第位是否为：\r\n(s&amp;(1&lt;&lt;i))==0，意思是将左移位与s进行与运算后，看结果是否为。 2. 将第位设置为：\r\ns|(1&lt;&lt;i)，意思是将左移位与s进行或运算。 3. 将第位设置为：\r\ns&amp;~(1&lt;&lt;i)，意思是s与第位为，其余位为的数进行与运算。\r\n例如：s=，；\r\ns&amp;(1&lt;&lt;i)：&amp;=；\r\ns|(1&lt;&lt;i)：&amp;=；\r\ns&amp;~(1&lt;&lt;i)：&amp;=；\r\n发现自己真的是鱼，半个多月前学的位运算现在基本都已经忘得差不多了（悲）\r\n","categories":["OI"],"tags":["笔记","位运算","进制"]},{"title":"优先队列——从零基础到入门","url":"/articles/priority-queue/","content":"优先队列，就是一种容器，默认它的第一个元素即堆顶为最大值。\r\npriority_queue可以理解为一个大根二叉堆（然鹅这东西我也不会）。\r\n常用操作\r\n\r\nq.push(x)：把元素插入堆，时间复杂度为\r\nq.pop()：删除堆顶元素（即最大值）\r\nint x=q.top：查询堆顶元素（即最大值）\r\n\r\n定义\r\n\r\n从大到小（大根堆）：priority_queue&lt;int&gt; q;或priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; q\r\n从小到大（小根堆）：priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;\r\n\r\n注意：最后的空格：&gt; &gt;\r\n结构体与优先队列\r\n需要重载运算符“&lt;”，举个栗子：\r\n#include &lt;bits/stdc++.h&gt;using namespace std;struct node{    int x,y;    bool operator &lt; (node a)const    {    \treturn x&gt;a.x;\t}}gg;int main(){ \tpriority_queue&lt;node&gt; q;\tfor(int i=1;i&lt;=3;i++)\t\tcin&gt;&gt;gg.x&gt;&gt;gg.y,q.push(gg);\tcout&lt;&lt;q.top().x&lt;&lt;q.top().y;\treturn 0;}\r\n然后就可以像正常的优先队列一样使用啦（上面的代码建立的是小顶堆）！\r\n当然我们还可以结构体外重载运算符：\r\n#include &lt;bits/stdc++.h&gt;using namespace std;struct node{    int x,y;}gg;bool operator &lt; (node a,node b){    return a.x&gt;b.x;}int main(){ \tpriority_queue&lt;node&gt; q;\tfor(int i=1;i&lt;=3;i++)\t\tcin&gt;&gt;gg.x&gt;&gt;gg.y,q.push(gg);\tcout&lt;&lt;q.top().x&lt;&lt;q.top().y;\treturn 0;}\r\n","categories":["OI"],"tags":["笔记","STL","优先队列"]},{"title":"倍增求LCA学习笔记","url":"/articles/lca/","content":"\r\n","categories":["OI"],"tags":["笔记","数据结构","倍增","LCA"]},{"title":"倍增——从零基础到入门","url":"/articles/undefined/","content":"简介\r\n倍增，顾名思义就是成倍增长，主要是在进行递推时，如果状态空间很大，通常的线性做法无法满足时间与空间复杂度的要求，可以通过成倍增长的方式，递推状态空间中在的整数次幂位置上的值作为代表。当需要其他位置上的值时，通过“任意整数可以表示成若干个的次幂项的和”这一性质，使用之前求出的代表值拼成所需的值。\r\n“倍增”与“二进制划分”思想结合，降低了很多问题的时间与空间复杂度。\r\n应用\r\n快速幂\r\nRMQ\r\nLCA\r\n","categories":["OI"],"tags":["笔记","倍增"]},{"title":"函数大全（持续更新）","url":"/articles/function/","content":"字符串类\r\n\r\nreverse：字符串反转。\r\nreverse(a,a+4)：把从a[0]到a[4]翻转\r\nreverse(a.begin(),a.end())：STL中或string类型的使用\r\n\r\n排序类\r\n计算类\r\n不知道类\r\n","categories":["OI"],"tags":["笔记","技巧"]},{"title":"光速乘学习笔记","url":"/articles/fastmul/","content":"前置芝士\r\n龟速乘\r\n光速乘\r\n虽然龟速乘已经很优秀了，但是还是不够，所以我们要用到一种更高级的、不需要黑科技__int128的快速乘——光速乘。\r\n还是那个熟悉的问题：。\r\n可以发现，。\r\n于是乎，我们巧妙运用unsigned long long的自然溢出特性，就可以解决这个问题。\r\n关于使用long double造成的精度问题，可以看这里。\r\n代码如下： inline ll ksc(ll a,ll b,ll p) {    ull c=(ull)a*b-(ull)((lb)a/p*b+0.5L)*p;    return (c+p)%p;}\r\n","categories":["OI"],"tags":["笔记","技巧","数学"]},{"title":"卡特兰数学习笔记","url":"/articles/catalan/","content":"卡特兰数，又称卡塔兰数（Catalan\r\nNumber），是组合数学中一个常用的数列。其前几项为：\r\n关于这个数列，显然我们是找不出什么规律的，所以直接把公式送给大家QwQ：\r\n\r\n递归公式： \r\n递归公式： \r\n组合公式： \r\n组合公式： \r\n\r\n","categories":["OI"],"tags":["笔记","数学"]},{"title":"同余性质学习笔记","url":"/articles/coresidual/","content":"前置芝士\r\n费马小定理、欧拉定理\r\n同余性质\r\n整数，，；自然数，；模。\r\n\r\n自反性：。\r\n对称性：若，则。\r\n传递性：若，，则。\r\n同加性：若，则。\r\n同乘性：若，则。\r\n一般情况，若，，则。\r\n同幂性：若，则。\r\n若，，，互质，则。\r\n\r\n","categories":["OI"],"tags":["笔记","数学","同余"]},{"title":"区间DP学习笔记","url":"/articles/sectiondp/","content":"\r\n","categories":["OI"],"tags":["笔记","DP","区间DP"]},{"title":"向心力的6个公式","url":"/articles/centripetal/","content":"一直背不下来QAQ\r\n向心力，线速度，角速度，周期，频率，转速。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","categories":["whk"],"tags":["笔记","物理","力学","公式"]},{"title":"图的存储学习笔记","url":"/articles/graph-memory/","content":"开幕雷击\r\n\r\n\r\n图(A)\r\n\r\n\r\n\r\n图(B)\r\n\r\n\r\n\r\n图(C)\r\n\r\n二维数组邻接矩阵存储\r\n定义int g[105][105]。\r\n的值，表示从点到点的边的权值，定义如下：\r\n\r\n当与之间有边或弧时，取值为（不带权）或权值。\r\n当与之间无边或弧时，取值为（不带权）或。\r\n\r\n举个例子：\r\n\r\n图(A) \r\n图(B) \r\n图(C) \r\n\r\n代码如下：\r\n#include &lt;bits/stdc++.h&gt;using namespace std;int i,j,k,e,n;double g[105][105];double w;int main(){    cin&gt;&gt;n;\tmemset(g,127,sizeof(g));    cin&gt;&gt;e;    for(k=1;k&lt;=e;k++)    {        cin&gt;&gt;i&gt;&gt;j&gt;&gt;w;        g[i][j]=w;        g[j][i]=w;//有向图省略    }    return 0;}\r\n数组模拟邻接表存储\r\n前置芝士\r\n\r\n出边：以这个结点为起点的边。\r\n入边：以这个结点为终点的边。\r\n\r\n图的邻接表存储法，又叫链式存储法。\r\n\r\n可以采用数组模拟链表。\r\n适合于稀疏图。\r\n\r\n​ 对于一个有个点条边的图，在使用\r\n代码如下：\r\n#include &lt;bits/stdc++.h&gt;using namespace std;//寄了，建不明白了，我不适合图论，然鹅今年CSP-S三道图论题，寄\r\n","categories":["OI"],"tags":["笔记","图论"]},{"title":"字符串Hash学习笔记","url":"/articles/string-hash/","content":"前置芝士\r\n哈希算法\r\n哈希算法是通过一个哈希函数H，将一种数据（包括字符串、较大的数等）转化为能够用变量表示或是直接就可作为数组下标的数。\r\n哈希值\r\n通过哈希函数转化的得到的数值。\r\n可以通过哈希值实现快速查找和匹配。\r\n字符串Hash\r\n简介\r\n寻找长度为的主串中的匹配串（长度为）出现的位置或次数的问题属于字符串匹配问题。\r\n朴素的想法是枚举所有起始位置，再直接检查是否匹配。\r\n可以不适用的直接比较字符串的方法，而是比较长度为的主串S的子串的哈希值是否相等，这就是哈希算法的原理——字符串Hash。\r\n流程\r\n\r\n前置芝士：进制转换\r\n\r\n如果我们用的时间计算长度为的字符串的哈希值，那么我们就没必要学字符串Hash了。\r\n所以我们需要用到一个叫做滚动哈希的优化技巧。\r\n我们选取两个合适的互质常数和（），假设字符串，那么我们定义哈希函数：。\r\n正常的数字是十进制的，这里是基数，相当于把字符串看作是进制数。\r\n这一过程是递推计算的。因为我太菜了下面讲解省略求模运算，因为可以用自然溢出大法！！！\r\n 举个栗子：\r\n字符串，令A表示1，B表示2。  判断字符串从位置开始的长度为的子串的哈希值与另一匹配串的哈希值是否相等。 \r\n容易证明，上面的柿子是正确的，所以大家牢记即可。\r\n于是只需要预求得，就能在时间内得到任意字符串的子串哈希值，从而完成字符串匹配。于是乎，字符串匹配问题的算法时间复杂度就为。\r\n举个栗子：\r\n字符串，，，。 \r\n正确性\r\n出现不同字符串哈希值相等的概率越低越好。\r\n所以有以下两种方法：\r\n\r\n自然溢出法\r\n利用unsigned long long无符号整数计算哈希值，相当于对哈希值。\r\n双模法\r\n顾名思义，就是搞一个二元数组存储哈希值，两个数，两个数都相同哈希值才相同。\r\n\r\n在速度上单模法会被自然溢出法虐，在正确率上单模法不如双模法和自然溢出法（毕竟自然溢出法的重复概率是），所以它是废物，所以不介绍单模法了QwQ。\r\n实现\r\n练手板子题\r\n友情赠送板子题代码（自然溢出法）：\r\n#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;//POJ不支持万能头QAQusing namespace std;typedef unsigned long long ull;const int maxn=1e6+5,maxm=1e4+5;ull power[maxn],hash[maxn];char s1[maxm],s2[maxn];int b=520;int main(){    power[0]=1;    for(int i=1;i&lt;1e6;i++)        power[i]=power[i-1]*b;    int t;    cin&gt;&gt;t;    while(t--)    {        scanf(\"%s%s\",s1+1,s2+1);        int n=strlen(s1+1),m=strlen(s2+1);        hash[0]=0;        for(int i=1;i&lt;=m;++i)            hash[i]=hash[i-1]*b+(ull)(s2[i]-'A'+1);        ull s=0;        for(int i=1;i&lt;=n;i++)            s=s*b+(ull)(s1[i]-'A'+1);        int ans=0;        for(int i=0;i&lt;=m-n;i++)            if(s==hash[i+n]-hash[i]*power[n]) ++ans;        cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}\r\n完结撒花！\r\n","categories":["OI"],"tags":["笔记","字符串","Hash"]},{"title":"异或操作——从零基础到入门","url":"/articles/xor/","content":"前置芝士\r\n位运算\r\n异或操作\r\n简介\r\n异或操作，是指两个数或者多个数之间进行的一种相同为、不同为的位运算。\r\n异或操作通常用或^表示。\r\n运算律\r\n\r\n，\r\n结合律\r\n交换律：一堆数在一起进行异或操作时，可以按任意顺序进行。\r\n\r\n应用\r\n\r\n交换两个数\r\na = a^b;b = a^b;a = a^b;\r\n找到某个数\r\n一个数组中只有一个数出现了奇数次，其余数都出现了偶数次，如何找到这个出现奇数次的数？\r\n根据异或运算的性质，一个数与自己异或等于零，一个数与异或等于本身可知，只需将数组中的所有数进行异或操作即可将出现偶数次的数消掉，得到出现奇数次的。\r\n……\r\n\r\n完结撒花！\r\n","categories":["OI"],"tags":["笔记","位运算","进制"]},{"title":"图论前置芝士","url":"/articles/graph/","content":"图的定义\r\n点用边连起来就是图。严格意义上讲，图是一种数据结构。\r\n常用名词集合\r\n有向图\r\n图的边有方向，只能按箭头方向从一点到另一点。\r\n无向图\r\n图的边没有方向，可以双向。\r\n节点的度\r\n无线图中与结点相连的边的数目。\r\n结点的入度\r\n在有向图中，以这个结点为终点的有向边的数目。\r\n结点的出度\r\n在有向图中，以这个结点为起点的有向边的数目。\r\n权值\r\n边的“费用”。\r\n连通\r\n如果图中结点U、V之间存在一条从U通过若干边、点到V的通路，则称U、V是连通的。\r\n回路&amp;环\r\n起点和终点相同的路径。\r\n阶\r\n图中结点的个数。\r\n完全图\r\n一个阶的完全无向图含有条边；一个阶的完全有向图含有条边。\r\n稠密图\r\n一个边数接近完全图的图。\r\n稀疏图\r\n一个边数远远少于完全图的图。\r\n强连通分量\r\n有向图中任意两点都连通的最大子图。\r\n特殊地，单个点也算一个强连通分量。\r\n奇点\r\n跟这个点相连的边数目有奇数个的点。\r\nE、V\r\nE代表边的集合，V代表结点的集合。\r\n","categories":["OI"],"tags":["笔记","图论"]},{"title":"快速幂学习笔记","url":"/articles/quickpow/","content":"引入\r\n\r\n求。\r\n\r\n快速幂\r\n对于\r\n\r\n若是偶数，则；\r\n若是奇数，则。\r\n\r\n继续将分解成、……次后，就会变成。我们称这种快速计算幂运算的方法为快速幂算法。\r\n代码如下：\r\n\r\n递归版\r\nint quickpow(int a,int b,int n){    if(b==1) turn a;    if(b%2==0)    {        int t=quickpow(a,b/2,n);        turn t*t%n;    }    else    {        int t=quickpow(a,b/2,n);        t=t*t%n;        t=t*a%n;        turn t;    }}\r\n非递归版\r\nint quickpow(int a,int b,int n){    int t=1;    while(b)    {        if(b%2==1) t=t*a%n;        a=a*a%n;        b=b/2;    }    return t;}\r\n\r\n\r\n练手板子题\r\n\r\n","categories":["OI"],"tags":["笔记","数学"]},{"title":"廿四的雪(1)","url":"/articles/24snow/","content":"\r\n\r\n下雪啦！\r\n\r\n","categories":["随笔"],"tags":["廿四的雪"]},{"title":"我的2022","url":"/articles/my2022/","content":"中考前篇\r\n九上期末\r\n要写我的，其实要从年的年末开始。\r\n话说那是一次西安交大少年班的考试，我十分愚蠢地报了名，其实这也没啥；但是，在校内人选的选拔中，由于是按照八年级下的期末考试成绩排名的（注意当时我们已经初三了诶！但是还是初二的成绩），再加上我们居然要和大佬云集的理工本部一起比成绩，期末考试拉胯的我自然是以一名之差成功落选，其实这也没啥嗷（其实有啥，毕竟可以去西安交大玩儿诶0v0谁不想呢）；但是，居然被隔壁班的某哥们儿暗戳戳的嘲讽了QAQ，寄😭，结果就因为这次刺激，我成功地发奋学习了一个月（具体就是每天学到点，然后记忆特别深的是当时我把理化的错题都手敲了一遍打印出来，加起来能有五六十页纸（由此可见我的蒻，错的题都快赶上对的了呜呜呜），导致那个学期我的物理化学笔记本超级厚），然后期末考试还是寄了吧，据说算政史是名，不算政史可能是年级前了（注意看今年我们一共只有个的还有一个学习很牛的特长生），所以说我肯定是和无缘了嗷。\r\n寒假\r\n然后我的寒假就开始了。这个寒假也是一个难忘的寒假。主要内容包括：爆看冬奥会每场有中国的比赛+爆抄本练习册答案，注意看，这时候的我还在抄中考复习练习册的答案，这么看我开学考试肯定是要寄了，事实的确如此。不过看冬奥会其实不是没有一点用处，我中考语文议论文撞大运考可能也是跟看冬奥会有关ψ(｀∇´)ψ。\r\n\r\n插入一段，说到这儿不多不少我中考之后的私信还被徐梦桃回复了诶0v0：\r\n\r\n\r\n私信被世界冠军回复！！！\r\n\r\n（具体内容就是感谢桃姐的论据让我在议论文上嘎嘎乱杀)\r\n\r\n书接上文，讲到了我在中考前最后一个假期的离谱经历，当时其实没有想那么多，貌似是觉得时间还很充裕（?）或者感觉自己稳了（?也不知道是稳上啥，可能是三甲吧QwQ），现在发现自己真是心大。\r\n备考\r\n假期很快就结束乐，但是貌似开学不久就又回归线上了，然鹅本心大人居然都没拿几本书回家（虽然当时离中考已经只有天啦啦啦啦），然后好像百日誓师就是线上开的，再然后天也是线上开的，上了一个多月网课之后初三就开学了。关于网课的听课效果我觉得还行吧，毕竟我是那种再上课时候喜欢疯狂发言（当然现在越发腼腆）的性格（笑），回归线下乐！\r\n然鹅，回归线下之后直接就来了一场双基，没记错的话（肯定不会记错）是年级名，这个成绩差不多是中水平吧，当时可能有一点心理波动（因为我的心理定位是名左右，上个育明也不错😉），但是想想初中三年，从一开始被很多人看好，到后来逐渐成为了年级笑话（浅浅提一下我的黑历史，包括但不仅限于把老师气得上不了课，被班主任赶回家，撤凳子发蹲一个上午……），可能那些曾经看好我的老师都认为我是个华而不实的弱鸡吧，想想其实也挺不甘的，但是没办法，初中三年教会我最重要的就是：拿实力说话，没有实力，没人会把你当根葱；你要是够强，你怎么样都是好的。\r\n双基之后，度过了一段平淡的时光，现在想想备考的日子其实很美好，那种紧张中带着一丝放松，焦虑中带着一丝释然，真的好好。这期间发生的一件最重要的事就是：我已经全面放弃记叙文了（因为我的记叙文分数上限就是56呜呜呜），感谢这次选择，要不就不会有我那中考杀疯了的语文分数和我出人意料的结果。\r\n紧接着就是一模了（突然发现的前半段全部都是围绕着中考的(✿◡‿◡)），算是我的一个辉煌时刻吧，虽然只是年级，但是谁能想到我是在数学动点暴扣分再搭配上班级倒数的语文成绩下达到的呢。写到这儿我突然想起来前文那个隔壁班的哥们儿，他在上述的所有考试其实是初二以来的所有考试都在薄纱我（悲，不过马上就要上演逆转大戏了，当然上了高中我又被他薄纱了）。这里还要提到一位我的发小，之前我和她的成绩算是同病相怜，结果到了双基我已经是被单方面薄纱了。写到这儿发现自己又菜又没用，呜呜呜，可能我的水平就是育明了（悲）。发现现实好残酷，小学的时候人人都觉得上是小菜一碟（甚至初一初二我都觉得还有机会），后来逐渐被现实击垮了。不甘心，但是实力不行。话说期末考试之后我们晚课分出来一个小班（这是可以说的吗），在这个小班里我当然是被疯狂薄纱，还记得前面说的隔壁班哥们儿吗（他现在居然还在我隔壁班），他分钟一道题，我分钟都切不了，作出的正解辅助线都能被我给写挂，寄。记得当时我们有数学晚课前个小时都是小考试，一道一道，做完了才能去吃饭啊啊啊啊，结果每次我都是最后一个做完的（数学老师还是我们班主任结果我每天被疯狂鄙视呜呜呜），我天我的数学水平居然被一个现在要选文的女生嘎嘎乱杀这岂是我能忍的，但是我真的不会呜呜呜感觉自己好没用呜呜呜他们分钟就能全切我却一直卡着呜呜呜，题暴力解法也能写挂呜呜呜，所以每天数学晚课就成了我的减肥日，根本吃不上饭呜呜呜，好不容易食堂整点儿人吃的东西啥也抢不上呜呜呜；物理晚课多选题训练，我直接一看到托里拆利实验装置就傻眼一遇到浮力压强就懵逼但是其他人全都哐哐列式只有我哐哐懵逼哐哐瞎搞，寄；英语晚课写作文，别人：高中四六级雅思托福词汇，我：乱套句式+疯狂套路+小学词汇。寄。\r\n紧接着就是二模了，突然发现自己真是鱼，居然连中考前的事儿都已经忘了呜呜呜，我现在连圆周运动公式都记不住呜呜呜，我好没用呜呜呜，不过二模好像也挺平常的，但是遗憾也肯定有，比如没有成功AK一张数学卷（初中数学从未拿过星人）（但是二模数学是真的简单），比如语文作文开头爆改字不知道的还以为我已经成一代绝世文豪了写作文怎么飘逸，一看分数成功挂大分稳稳拿下，这一次的排名是，因为这次考试的难度所以有很多后起之秀来到了那个小班，但毕竟是后起之秀所以我本以为自己能在数学和物理上找回自信但没想到我居然被曾经年级名开外的选手乱杀呜呜呜我好没用。\r\n二模之后就是最激动人心的环节——报考！！！当然我没有丝毫犹豫因为太菜报了指标育明、统招+育明、统调是啥我忘了，反正就是纯托底选择，普高本来说是文谷，结果文谷不能保证我不去渤海，所以报考结束的几小时前临时改成了中（很长一段时间里我认为这里才是我的归宿）。话说这其中也想过报冲一下，毕竟很多一模年级前十二模都掉出前二十了还报了，所以在那张愚蠢的腾讯文档表格里有一段时间我是在那一栏的，然鹅后来我被嘲了，也被别的家长嘲了，所以后来只能改成育明，注意看此时此刻以我的成绩在报育明的人里是绝对是数一数二，然鹅马上转折就来了。\r\n报考结束之后感觉大多数人好像都觉得自己报的啥就能考上啥（说白了就是飘了），但是我不敢啊，因为就在去年我认识的一个学习超好的小哥哥就是因为中考前觉得自己稳了结果最后分之差从直接掉到中了，所以我必须以此为鉴！！！所以中考前的一两周当别人都在play的时候只有我在默默地胡乱study（其实还是实力不行，怕自己中考挂了），然后中考前还请了几次短假自己在家整理了一些知识，好像就是这样。\r\n然后就是中考啦啦啦啦啦！中考前一天还真是有点儿小感动（毕竟是朝夕相处了年呢），老师、同学……可能中考之后就很难再见面了。当时可能大多数人都觉得我稳了吧（但是马上就要到转折点了0v0），记得当时团员要交块钱团费，我去送的时候收团费的老师还跟我说了一声加油，挺感动的。这所学校，真的就要和我分开了，还是有一些不舍的呜呜呜，其实自己挺容易被感动的。（多愁善感的基因）\r\n中考篇\r\n（其实这一段在之前貌似写过）\r\nDay 1\r\n语文\r\n具体可以看我前面的朋友圈内容乐，当时记忆比较深的就是别人都在大太阳底下站着唠嗑等待入场，然后我因为没找到同学一个人跑到那个木亭子下面看我蒟蒻的笔记，然后进了考场答题，嗯，挺顺的，作文和大阅读可能卡了一下，但也还好吧。\r\n估分：，运气好的话+\r\n理化\r\n同样挺顺的，物理它没出浮力和压强啦啦啦啦啦！当时出考场听到有人说难（?）有人说简单，我觉得简单的有点儿让人不敢相信。（真的，非凡尔赛）\r\n估分：+=\r\nDay 2\r\n数学\r\n寄了。前面答得还挺顺手，题折纸题不会果断放弃（直到最后我都不会正解，直接拿刻度尺+量角器瞎搞算的破数居然对了），到了题看了看旁边的哥们儿，嗯，比我慢一点儿，还行，现在距离考试结束还有一个多小时，然鹅谁会想到我在接下来的一个多小时里颗粒无收😭。\r\n先开，送分；开始瞎搞结果发现自己假证了，寄；想开，又不会。忙活了一会儿，胡写几个相似三角形证明，写了一波假证上去，跑了。毕竟题切不掉我已经习惯了呜呜呜。瞎搞操作熟练的让人心疼。\r\n再开，送分；好像是一道很水的计算题，切了；看起来很简单，一上手做直接被我的暴力解法搞成了次方程，不会解，扔那儿，摆了。\r\n在考场上估了个分，吧，不过当时我还天真的以为这次数学超级难，大家都不会，嗯，还行。\r\n看了看旁边的哥们儿，呦呵，他题好像切了，难不成这题其实很简单？\r\n接下来一直到考试结束的半小时里，我就开始在、之间反复横跳，期间还水掉了题，但是其他的没有一点进展啊啊啊啊啊啊啊啊。\r\n还有分钟，看了看旁边的哥们儿，呦呵，他题好像也切了，难不成这题其实很简单？\r\n难道他是绝世高手？还是我寄了？\r\n出考场，听到有人说数学简单，比一模简单（?），一模我可是切了啊，满脑问号.jpg。算了，不管了。\r\n估分：\r\n英语\r\n很顺手，考试结束前还检查出来一个价值分的愚蠢错误。\r\n估分：\r\n崩溃\r\n考完英语，听到了一堆人说数学简单，、都切了，连之前数学难优秀的几个女同学居然都全切了在考场外面拉着数学老师的手活蹦乱跳，只有我据说手脚冰凉。\r\n回家就崩溃了，应该是寄了。数学就得和别人差+。完了，天要亡我。\r\nDay 3\r\n政史\r\n凑数用。唯一记得的就是那天下雨了，结果我下车的时候校长就在马路对面，给我喊了个加油，可是我已经寄了诶╯︿╰。感觉自己会成为下一届的标准反面教材，最有希望却摔得最惨。\r\n估分：必过\r\n中考后篇\r\n中考后玩了几天吧，还拍了毕业照，同学老师问我考得怎么样，我只能说寄了，说自己数学的惨，结果他们都不信（?），崩了，真的感觉完了。\r\n7.14\r\n出分日。\r\n本来说点出分，后来改成了点，本来想先睡一觉，结果一直睡不着。\r\n实际：\r\n乐了！！！数学瞎搞居然给了我这么多过程分！！！两道题加在一起只扣分诶！！！\r\n和同学比了一下，出乎意料的高，年级第，我天，历史最佳成绩了。\r\n还记得那个隔壁班的哥们儿吗，时隔两年，我终于有一次战胜了他。\r\n一堆老师来问我分（甚至还有前面那位收团费的老师），结果全惊了，毕竟在这之前连我自己都觉得我寄了，已经做好去中报道的准备了。\r\n泪目了。不负我。\r\n7.20\r\n出录取结果日。\r\n其实还在纠结这个分够不够的统招，我觉得挺稳的，果然，高分踩统招线入学。虽然没进羟基班但已经是意外之喜了。毕竟我是蒟蒻爆发户。有效防止了我在羟基班被人薄纱\r\n开始了自己在廿四被薄纱的日子\r\n新生活篇\r\n\r\n学了OI（但是我好菜呜呜呜希望假期结束能有所长进吧呜呜呜）\r\n当了一种很新的班委——纪律委员。这个职务可能别的班都没有吧。主要是由于班的特殊性。说到我是怎么当上的，其实挺奇妙的（毕竟曾经的我可是开班会被点名批评的不安定分子）。话说期中考试结束后的一天，老师叫鸡哥出去，然后我蚌埠住了乐了一下，然后老师就叫我也出去。然后老师表扬了鸡哥，然后问我能不能管理班级纪律，然后鸡哥蚌埠住了乐了一下，然后我就乐了，然后我就说能，然后就没有然后了。\r\n真心希望有一天班不需要纪律委员来管纪律，大家都能自己管好自己的纪律啊（相信会的OwO）\r\n认识了很多新同学\r\n学到了很多东西（比如自己真的很菜）\r\n考了一次期中考试，寄了\r\n期中考试之后努力学习了，不知道期末考试怎么样\r\n被薄纱\r\n得了一次新冠，已经好乐\r\n\r\n终章\r\n这篇年终总结算是结束了，现在想想我的真是跌宕起伏又精彩纷呈呢。\r\n年结束了，我很怀念它。\r\n年，对我好一点啊QwQ。\r\n\r\n愿一切美好，都能如愿以偿。\r\n\r\n","categories":["随笔"],"tags":["回忆","我的20××"]},{"title":"树状数组——从零基础到入门","url":"/articles/tree-array/","content":"\r\n","categories":["OI"],"tags":["笔记","数据结构","树状数组"]},{"title":"欧拉距离与曼哈顿距离","url":"/articles/euler-manhattan/","content":"这个东西看起来很高大上，其实就是非常简单的两个定义QwQ\r\n\r\n欧拉距离\r\n就是我们最熟悉的两点之间距离公式： \r\n曼哈顿距离\r\n相对于欧拉距离，曼哈顿距离的计算更加简单，并且没有开方过程，在计算机的运行过程中误差更小。\r\n 关于曼哈顿距离，有一些有趣的故事QwQ\r\n\r\n\r\n曼哈顿距离的发明者是世纪著名的德国犹太人数学家赫尔曼·闵可夫斯基，他也是爱因斯坦的老师、四维时空理论的创始人。\r\n曼哈顿距离又叫出租车距离，主要是由于在纽约曼哈顿（这也是它为什么叫曼哈顿距离），计算出租车的距离时经常用街区表示，而经过几个街区就是曼哈顿距离的数值。\r\n\r\n\r\n\r\n","categories":["OI"],"tags":["笔记","数学"]},{"title":"欧拉回路学习笔记","url":"/articles/euler-road/","content":"\r\n","categories":["OI"],"tags":["笔记","图论"]},{"title":"汉诺塔问题","url":"/articles/hanoi/","content":"汉诺塔问题，标准递归问题。 #include &lt;bits/stdc++.h&gt;using namespace std;int k=0,n;void mov(int n,char a,char b,char c){\tif(n==0)\t{\t\treturn;\t}\tmov(n-1,a,b,c);\tk++;\tcout&lt;&lt;k&lt;&lt;\":from \"&lt;&lt;a&lt;&lt;\"--&gt;\"&lt;&lt;c&lt;&lt;endl;\tmov(n-1,a,c,b);}int main(){\tcout&lt;&lt;\"n=\";\tcin&gt;&gt;n;\tmov(n,'a','b','c');\treturn 0;} 函数：把片从柱移到柱的函数mov(n,a,c,b)。\r\n\r\n先调用函数mov(n-1,a,b,c)，把片从柱移到柱，柱作为过渡柱。\r\n直接执行\r\n把a柱上剩下的一片直接移到c上。 cout&lt;&lt;k&lt;&lt;\":from \"&lt;&lt;a&lt;&lt;\"--&gt;\"&lt;&lt;c&lt;&lt;endl;\r\n调用mov(n-1,b,c,a)，把柱上的片从移到柱上，柱是过渡柱。\r\n直到减少到就退出。\r\n\r\n","categories":["OI"],"tags":["笔记","递归"]},{"title":"DFS剪枝学习笔记","url":"/articles/dfs-cut/","content":"前置芝士\r\n搜索的进程可以看作是从树根出发，遍历一棵倒置的树——搜索树的过程。\r\n剪枝，顾名思义，就是通过某种判断，避免一些不必要的遍历过程。\r\n剪枝的原则\r\n正确性\r\n保证不丢失正确的结果\r\n准确性\r\n尽可能多地剪去不能通向正解的枝条。\r\n高效性\r\n剪枝的技巧\r\n优化搜索顺序\r\n排除等效冗余\r\n在搜索过程中，如果能够判定从搜索树的的当前节点上沿着某几条不同分支到达的子树是等效的，那么只需要对其中的一条分值进行搜索。\r\n可行性剪枝\r\n在搜索过程中，及时对当前状态进行检查，如果发现分支已经无法到达递归边界，就执行回溯。\r\n某些题目条件的范围限制是一个区间，此时可行性剪枝也被称为“上下界剪枝”。\r\n最优性剪枝\r\n在最优化问题的搜索过程中，如果当前花费的代价已经超过当前搜到的最优解，此时可以停止对当前分支的搜索，执行回溯。\r\n记忆化\r\n记录每个状态的搜索结果，在重复遍历一个状态时直接检索并返回。\r\n类似于对图进行深搜时，标记一个节点是否已经被访问过。\r\n\r\n练手板子题\r\n提示：最优性剪枝、可行性剪枝\r\n\r\n","categories":["OI"],"tags":["笔记","DFS","剪枝"]},{"title":"整数快读模板","url":"/articles/fastread/","content":"inline int read(){\tint x=0,f=1;\tchar ch=getchar();\twhile(ch&gt;'9'||ch&lt;'0'){if(ch=='-') f=-1;ch=getchar();}\twhile(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}\treturn x*f;}\r\n","categories":["OI"],"tags":["模板"]},{"title":"状压DP学习笔记","url":"/articles/compressdp/","content":"\r\n","categories":["OI"],"tags":["笔记","DP","状压DP"]},{"title":"排序方式笔记","url":"/articles/sort/","content":"最好情况下\r\n\r\n冒泡排序\r\n\r\n图解： \r\n\r\n插入排序\r\n\r\n图解： \r\n\r\n\r\n平均情况下\r\n\r\n快速排序\r\n\r\n图解： \r\n\r\n\r\n最坏情况下\r\n\r\n堆排序 （等学会之后再填坑）\r\n归并排序\r\n\r\n图解： \r\n\r\n\r\n","categories":["OI"],"tags":["笔记","排序","算法"]},{"title":"组合数学学习笔记","url":"/articles/combinatorics/","content":"前置芝士\r\n加法原理\r\n若完成一件事的方法有类，其中第类方法包括种不同的方法，且这些方法互不重合，则完成这件事共有：种不同的方法。\r\n乘法原理（分步计数原理）\r\n若完成一件事需要个步骤，其中第个步骤有种不同的完成方法，且这些步骤互不干扰，则完成这件事共有：种不同的方法。\r\n\n            区别：一个与分类有关，一个与分步有关；\r加法原理是“分步完成”，乘法原理是“分类完成”。\r\n          \r\n排列及其公式\r\n线排列\r\n定义\r\n一般地，从个不同的元素中，取出（）个元素按照一定的顺序排成一列，叫做从个不同的元素中取出个元素的一个线排列。\r\n从个不同的元素中取出（）个元素的所有线排列的个数，叫做从个不同元素中取出个元素的排列数，用符号或表示。\r\n排列数公式\r\n\r\n全排列\r\n把个不同的元素全部取出，按照一定的顺序排成一列，叫做个不同的元素的一个全排列。\r\n全排列的方案个数叫做个元素的全排列数，用符号表示。\r\n此时，。\r\n相异元素可重复排列\r\n从个不同元素中可以重复地选取出个元素的排列，叫做相异元素可重复排列。\r\n排列方案数：。\r\n不全相异元素的全排列\r\n圆排列\r\n从个不同元素中选取出个元素，不分首尾地排成一个圆圈的排列叫做圆排列。\r\n排列方案数：；如果，\r\n组合及其公式\r\n非重组合\r\n可重组合\r\n二项式定理\r\n\r\n","categories":["OI"],"tags":["数学","组合数学"]},{"title":"背包问题详解（01背包，完全背包与多重背包）","url":"/articles/bags/","content":"\r\n前段时间学背包问题的时候发现的一篇学长的宝藏博客QwQ，写得真的好\r\n\r\n背包问题\r\n01背包\r\n问题简述：有m个物品待放入一个容量为V的背包，每件物品都有其对应的体积w与价值v，从中选取一些物品放入背包，使得物品总价值最大。\r\n算法思路：考虑动态规划，令f(i,j)为只考虑前i件物品，背包容量为j时能得到的最大价值。那么当只考虑第i件物品放不放时，便有以下两种情况：\r\n1，第i件物品体积大于当前背包容量，不放：f(i,j)=f(i-1,j)；\r\n2，第i件物品体积小于等于当前背包容量，则考虑放与不放哪个更优：\r\nf(i,j)=max(f(i-1,j),f(i-1,j-w[i])+v[i])\r\n那么就得到核心代码：\r\nfor(int i=1;i&lt;=m;i++)    for(int j=1;j&lt;=V;j++)    {       if(j=w[i])            f[i][j]=max(f[i-1][j],f[i-1][j-w[i]]+v[i]);       else            f[i][j]=f[i-1][j];    }\r\n观察状态转移方程式，我们发现，对第i件物品的选择只与对前一件物品的选择有关，于是考虑滚动数组优化空间。\r\n注意：当使用滚动数组时，第二层循环应由V到w[i]。这是因为在状态转移时用到的背包容量均小于等于j，倒着循环可以保证j前面都是只考虑i-1件物品时的数据，而j后面是更新过的前i件物品的数据，这样顺带保证了当j&lt;w[i]，f(i,j)=f(i-1,j)。\r\nfor(int i=1;i&lt;=m;i++)\tfor(int j=V;j&gt;=w[i];j--)   \t\tf[j]=max(f[j],f[j-w[i]]+v[i]);\r\n练手板子题：传送门\r\n01背包Pro\r\n恰好为。\r\nf[0]为，其余为-INF。\r\n完全背包\r\n问题简述：有m种物品待放入一个容量为V的背包，每种物品都有无穷多件且有其对应的体积w与价值v，从中选取一些物品放入背包，使得物品总价值最大。\r\n算法思路：在01背包的基础上，由于每种物品都能被重复选择，考虑从1开始枚举每件物品被选择的次数k直到当前物品所占体积超过容量j，则有：f(i,j)=max(f(i,j),f(i,j-k*w[i])+k*v[i])。由于在每次循环中讨论的都是第i件物品的选择次数，故数组第一维为i，这也决定了在每次对j进行枚举后要将f(i,j)初始化：f(i,j)=f(i-1,j)。\r\n上核心代码：\r\nfor(int i=1;i&lt;=m;i++)\tfor(int j=1;j&lt;=V;j++)\t{        f[i][j]=f[i-1][j];        for(int k=1;k*w[i]&lt;=j;k++)                f[i][j]=max(f[i][j],f[i][j-k*w[i]]+k*v[i]);\t}\r\n观察状态转移方程式，参照01背包的思想再次考虑滚动数组优化：\r\n不难发现，完全背包的第二层循环是无需倒着枚举的。如上文所说，在每次对k进行枚举时讨论的都是对第i件物品的选择，故j前面的数据应为只考虑前i件物品时的数据，所以应正着循环。\r\n再考虑对k的枚举。每次循环都是在前一次循环的基础上多选择一件物品i放入背包，所以可以考虑变乘为加：f(j)=max(f(j),f(j-w[i])+v[i])，进一步优化时间。\r\nfor(int i=1;i&lt;=m;i++)\tfor(int j=w[i];j&lt;=V;j++)\t\tf[j]=max(f[j],f[j-w[i]]+v[i]);\r\n日常板子题时刻：传送门\r\n（不开longlong见祖宗哦\r\n多重背包\r\n问题简述：有n种物品待放入一个容量为V的背包，每种物品都有其对应的数量m，体积w与价值v，从中选取一些物品放入背包，使得物品总价值最大。\r\n算法思路：由于不能无限选择，这个问题又变回了01背包，只是加了对k的枚举。当我们熟练掌握前两种背包，想写出来一个多重背包也就不难了。\r\n核心代码又来了。\r\nfor(int i=1;i&lt;=n;i++)\tfor(int j=V;j&gt;=w[i];j--)\t\tfor(int k=1;k&lt;=m[i]&amp;&amp;k*w[i]&lt;=j;k++)\t\t\tf[j]=max(f[j],f[j-k*w[i]]+k*v[i]);\r\n我们发现，由于物品有数量的限制，第三层循环无法删去，那么又如何对时间进行优化呢？\r\n此时可以考虑使用二进制，由于可以表示之内的所有数，故m件物品一定可以进行二进制拆分成许多堆物品，每堆件又能看作一件质量为，价值为的物品，使复杂度优化一个。\r\n二进制拆分模拟如下：\r\nint vv,ww,mm,cnt=0;for(int i=1;i&lt;=n;i++){\tvv=read(),ww=read(),mm=read();\tfor(int j=1;j&lt;=mm;j&lt;&lt;=1)\t{\t\tv[++cnt]=vv*j,w[cnt]=ww*j;\t\tmm-=j;\t}\tif(mm) \t\tv[++cnt]=vv*mm,w[cnt]=ww*mm;}\r\n然后就是朴实无华01背包啦。\r\n板子：传送门\r\n（几天前用快读不加二进制优化还能卡过呢qwq\r\n","categories":["OI"],"tags":["笔记","算法","转载","背包"]},{"title":"线段树学习笔记","url":"/articles/segement-tree/","content":"\r\n事情的起因来自于年的元旦，一位蒟蒻百无聊赖中误入了大佬们的团队作业，好奇心满满地点开了第一道题，看着一行半的题干信心满满地准备大干一场，调了分钟写出一个分治+DP的思路，直接忽略时间复杂度是的事实，结果UKE了无数次后上CF一测发现第一个点就TLE了😭。然后发现这道题要用线段树优化，痛定思痛从开始学线段树。\r\n啊啊啊明天的团队作业已经出了我要切了它啊啊啊！\r\n\r\n基础\r\n线段树是一种基于分治思想的二叉树结构，用于在区间上进行信息统计。\r\n性质\r\n\r\n线段树的每一个节点都代表一个区间。\r\n线段树具有唯一的根节点，代表的区间是整个统计范围。\r\n线段树的每个叶节点都代表一个长度为的元区间。\r\n对于每个内部节点，它的左子节点是，右子节点是，其中。\r\n\r\n\r\n\r\n线段树的区间视角、二叉树视角\r\n\r\n除去树的最后一层，整棵线段树一定是一棵完全二叉树，树的深度为。\r\n编号\r\n\r\n“父子倍”节点编号\r\n\r\n根节点编号为。\r\n编号为的节点的左子节点编号为，右子节点编号为。\r\n\r\n\r\n保存线段树的数组长度要不小于。\r\n建树\r\n给定一个长度为的序列。。\r\nstruct SegmentTree{    int l,r;    int sum;    int lazy;    //lazy懒标记，下面有讲QwQ}t[size*4];void build(int k,int l,int r){    t[k].l=l,t[k].r=r;    if(l==r){t[k].sum=a[l];return;}    int mid=(l+r)/2;    build(k*2,l,mid);    build(k*2+1,mid+1,r);    t[k].sum=max(t[k].sum,t[k*2+1].sum);}build(1,1,n);\r\n单点查询+修改\r\n从根节点出发，递归找到代表区间的叶节点，然后从下往上更新以及它的所有祖先节点上保存的信息。时间复杂度为。\r\n//change A[x] to vvoid change(int k,int x,int v){    if(t[k].l==t[k].r){t[k].sum=v;return;}    int mid=(t[k].l+t[k].r)/2;    if(x&lt;=mid) change(k*2,x,v);    else change(k*2+1,x,v);    t[k].sum=max(t[2*k].sum,t[2*k+1].sum);}change(1,x,v);\r\n区间查询\r\n查询序列在区间上的最大值。\r\n从根节点开始，递归执行以下过程。\r\n\r\n若完全覆盖了当前节点代表的区间，则立即回溯，并且该节点的值为候选答案。\r\n若左子节点与有重叠部分，则递归访问左子节点。\r\n若右子节点与有重叠部分，则递归访问右子节点。\r\n\r\nint ask(int k,int l,int r){    if(l&lt;=t[k].l&amp;&amp;r&gt;=t[k].r) return t[k].sum;    int mid=(t[k].l+t[k].r)/2;    int val=-(1&lt;&lt;30);    if(l&lt;=mid) val=max(val,ask(k*2,l,r));    if(l&gt;mid) val=max(val,ask(k*2+1,l,r));    return val;}cout&lt;&lt;ask(1,l,r)&lt;&lt;endl;\r\n该查询过程会把询问区间先线段树上分成个节点，取它们的最大值作为答案。\r\n区间修改\r\n前置芝士\r\n延迟标记，可能就是懒标记。\r\n顾名思义，延迟标记就是更新到某一子区间时直接打上标记，延迟对它的子节点的更新操作。但是大家都叫它懒标记，所以下面我们叫它懒标记。\r\n\r\n当lazy[i]!=0时，表示更新过了而的子节点还没有更新。\r\n\r\n其实可以这么理解嗷。以下图为例：\r\n\r\n\r\n举个栗子\r\n\r\n如果我们要修改区间上的值，令其都，那么可以更新区间、、、，每找到一个这样的真包含区间就加上一个懒标记。我们观察到，、的子节点的值没有更新诶，但是没关系，当我们遍历到这个有懒标记的节点时，如果有懒标记，那就可以把它的子节点给更新并且打上懒标记，再把这个懒标记给置。以此类推。\r\n\r\n懒标记要和修改相同，比如要，懒标记就是。\r\n如果要进行乘法操作，和上面的一样，懒标记就是5。\r\n\r\n实操\r\n\r\n乐了，已经崩溃了，自己迷迷糊糊的，不知道能不能写明白。代码就不放出来吓唬人了。\r\n为了不误人子弟我就先咕了，等大彻大悟之后一定回来填坑！！！\r\n给自己找点儿信心：STO ncwzdlsd Orz\r\n\r\n但是，善良的蒟蒻为了防止大家抄题解欣赏别人的代码思路的时候看不懂，还是介绍一下add、pushup、pushdown、change、query操作吧QwQ。呵呵真是一个口是心非的男人\r\n注：下文的均代表当前节点。\r\n\r\nadd：给一个节点进行更新并且打上懒标记。\r\n代码如下：\r\nvoid add(int k,int l,int r,int val){    tree[k].sum+=(r-l+1)*val;    tree[k].lazy+=val;}\r\npushup：把修改上推，即更新父节点的值。\r\n代码如下：\r\nvoid pushup(int k){    //之前用的SegmentTree，现在不拽了，老老实实用tree    tree[k].sum=tree[k*2].sum+tree[k*2+1].sum;}\r\n解释：\r\n\r\n父节点的等于子节点的元素和。\r\n\r\npushdown：把修改下推，即更新子节点的值。\r\n代码如下：\r\nvoid pushdown(int k,int l,int r){    int mid=(l+r)/2;    add(k*2,l,mid,tree[k].lazy);//左子节点    add(k*2+1,mid+1,r,tree[k].lazy);//右子节点    lazy[k]=0;}\r\nchange：修改操作。把全部+val\r\n代码如下：\r\nvoid change(int k,int l,int r,int val){    if(l&lt;=tree[k].l&amp;&amp;tree[k].r&lt;=r)//真包含    {        tree[k].sum+=(tree[k].r-tree[k].l+1)*val;        tree[k].lazy+=val;        return;    }    pushdown(k,tree[k].l,tree[k].r);    int mid=(tree[k].l+tree[k].r)/2;    if(l&lt;=mid)        change(k*2,l,r,val);//左子树与更新区间有交集    if(r&gt;mid)        change(k*2+1,l,r,val);    pushup(k);}\r\nquery：查询区间和。\r\n代码如下：\r\nint query(int k,int l,int r){    if(l&lt;=tree[k].l&amp;&amp;tree[k].r&lt;=r)//当前区间真包含于查询区间        return tree[k].sum;    pushdown(k,tree[k].l,tree[k].r);    int res=0;    int mid=(tree[k].l+tree[k].r)/2;    if(l&lt;=mid)        res+=query(k*2,l,r);    if(r&gt;mid)        res+=(k*2+1,l,r);    return res;}\r\n\r\n动态开点与线段树合并\r\n\r\n不会，正在学习……咕咕咕咕咕\r\n\r\n可能没完结完结撒花！！！\r\n线段树，学了一整天，感觉自己还是半懵状态，不过慢慢来应该会懂的。\r\n不行了，我高低得拜一下自己。\r\nSTO ncwzdlsd\r\n\r\n练手板子题\r\n\r\n我天这道板子题我居然写不明白了回炉重造吧呜呜呜\r\n大家还是不要像我一样用结构体了还是改回数组吧\r\n","categories":["OI"],"tags":["笔记","数据结构","线段树"]},{"title":"莫比乌斯函数——从零基础到入门","url":"/articles/mobius/","content":"前置芝士\r\n质数筛选\r\n莫比乌斯函数\r\n定义\r\n设正整数按照算数基本定理分解质因数为，定义函数\r\n\r\n即为莫比乌斯函数。\r\n理解\r\n当包含相等的质因子时，。当的所有质因子各不相等时，若有偶数个质因子，；若有奇数个质因子，。\r\n求法\r\n若只求一项莫比乌斯函数，分解质因数即可。\r\n若求的每一项莫比乌斯函数，可以使用埃氏筛。先把所以初始化为。对于筛出的每一个质数，令，扫描的倍数，检查能否被整除。若能，则令；否则，令。\r\n代码如下：\r\n\r\n埃氏筛\r\nfor(int i=1;i&lt;=n;i++) mu[i]=1,v[i]=0;for(int i=2;i&lt;=n;i++){    if(v[i]) continue;    mu[i]=-1;    for(int j=2*i;j&lt;=n;j+=i)    {        v[j]=1;        if((j/i)%i==0) mu[j]=0;        else mu[j]*=-1;    }}\r\n线性筛，感谢@bizhidaojiaosha友情提供代码QwQ\r\nfor(int i=2;i&lt;=n;++i){    if(!vis[i]) p[++tot]=i,mu[i]=-1;    for(int j=1;j&lt;=tot&amp;&amp;1ll*p[j]*i&lt;=n;++j)    {        int now=i*p[j];        vis[now]=1;        if(i%p[j]==0) mu[now]=0;        else {mu[now]=-mu[i];break}    }}\r\n\r\n性质\r\n\r\n对任意正整数有：。\r\n对任意正整数有：。\r\n\r\n","categories":["OI"],"tags":["笔记","数学","莫比乌斯函数"]},{"title":"莫比乌斯反演——从零基础到入门","url":"/articles/mobius-inversion/","content":"莫比乌斯反演，顾名思义，就是一种可以简化运算的方法。\r\n定理：和是定义在非负整数集合中的两个函数，，那么 \r\n当然从我这两行的篇幅就可以看出我是一个啥也不会的蒟蒻，所以这里我们祭出大佬的博客。\r\n完结撒花！\r\n","categories":["OI"],"tags":["笔记","数学","莫比乌斯反演"]},{"title":"质数筛选学习笔记","url":"/articles/prime/","content":"Eratosthenes筛选法\r\n顾名思义就是数学家Eratosthenes发明的筛法，但是它的名字太长了，所以我们简称它为埃氏筛QwQ。\r\n基本思想\r\n质数的倍数一定不是质数。\r\n实现方法\r\n用一个长度为的数组保存信息，表示质数，表示合数。先假设所有的数都是质数（初始化为），从小到大枚举每一个质数，把的倍速都标记为非质数（置为）。\r\n如何枚举质数呢？从小到大扫描到时，若未被标记，则它不能被之间的任何数整除，则为质数。\r\n举个栗子：  可以发现，存在重复标记的耗时行为。实际上，小于的的倍数在扫描更小的数时就已经被标记过了。因此，可以优化一下，对于每个，把大于等于的的倍数标记为合数即可。\r\n代码如下：\r\nvoid primes(int n){    memset(v,0,sizeof(v));    for(int i=2;i&lt;=n;i++)    {        if(v[i]) continue;        cout&lt;&lt;i&lt;&lt;endl;        for(int j=i;j&lt;=n/i;j++) v[i*j]=1;    }}\r\n算法的时间复杂度为，效率非常接近于线性。时间复杂度的证明非常复杂，本蒟蒻也不太会，所以不证了QwQ\r\n线性筛法\r\n即使在优化后，埃氏筛仍然会重复标记合数。举个栗子，既会被标记又会被标记，其根本原因是算法不能确定唯一的产生的方式。\r\n所以，我们只要保证合数被它的最小质因数筛去就好啦！时间复杂度为。\r\n代码如下：（添加注释小能手上线）\r\nint v[maxn],prime[maxn];void primes(int n){    memset(v,0,sizeof(v));//存储最小质因子    int m=0;//质数数量    for(int i=2;i&lt;=n;i++)    {        if(v[i]==0)        {            v[i]=i;            prime[++m]=i;        }        for(int j=1;j&lt;=m;j++)        {            //i有比prime[j]更小的质因子或者超出n的范围            if(prime[j]&gt;v[i]||prime[j]&gt;n/i) break;            v[i*prime[j]]=prime[j];        }    }    for(int i=1;i&lt;=m;i++)        cout&lt;&lt;prime[i]&lt;&lt;endl;}\r\n","categories":["OI"],"tags":["数学","埃氏筛","线性筛"]},{"title":"费马小定理、欧拉定理学习笔记","url":"/articles/euler-fermat/","content":"费马小定理\r\n如果是一个质数，而整数不是的倍数，则有。\r\n一般情况：\r\n欧拉定理\r\n欧拉函数\r\n对正整数，欧拉函数是小于等于的数中与互质的数的数目。\r\n引理1\r\n\r\n如果为某一个素数，则：；\r\n如果为某一个素数的的幂次，则：；\r\n如果为任意两个互质的数，的积，则：。\r\n\r\n引理2\r\n设为正整数的素数幂乘积表达式，则：。\r\n欧拉定理\r\n若与互质，则。\r\n","categories":["OI"],"tags":["笔记","数学"]},{"title":"贪心——从零基础到入门","url":"/articles/greed/","content":"简介\r\n贪心算法是从问题的初始状态出发，通过若干次的贪心选择而得到的最优值（或较优值）。\r\n贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，至于当前状态有关。\r\n适用前提是，局部最优策略能导致全局最优策略。\r\n基本思路\r\n\r\n描述问题\r\n分解问题\r\n求解子问题，得到局部最优解\r\n合并子问题最优解\r\n\r\n简单贪心问题\r\n最优装载问题\r\n个物体，第个物体重量为，选择尽量多的物体，使得总重量不超过。\r\n贪心策略：先装最轻的\r\n部分背包问题\r\n个物体，第个物体重量为，价值为，选择物体，每一个物体可以只取走一部分，使得总重量不超过且总价值尽量高。\r\n贪心策略：先选出性价比高的\r\n乘船问题\r\n个人，第个人重量为，每艘船载重量为，最多可乘两人。用最少的船装载所有人。\r\n贪心策略：最轻的人和最重的人配对\r\n常见应用\r\n选择不相交区间问题\r\n练手板子题\r\n给定个开区间，\r\n首先\r\n区间选点问题\r\n练手板子题\r\n区间覆盖问题\r\n练手板子题\r\n流水作业调度问题\r\n练手板子题\r\n带限期和罚款的单位时间任务调度问题\r\n练手板子题\r\n","categories":["OI"],"tags":["笔记","贪心"]},{"title":"链表学习笔记","url":"/articles/linker/","content":"链表有很多种。下面列举一些。\r\n\r\n单链表：每个节点记录自己的后继。\r\n双链表：每个结点记录自己的前驱和后继。\r\n循环单链表：本身是一个单链表。最后一个节点的后继为第一个界点。\r\n循环双链表：本身是一个双链表，连成环形。\r\n块状链表：基本思想是将若干元素压缩成一块，将这些块串联起来。\r\n跳表：相当于平衡树。每个结点拥有自己的右指针和下指针，通过分层的方式来加速查询，而每个元素的层数由概率决定。\r\n\r\nP1160：\r\n利用一个双向链表维护这个队伍，每个同学记录自己左边和右边的同学。这样各种操作都可以O(1)的时间复杂度完成了。使用数组index定位某位同学的节点编号。\r\n#include &lt;iostream&gt;using namespace std;//注意万能头里有index数组struct node{    int pre,nxt,key;    node(int _key=0,int _pre=0,int _nxt=0)    {        pre=_pre;        nxt=_nxt;        key=_key;    }};node s[100005];int n,m,tot=0;int index[100005];void ins_back(int x,int y){    int now=index[x];    s[++tot]=node(y,now,s[now].nxt);    s[s[now].nxt].pre=tot;    s[now].nxt=tot;    index[y]=tot;}void ins_front(int x,int y){\tint now=index[x];\ts[++tot]=node(y,s[now].pre,now);    s[s[now].pre].nxt=tot;    s[now].pre=tot;    index[y]=tot;}void del(int x){\tint now=index[x];\tint le=s[now].pre,rt=s[now].nxt;\ts[le].nxt=rt;\ts[rt].pre=le;\tindex[x]=0;}int main(){\tindex[0]=0;    int x,k,p,now;    cin&gt;&gt;n;    s[0]=node();//  令0恒为最右边的结点 \tins_back(0,1);\tfor(int i=2;i&lt;=n;i++)\t{\t\tcin&gt;&gt;k&gt;&gt;p;\t\tp?ins_back(k,i):ins_front(k,i);\t}\t\tcin&gt;&gt;m;\tfor(int i=1;i&lt;=m;i++)\t{\t\tcin&gt;&gt;x;\t\tif(index[x])\t\t{\t\t\tdel(x);\t\t}\t}\tnow=s[0].nxt;\twhile(now)\t{\t\tcout&lt;&lt;s[now].key&lt;&lt;' ';\t\tnow=s[now].nxt;\t}\t    return 0;   }\r\n","categories":["OI"],"tags":["笔记","数据结构","题解"]},{"title":"进制转换问题","url":"/articles/sysconvert/","content":"\r\n","categories":["OI"],"tags":["笔记","进制"]},{"title":"随机数据生成与对拍","url":"/articles/compare/","content":"\r\n这是一篇远古博客，之所以要重写是因为当年的我在关键时刻社死不敢找大佬请教（或者说大佬不屑搭理本蒟蒻），所以只能现在来补QAQ\r\n\r\n使用场景\r\n\r\n在无法获得实时评测反馈的比赛中，思考并实现了一个“高分解法”，但是再不会证明自己的结论，或者不能确保自己编写的程序是否完全正确。\r\n在平时解题时，自己编写的程序无法在Online\r\nJudge上取得Accepted结果，调试很久仍未发现错误。\r\n\r\n随机数据生成\r\n头文件cstdlib包含rand和srand两个函数，以及RAND_MAX常量。\r\nRAND_MAX是一个不小于的整数，一般来说，在Windows系统中为，在类Unix系统中为。\r\nrand()函数返回一个~RAND_MAX之间的随机整数int。\r\nsrand(seed)函数接受unsighed int类型的参数seed，以seed为随机种子。rand函数基于线性同余递推式生成随机数，“随机种子”相当于计算线性同余死的一个初始参数。\r\n当种子确定后，接下来产生的随机数列就是固定的，所以这种随机方法也被称为“伪随机”。因此，一般在随机数据生成程序main函数的开头，用当前系统时间作为随机种子。\r\n头文件ctime包含time函数，调用time(0)可以返回从年月日时分秒（Unix纪元）到现在的秒数。执行srand((unsigned)time(0))即可初始化随机种子。\r\n代码如下：\r\n#include&lt;cstdlib&gt;#include&lt;ctime&gt;int random(int n){    return (long long)rand()*rand()%n;}int main(){    srand((unsigned)time(0));    //···具体内容···}\r\n函数random(n)返回之间的随机整数，对int范围内的均能正常工作。\r\n对拍\r\n","categories":["OI"],"tags":["笔记","技巧","对拍"]},{"title":"逆元学习笔记","url":"/articles/inverse/","content":"定义\r\n若，，互质，则称为的逆元，记为。\r\n用处\r\n逆元可以在计算时，转化为。\r\n求法\r\n扩展欧几里得算法\r\n根据逆元的定义，可转化为，用扩展欧几里得算法求解。\r\n友情赠送代码：\r\nvoid exgcd(int a,int b,int c,int &amp;x,int &amp;y){    if(a==0)    {        x=0;y=c/b;        return;    }    else    {        int tx,ty;        exgcd(b%a,a,tx,ty);        x=ty-(b/a)*tx;        y=tx;        return;    }}\r\n线性算法\r\n前置芝士：。\r\n设，，，则：。\r\n两边同时乘，就会得到：  于是，就可以递归求逆元啦！代码只有一行！\r\nA[i]=-(p/i)*A[p%i];\r\n这种方法可以在（众所周知表示时间复杂度更准确QwQ）的时间内求出单个数逆元QwQ。\r\n","categories":["OI"],"tags":["笔记","数学","逆元"]},{"title":"龟速乘学习笔记","url":"/articles/turtlemul/","content":"前置芝士\r\n位运算\r\n进制转换\r\n龟速乘\r\n龟速乘，主要用于解决爆long long的问题。\r\n举个栗子：求的值。其中。\r\n可以考虑类似快速幂的思想，把转化成二进制，如果某位上为就与进行运算。\r\n例如，若，那么。\r\n由于要把的每一位取出进行判断，所以时间复杂度为。\r\n代码如下： inline ll gsc(ll a,ll b,ll p){    ll res=0;    while(b)    {        if(b&amp;1) res=(res+a)%p;        a=(a*2)%p;//相当于预备好了a,2a,4a...        b&gt;&gt;=1;    }    return res;}\r\n（我天感觉自己解释不明白了反正3行代码背住就OK）\r\n","categories":["OI"],"tags":["笔记","位运算","进制","技巧","数学"]}]