[{"title":"2022.11 and 2022.12","url":"/articles/2022.11%20and%202022.12/","content":"感慨万千。\r\n\r\n\r\n2022年11月，某组拍摄心理剧时空荡荡的教室\r\n\r\n\r\n\r\n2022年12月，疫情“放开”之后大面积感染，迫于形势不得不再次线上后，空荡荡的教室\r\n\r\n","categories":["随笔"]},{"title":"My Blog","url":"/articles/My-Blog/","content":"我的博客来了！！！\r\n","categories":["随笔"]},{"title":"OI回忆录","url":"/articles/OI%E5%9B%9E%E5%BF%86%E5%BD%95/","content":"OI回忆录，顾名思义，是即将AFO的OIer写的回忆录。\r\n然鹅，目前为止我并没有AFO，写这篇OI回忆录，其实是因为最近看了太多很强的OIer退役了，多愁善感的基因令我也有些伤感——我也会有这一天，是在寒假集训结束后，模拟赛被薄纱而退役？还是苟到了CSP、NOIP，考完之后以一个对不起自己的成绩退役？还是……\r\n一些这样的文章，就有点儿伤感捏。\r\n高一上\r\n高一上，最先来的便是五科竞赛布道宣讲，自己一直对计算机很感兴趣，所以虽然父母想让选数学/物理但最后还是选了信息。（现在想想是好的毕竟我的数学和物理真的有点儿拉）\r\n当时新高一零基础的有个人吧（差不多）。\r\n开始gg讲的都是一些简单的东西，记得刚学的时候自己就像打了鸡血一样把OpenJudge上的题全部刷完了，好像还得到gg的表扬乐。然后我就摆了\r\n期中考试我寄了，寄的很彻底，在信竞队伍里垫底，当时其实有点儿迷茫，感觉自己好没用，当时好像还考了一场模拟赛，我虽然不是垫底但也有点儿拉胯。动力全无。\r\n期中考试之后，还剩个人，甚至连年级前的巨佬都AFO了。（后来又加入了一个）\r\n后来月的某天……算了这段是比较私人的东西就不写出来了。（大体可能就是看见了某个人然后莫名其妙地被激励了有了目标（?））自那之后努力了一段时间，每天中午不吃饭不睡觉地往机房跑（但是好像并没有学多少东西），网课的时候也在刷题，所以洛谷很快到了AC，乐。（然鹅还不是橙名呜呜呜）\r\n然后高一上就结束乐。记录一下当时会的东西（截止到2022/12/25）：\r\n\r\n寒假(1)\r\n","categories":["OI"],"tags":["回忆"]},{"title":"SPFA算法学习笔记","url":"/articles/SPFA%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96/","content":"\r\n关于SPFA，它死了\r\n\r\n所以这篇博客没有什么写的必要了\r\n不过SPFA是可以优化的，已经在学了，咕咕咕，学会了来填坑QwQ\r\n","categories":["-OI-笔记"],"tags":["图论","SPFA"]},{"title":"RMQ学习笔记","url":"/articles/RMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"前置芝士\r\nRMQ，即Range Maximum(Minimum)\r\nQuery的缩写。（记住它叫RMQ就对了）\r\n顾名思义，RMQ就是询问某个区间内的最大值或最小值。\r\nST算法\r\n简介\r\nST算法通常用在要多次询问一些区间的最值的问题中。\r\n时间复杂度\r\n它可以做到的预处理，回答每个询问。\r\n使用条件\r\n使用ST算法的条件是没有修改操作，它适用于没有修改操作并且询问次数较多（级别甚至更大）的情况。\r\n原理\r\n动态规划。\r\n流程\r\n预处理\r\n我们用a[1…n]表示一组数。\r\n设表示从到这个范围内的最大值，也就是以为起点连续个数的最大值。由于元素个数为个，所以从中间平均分成两部分，每一部分的元素个数刚好为个，也就是说，把分为和。\r\n整个区间的最大值一定是左右两部分最大值的较大值，满足动态规划的最优化原理。\r\n状态转移方程：，边界条件为f[i][0]=a[i]。\r\n预处理时间复杂度：。\r\n询问\r\n要询问区间的最大值，则先求出最大的满足，那么区间。\r\n两个区间的元素个数都为，所以的最大值为，可以在内计算出来。\r\n虽然这两个区间有交集，但是对于求区间最值来说没有影响，这就是ST算法适用于求区间最值的原因。\r\n求区间最大值，直接给出表达式： \r\n技巧\r\n因为cmath库中的log2函数效率不高，通常还会使用递推预处理出这种区间长度各自对应的值。具体地，。\r\nST VS 线段树\r\n\r\nST算法的优势\r\n\r\n实现非常简单\r\n效率比线段树更高\r\n\r\n线段树的优势\r\n\r\n可以更好地维护动态的信息，而ST算法不易推广到动态\r\n可以维护更多的信息，而ST算法只能维护最值\r\n\r\n\r\n\r\n练手板子题\r\n\r\n友情提供板子题代码：\r\n#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=1e6+5,logn=20;int log[maxn],f[maxn][logn+5];int n,m,x,y;inline int read(){\tint x=0,f=1;\tchar ch=getchar();\twhile(ch&gt;'9'||ch&lt;'0'){if(ch=='-') f=-1;ch=getchar();}\twhile(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}\treturn x*f;}int main(){    n=read(),m=read();    for(int i=1;i&lt;=n;++i)    {        f[i][0]=read();    }    log[0]=-1;    for(int i=1;i&lt;=n;++i)        log[i]=log[i/2]+1;    for(int j=1;j&lt;=logn;++j)        for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;++i)            f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;j-1)][j-1]);    \t\t//注意加减乘除运算符的优先级高于位移运算符    while(m--)    {        x=read(),y=read();        int s=log[y-x+1];        printf(\"%d\\n\",max(f[x][s],f[y-(1&lt;&lt;s)+1][s]));    }    return 0;}\r\n","categories":["-OI-笔记"],"tags":["数据结构","RMQ"]},{"title":"UVA11806题解","url":"/articles/UVA11806%E9%A2%98%E8%A7%A3/","content":"设满足“第一行没有石子”的方案集为 ，最后一行没有石子的方案集为 ，第一列没有石子的方案集为 ，最后一列没有石子的方案集为 ，全集为 ，则所求答案是“在  中但不在\r\n任何一个集合中”的元素个数，可以用容斥原理求解。\r\n我们用二进制来表示 \r\n的所有搭配（\r\n对应于“空搭配”），如果在集合  或\r\n 中，相当于少了一列。假定最后剩了\r\n 行  列，方法数就是 。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int mod=1000007;const int maxk=500;int c[maxk+10][maxk+10];int main(){    memset(c,0,sizeof(c));    c[0][0]=1;    for(int i=0;i&lt;=maxk;i++)    {        c[i][0]=c[i][i]=1;        for(int j=1;j&lt;i;j++)            c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;    }    int t;    cin&gt;&gt;t;    for(int kase=1;kase&lt;=t;kase++)    {        int n,m,k,sum=0;        cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;        for(int s=0;s&lt;16;s++)        {            int b=0,r=n,qaq=m;            if(s&amp;1)            {                r--;                b++;            }            if(s&amp;2)            {                r--;                b++;            }            if(s&amp;4)            {                qaq--;                b++;            }            if(s&amp;8)            {                qaq--;                b++;            }            if(b&amp;1) sum=(sum+mod-c[r*qaq][k])%mod;            else sum=(sum+c[r*qaq][k])%mod;        }        printf(\"Case %d: %d\\n\",kase,sum);    }    return 0;}\r\n","categories":["-OI-题解"],"tags":["题解"]},{"title":"位运算——从零基础到入门","url":"/articles/%E4%BD%8D%E8%BF%90%E7%AE%97%E2%80%94%E2%80%94%E4%BB%8E%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%88%B0%E5%85%A5%E9%97%A8/","content":"\r\n左移：左移一位，相当于某数乘以。比如左移位变为  变为，表示为。因此左移位,相当于该数乘以。\r\n右移：右移一位，相当于某数除以，比如右移1位变为  变为，表示为。因此右移位，相当于该数除以。\r\n与运算：按位进行“与”运算，两数同一位都为时结果为，否则为。例如：101&amp;110=100。\r\n或运算：按位进行“或”运算，两数同一位都为时结果为，否则为。例如：101|110=111。\r\n非运算：按位取反。例如~101=010；\r\n\r\n若当前状态为s，对s有下列操作。 1. 判断第位是否为：\r\n(s&amp;(1&lt;&lt;i))==0，意思是将左移位与s进行与运算后，看结果是否为。 2. 将第位设置为：\r\ns|(1&lt;&lt;i)，意思是将左移位与s进行或运算。 3. 将第位设置为：\r\ns&amp;~(1&lt;&lt;i)，意思是s与第位为，其余位为的数进行与运算。\r\n例如：s=1010101，i=5；\r\ns&amp;(1&lt;&lt;i)：1010101&amp;0100000=0000000；\r\ns|(1&lt;&lt;i)：1010101&amp;0100000=1110101；\r\ns&amp;~(1&lt;&lt;i)：1010101&amp;1011111=1010101；\r\n发现自己真的是鱼，半个多月前学的位运算现在基本都已经忘得差不多了（悲）\r\n","categories":["-OI-笔记"],"tags":["进制"]},{"title":"廿四的雪(1)","url":"/articles/%E5%BB%BF%E5%9B%9B%E7%9A%84%E9%9B%AA(1)/","content":"\r\n\r\n下雪啦！\r\n\r\n","categories":["随笔"],"tags":["廿四的雪"]},{"title":"快速幂学习笔记","url":"/articles/%E5%BF%AB%E9%80%9F%E5%B9%82%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"引入\r\n\r\n求。\r\n\r\n快速幂\r\n对于\r\n\r\n若是偶数，则；\r\n若是奇数，则。\r\n\r\n继续将分解成、……次后，就会变成。我们称这种快速计算幂运算的方法为快速幂算法。\r\n代码如下：\r\n\r\n递归版\r\nint quickpow(int a,int b,int n){    if(b==1) turn a;    if(b%2==0)    {        int t=quickpow(a,b/2,n);        turn t*t%n;    }    else    {        int t=quickpow(a,b/2,n);        t=t*t%n;        t=t*a%n;        turn t;    }}\r\n非递归版\r\nint quickpow(int a,int b,int n){    int t=1;    while(b)    {        if(b%2==1) t=t*a%n;        a=a*a%n;        b=b/2;    }    return t;}\r\n\r\n\r\n练手板子题\r\n\r\n","categories":["-OI-笔记"],"tags":["数学"]},{"title":"我的2022","url":"/articles/%E6%88%91%E7%9A%842022/","content":"中考前篇\r\n九上期末\r\n要写我的，其实要从年的年末开始。\r\n话说那是一次西安交大少年班的考试，我十分愚蠢地报了名，其实这也没啥；但是，在校内人选的选拔中，由于是按照八年级下的期末考试成绩排名的（注意当时我们已经初三了诶！但是还是初二的成绩），再加上我们居然要和大佬云集的理工本部一起比成绩，期末考试拉胯的我自然是以一名之差成功落选，其实这也没啥嗷（其实有啥，毕竟可以去西安交大玩儿诶0v0谁不想呢）；但是，居然被隔壁班的某哥们儿暗戳戳的嘲讽了QAQ，寄😭，结果就因为这次刺激，我成功地发奋学习了一个月（具体就是每天学到点，然后记忆特别深的是当时我把理化的错题都手敲了一遍打印出来，加起来能有五六十页纸（由此可见我的蒻，错的题都快赶上对的了呜呜呜），导致那个学期我的物理化学笔记本超级厚），然后期末考试还是寄了吧，据说算政史是名，不算政史可能是年级前了（注意看今年我们一共只有个的还有一个学习很牛的特长生），所以说我肯定是和无缘了嗷。\r\n寒假\r\n然后我的寒假就开始了。这个寒假也是一个难忘的寒假。主要内容包括：爆看冬奥会每场有中国的比赛+爆抄本练习册答案，注意看，这时候的我还在抄中考复习练习册的答案，这么看我开学考试肯定是要寄了，事实的确如此。不过看冬奥会其实不是没有一点用处，我中考语文议论文撞大运考可能也是跟看冬奥会有关ψ(｀∇´)ψ。\r\n\r\n插入一段，说到这儿不多不少我中考之后的私信还被徐梦桃回复了诶0v0：\r\n\r\n\r\n私信被世界冠军回复！！！\r\n\r\n（具体内容就是感谢桃姐的论据让我在议论文上嘎嘎乱杀)\r\n\r\n书接上文，讲到了我在中考前最后一个假期的离谱经历，当时其实没有想那么多，貌似是觉得时间还很充裕（?）或者感觉自己稳了（?也不知道是稳上啥，可能是三甲吧QwQ），现在发现自己真是心大。\r\n备考\r\n假期很快就结束乐，但是貌似开学不久就又回归线上了，然鹅本心大人居然都没拿几本书回家（虽然当时离中考已经只有天啦啦啦啦），然后好像百日誓师就是线上开的，再然后天也是线上开的，上了一个多月网课之后初三就开学了。关于网课的听课效果我觉得还行吧，毕竟我是那种再上课时候喜欢疯狂发言（当然现在越发腼腆）的性格（笑），回归线下乐！\r\n然鹅，回归线下之后直接就来了一场双基，没记错的话（肯定不会记错）是年级名，这个成绩差不多是中水平吧，当时可能有一点心理波动（因为我的心理定位是名左右，上个育明也不错😉），但是想想初中三年，从一开始被很多人看好，到后来逐渐成为了年级笑话（浅浅提一下我的黑历史，包括但不仅限于把老师气得上不了课，被班主任赶回家，撤凳子发蹲一个上午……），可能那些曾经看好我的老师都认为我是个华而不实的弱鸡吧，想想其实也挺不甘的，但是没办法，初中三年教会我最重要的就是：拿实力说话，没有实力，没人会把你当根葱；你要是够强，你怎么样都是好的。\r\n双基之后，度过了一段平淡的时光，现在想想备考的日子其实很美好，那种紧张中带着一丝放松，焦虑中带着一丝释然，真的好好。这期间发生的一件最重要的事就是：我已经全面放弃记叙文了（因为我的记叙文分数上限就是56呜呜呜），感谢这次选择，要不就不会有我那中考杀疯了的语文分数和我出人意料的结果。\r\n紧接着就是一模了（突然发现的前半段全部都是围绕着中考的(✿◡‿◡)），算是我的一个辉煌时刻吧，虽然只是年级，但是谁能想到我是在数学动点暴扣分再搭配上班级倒数的语文成绩下达到的呢。写到这儿我突然想起来前文那个隔壁班的哥们儿，他在上述的所有考试其实是初二以来的所有考试都在薄纱我（悲，不过马上就要上演逆转大戏了，当然上了高中我又被他薄纱了）。这里还要提到一位我的发小，之前我和她的成绩算是同病相怜，结果到了双基我已经是被单方面薄纱了。写到这儿发现自己又菜又没用，呜呜呜，可能我的水平就是育明了（悲）。发现现实好残酷，小学的时候人人都觉得上是小菜一碟（甚至初一初二我都觉得还有机会），后来逐渐被现实击垮了。不甘心，但是实力不行。话说期末考试之后我们晚课分出来一个小班（这是可以说的吗），在这个小班里我当然是被疯狂薄纱，还记得前面说的隔壁班哥们儿吗（他现在居然还在我隔壁班），他分钟一道题，我分钟都切不了，作出的正解辅助线都能被我给写挂，寄。记得当时我们有数学晚课前个小时都是小考试，一道一道，做完了才能去吃饭啊啊啊啊，结果每次我都是最后一个做完的（数学老师还是我们班主任结果我每天被疯狂鄙视呜呜呜），我天我的数学水平居然被一个现在要选文的女生嘎嘎乱杀这岂是我能忍的，但是我真的不会呜呜呜感觉自己好没用呜呜呜他们分钟就能全切我却一直卡着呜呜呜，题暴力解法也能写挂呜呜呜，所以每天数学晚课就成了我的减肥日，根本吃不上饭呜呜呜，好不容易食堂整点儿人吃的东西啥也抢不上呜呜呜；物理晚课多选题训练，我直接一看到托里拆利实验装置就傻眼一遇到浮力压强就懵逼但是其他人全都哐哐列式只有我哐哐懵逼哐哐瞎搞，寄；英语晚课写作文，别人：高中四六级雅思托福词汇，我：乱套句式+疯狂套路+小学词汇。寄。\r\n紧接着就是二模了，突然发现自己真是鱼，居然连中考前的事儿都已经忘了呜呜呜，我现在连圆周运动公式都记不住呜呜呜，我好没用呜呜呜，不过二模好像也挺平常的，但是遗憾也肯定有，比如没有成功AK一张数学卷（初中数学从未拿过星人）（但是二模数学是真的简单），比如语文作文开头爆改字不知道的还以为我已经成一代绝世文豪了写作文怎么飘逸，一看分数成功挂大分稳稳拿下，这一次的排名是，因为这次考试的难度所以有很多后起之秀来到了那个小班，但毕竟是后起之秀所以我本以为自己能在数学和物理上找回自信但没想到我居然被曾经年级名开外的选手乱杀呜呜呜我好没用。\r\n二模之后就是最激动人心的环节——报考！！！当然我没有丝毫犹豫因为太菜报了指标育明、统招+育明、统调是啥我忘了，反正就是纯托底选择，普高本来说是文谷，结果文谷不能保证我不去渤海，所以报考结束的几小时前临时改成了中（很长一段时间里我认为这里才是我的归宿）。话说这其中也想过报冲一下，毕竟很多一模年级前十二模都掉出前二十了还报了，所以在那张愚蠢的腾讯文档表格里有一段时间我是在那一栏的，然鹅后来我被嘲了，也被别的家长嘲了，所以后来只能改成育明，注意看此时此刻以我的成绩在报育明的人里是绝对是数一数二，然鹅马上转折就来了。\r\n报考结束之后感觉大多数人好像都觉得自己报的啥就能考上啥（说白了就是飘了），但是我不敢啊，因为就在去年我认识的一个学习超好的小哥哥就是因为中考前觉得自己稳了结果最后分之差从直接掉到中了，所以我必须以此为鉴！！！所以中考前的一两周当别人都在play的时候只有我在默默地胡乱study（其实还是实力不行，怕自己中考挂了），然后中考前还请了几次短假自己在家整理了一些知识，好像就是这样。\r\n然后就是中考啦啦啦啦啦！中考前一天还真是有点儿小感动（毕竟是朝夕相处了年呢），老师、同学……可能中考之后就很难再见面了。当时可能大多数人都觉得我稳了吧（但是马上就要到转折点了0v0），记得当时团员要交块钱团费，我去送的时候收团费的老师还跟我说了一声加油，挺感动的。这所学校，真的就要和我分开了，还是有一些不舍的呜呜呜，其实自己挺容易被感动的。（多愁善感的基因）\r\n中考篇\r\n（其实这一段在之前貌似写过）\r\nDay 1\r\n语文\r\n具体可以看我前面的朋友圈内容乐，当时记忆比较深的就是别人都在大太阳底下站着唠嗑等待入场，然后我因为没找到同学一个人跑到那个木亭子下面看我蒟蒻的笔记，然后进了考场答题，嗯，挺顺的，作文和大阅读可能卡了一下，但也还好吧。\r\n估分：，运气好的话+\r\n理化\r\n同样挺顺的，物理它没出浮力和压强啦啦啦啦啦！当时出考场听到有人说难（?）有人说简单，我觉得简单的有点儿让人不敢相信。（真的，非凡尔赛）\r\n估分：+=\r\nDay 2\r\n数学\r\n寄了。前面答得还挺顺手，题折纸题不会果断放弃（直到最后我都不会正解，直接拿刻度尺+量角器瞎搞算的破数居然对了），到了题看了看旁边的哥们儿，嗯，比我慢一点儿，还行，现在距离考试结束还有一个多小时，然鹅谁会想到我在接下来的一个多小时里颗粒无收😭。\r\n先开，送分；开始瞎搞结果发现自己假证了，寄；想开，又不会。忙活了一会儿，胡写几个相似三角形证明，写了一波假证上去，跑了。毕竟题切不掉我已经习惯了呜呜呜。瞎搞操作熟练的让人心疼。\r\n再开，送分；好像是一道很水的计算题，切了；看起来很简单，一上手做直接被我的暴力解法搞成了次方程，不会解，扔那儿，摆了。\r\n在考场上估了个分，吧，不过当时我还天真的以为这次数学超级难，大家都不会，嗯，还行。\r\n看了看旁边的哥们儿，呦呵，他题好像切了，难不成这题其实很简单？\r\n接下来一直到考试结束的半小时里，我就开始在、之间反复横跳，期间还水掉了题，但是其他的没有一点进展啊啊啊啊啊啊啊啊。\r\n还有分钟，看了看旁边的哥们儿，呦呵，他题好像也切了，难不成这题其实很简单？\r\n难道他是绝世高手？还是我寄了？\r\n出考场，听到有人说数学简单，比一模简单（?），一模我可是切了啊，满脑问号.jpg。算了，不管了。\r\n估分：\r\n英语\r\n很顺手，考试结束前还检查出来一个价值分的愚蠢错误。\r\n估分：\r\n崩溃\r\n考完英语，听到了一堆人说数学简单，、都切了，连之前数学难优秀的几个女同学居然都全切了在考场外面拉着数学老师的手活蹦乱跳，只有我据说手脚冰凉。\r\n回家就崩溃了，应该是寄了。数学就得和别人差+。完了，天要亡我。\r\nDay 3\r\n政史\r\n凑数用。唯一记得的就是那天下雨了，结果我下车的时候校长就在马路对面，给我喊了个加油，可是我已经寄了诶╯︿╰。感觉自己会成为下一届的标准反面教材，最有希望却摔得最惨。\r\n估分：必过\r\n中考后篇\r\n中考后玩了几天吧，还拍了毕业照，同学老师问我考得怎么样，我只能说寄了，说自己数学的惨，结果他们都不信（?），崩了，真的感觉完了。\r\n7.14\r\n出分日。\r\n本来说点出分，后来改成了点，本来想先睡一觉，结果一直睡不着。\r\n实际：\r\n乐了！！！数学瞎搞居然给了我这么多过程分！！！两道题加在一起只扣分诶！！！\r\n和同学比了一下，出乎意料的高，年级第，我天，历史最佳成绩了。\r\n还记得那个隔壁班的哥们儿吗，时隔两年，我终于有一次战胜了他。\r\n一堆老师来问我分（甚至还有前面那位收团费的老师），结果全惊了，毕竟在这之前连我自己都觉得我寄了，已经做好去中报道的准备了。\r\n泪目了。不负我。\r\n7.20\r\n出录取结果日。\r\n其实还在纠结这个分够不够的统招，我觉得挺稳的，果然，高分踩统招线入学。虽然没进羟基班但已经是意外之喜了。毕竟我是蒟蒻爆发户。有效防止了我在羟基班被人薄纱\r\n开始了自己在廿四被薄纱的日子\r\n新生活篇\r\n\r\n学了OI（但是我好菜呜呜呜希望假期结束能有所长进吧呜呜呜）\r\n当了一种很新的班委——纪律委员。这个职务可能别的班都没有吧。主要是由于班的特殊性。说到我是怎么当上的，其实挺奇妙的（毕竟曾经的我可是开班会被点名批评的不安定分子）。话说期中考试结束后的一天，老师叫鸡哥出去，然后我蚌埠住了乐了一下，然后老师就叫我也出去。然后老师表扬了鸡哥，然后问我能不能管理班级纪律，然后鸡哥蚌埠住了乐了一下，然后我就乐了，然后我就说能，然后就没有然后了。\r\n真心希望有一天班不需要纪律委员来管纪律，大家都能自己管好自己的纪律啊（相信会的OwO）\r\n认识了很多新同学\r\n学到了很多东西（比如自己真的很菜）\r\n考了一次期中考试，寄了\r\n期中考试之后努力学习了，不知道期末考试怎么样\r\n被薄纱\r\n得了一次新冠，已经好乐\r\n\r\n终章\r\n这篇年终总结算是结束了，现在想想我的真是跌宕起伏又精彩纷呈呢。\r\n年结束了，我很怀念它。\r\n年，对我好一点啊QwQ。\r\n\r\n愿一切美好，都能如愿以偿。\r\n\r\n","categories":["随笔"],"tags":["回忆","我的20××"]},{"title":"排序方式笔记","url":"/articles/%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F%E7%AC%94%E8%AE%B0/","content":"最好情况下\r\n\r\n冒泡排序\r\n\r\n图解： \r\n\r\n插入排序\r\n\r\n图解： \r\n\r\n\r\n平均情况下\r\n\r\n快速排序\r\n\r\n图解： \r\n\r\n\r\n最坏情况下\r\n\r\n堆排序 （等学会之后再填坑）\r\n归并排序\r\n\r\n图解： \r\n\r\n\r\n","categories":["-OI-笔记"],"tags":["算法","排序"]},{"title":"DFS剪枝学习笔记","url":"/articles/%E6%B7%B1%E6%90%9C%E5%89%AA%E6%9E%9D%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"前置芝士\r\n搜索的进程可以看作是从树根出发，遍历一棵倒置的树——搜索树的过程。\r\n剪枝，顾名思义，就是通过某种判断，避免一些不必要的遍历过程。\r\n剪枝的原则\r\n正确性\r\n保证不丢失正确的结果\r\n准确性\r\n尽可能多地剪去不能通向正解的枝条。\r\n高效性\r\n剪枝的技巧\r\n优化搜索顺序\r\n排除等效冗余\r\n在搜索过程中，如果能够判定从搜索树的的当前节点上沿着某几条不同分支到达的子树是等效的，那么只需要对其中的一条分值进行搜索。\r\n可行性剪枝\r\n在搜索过程中，及时对当前状态进行检查，如果发现分支已经无法到达递归边界，就执行回溯。\r\n某些题目条件的范围限制是一个区间，此时可行性剪枝也被称为“上下界剪枝”。\r\n最优性剪枝\r\n在最优化问题的搜索过程中，如果当前花费的代价已经超过当前搜到的最优解，此时可以停止对当前分支的搜索，执行回溯。\r\n记忆化\r\n记录每个状态的搜索结果，在重复遍历一个状态时直接检索并返回。\r\n类似于对图进行深搜时，标记一个节点是否已经被访问过。\r\n\r\n练手板子题\r\n提示：最优性剪枝、可行性剪枝\r\n\r\n","categories":["-OI-笔记"],"tags":["DFS","剪枝"]},{"title":"线段树学习笔记","url":"/articles/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"\r\n事情的起因来自于年的元旦，一位蒟蒻百无聊赖中误入了大佬们的团队作业，好奇心满满地点开了第一道题，看着一行半的题干信心满满地准备大干一场，调了分钟写出一个分治+DP的思路，直接忽略时间复杂度是的事实，结果UKE了无数次后上CF一测发现第一个点就TLE了😭。然后发现这道题要用线段树优化，痛定思痛从开始学线段树。\r\n啊啊啊明天的团队作业已经出了我要切了它啊啊啊！\r\n\r\n基础\r\n线段树是一种基于分治思想的二叉树结构，用于在区间上进行信息统计。\r\n性质\r\n\r\n线段树的每一个节点都代表一个区间。\r\n线段树具有唯一的根节点，代表的区间是整个统计范围。\r\n线段树的每个叶节点都代表一个长度为的元区间。\r\n对于每个内部节点，它的左子节点是，右子节点是，其中。\r\n\r\n\r\n\r\n线段树的区间视角、二叉树视角\r\n\r\n除去树的最后一层，整棵线段树一定是一棵完全二叉树，树的深度为。\r\n编号\r\n\r\n“父子倍”节点编号\r\n\r\n根节点编号为。\r\n编号为的节点的左子节点编号为，右子节点编号为。\r\n\r\n\r\n保存线段树的数组长度要不小于。\r\n建树\r\n给定一个长度为的序列。。\r\nstruct SegmentTree{    int l,r;    int sum;    int lazy;    //lazy懒标记，下面有讲QwQ}t[size*4];void build(int k,int l,int r){    t[k].l=l,t[k].r=r;    if(l==r){t[k].sum=a[l];return;}    int mid=(l+r)/2;    build(k*2,l,mid);    build(k*2+1,mid+1,r);    t[k].sum=max(t[k].sum,t[k*2+1].sum);}build(1,1,n);\r\n单点查询+修改\r\n从根节点出发，递归找到代表区间的叶节点，然后从下往上更新以及它的所有祖先节点上保存的信息。时间复杂度为。\r\n//change A[x] to vvoid change(int k,int x,int v){    if(t[k].l==t[k].r){t[k].sum=v;return;}    int mid=(t[k].l+t[k].r)/2;    if(x&lt;=mid) change(k*2,x,v);    else change(k*2+1,x,v);    t[k].sum=max(t[2*k].sum,t[2*k+1].sum);}change(1,x,v);\r\n区间查询\r\n查询序列在区间上的最大值。\r\n从根节点开始，递归执行以下过程。\r\n\r\n若完全覆盖了当前节点代表的区间，则立即回溯，并且该节点的值为候选答案。\r\n若左子节点与有重叠部分，则递归访问左子节点。\r\n若右子节点与有重叠部分，则递归访问右子节点。\r\n\r\nint ask(int k,int l,int r){    if(l&lt;=t[k].l&amp;&amp;r&gt;=t[k].r) return t[k].sum;    int mid=(t[k].l+t[k].r)/2;    int val=-(1&lt;&lt;30);    if(l&lt;=mid) val=max(val,ask(k*2,l,r));    if(l&gt;mid) val=max(val,ask(k*2+1,l,r));    return val;}cout&lt;&lt;ask(1,l,r)&lt;&lt;endl;\r\n该查询过程会把询问区间先线段树上分成个节点，取它们的最大值作为答案。\r\n区间修改\r\n前置芝士\r\n延迟标记，可能就是懒标记。\r\n顾名思义，延迟标记就是更新到某一子区间时直接打上标记，延迟对它的子节点的更新操作。但是大家都叫它懒标记，所以下面我们叫它懒标记。\r\n\r\n当lazy[i]!=0时，表示更新过了而的子节点还没有更新。\r\n\r\n其实可以这么理解嗷。以下图为例：\r\n\r\n\r\n举个栗子\r\n\r\n如果我们要修改区间上的值，令其都，那么可以更新区间、、、，每找到一个这样的真包含区间就加上一个懒标记。我们观察到，、的子节点的值没有更新诶，但是没关系，当我们遍历到这个有懒标记的节点时，如果有懒标记，那就可以把它的子节点给更新并且打上懒标记，再把这个懒标记给置。以此类推。\r\n\r\n懒标记要和修改相同，比如要，懒标记就是。\r\n如果要进行乘法操作，和上面的一样，懒标记就是5。\r\n\r\n实操\r\n\r\n乐了，已经崩溃了，自己迷迷糊糊的，不知道能不能写明白。代码就不放出来吓唬人了。\r\n为了不误人子弟我就先咕了，等大彻大悟之后一定回来填坑！！！\r\n给自己找点儿信心：STO ncwzdlsd Orz\r\n\r\n但是，善良的蒟蒻为了防止大家抄题解欣赏别人的代码思路的时候看不懂，还是介绍一下add、pushup、pushdown、change、query操作吧QwQ。呵呵真是一个口是心非的男人\r\n注：下文的均代表当前节点。\r\n\r\nadd：给一个节点进行更新并且打上懒标记。\r\n代码如下：\r\nvoid add(int k,int l,int r,int val){    tree[k].sum+=(r-l+1)*val;    tree[k].lazy+=val;}\r\npushup：把修改上推，即更新父节点的值。\r\n代码如下：\r\nvoid pushup(int k){    //之前用的SegmentTree，现在不拽了，老老实实用tree    tree[k].sum=tree[k*2].sum+tree[k*2+1].sum;}\r\n解释：\r\n\r\n父节点的等于子节点的元素和。\r\n\r\npushdown：把修改下推，即更新子节点的值。\r\n代码如下：\r\nvoid pushdown(int k,int l,int r){    int mid=(l+r)/2;    add(k*2,l,mid,tree[k].lazy);//左子节点    add(k*2+1,mid+1,r,tree[k].lazy);//右子节点    lazy[k]=0;}\r\nchange：修改操作。把全部+val\r\n代码如下：\r\nvoid change(int k,int l,int r,int val){    if(l&lt;=tree[k].l&amp;&amp;tree[k].r&lt;=r)//真包含    {        tree[k].sum+=(tree[k].r-tree[k].l+1)*val;        tree[k].lazy+=val;        return;    }    pushdown(k,tree[k].l,tree[k].r);    int mid=(tree[k].l+tree[k].r)/2;    if(l&lt;=mid)        change(k*2,l,r,val);//左子树与更新区间有交集    if(r&gt;mid)        change(k*2+1,l,r,val);    pushup(k);}\r\nquery：查询区间和。\r\n代码如下：\r\nint query(int k,int l,int r){    if(l&lt;=tree[k].l&amp;&amp;tree[k].r&lt;=r)//当前区间真包含于查询区间        return tree[k].sum;    pushdown(k,tree[k].l,tree[k].r);    int res=0;    int mid=(tree[k].l+tree[k].r)/2;    if(l&lt;=mid)        res+=query(k*2,l,r);    if(r&gt;mid)        res+=(k*2+1,l,r);    return res;}\r\n\r\n动态开点与线段树合并\r\n\r\n不会，正在学习……咕咕咕咕咕\r\n\r\n可能没完结完结撒花！！！\r\n线段树，学了一整天，感觉自己还是半懵状态，不过慢慢来应该会懂的。\r\n不行了，我高低得拜一下自己。\r\nSTO ncwzdlsd\r\n\r\n练手板子题\r\n\r\n我天这道板子题我居然写不明白了回炉重造吧呜呜呜\r\n大家还是不要像我一样用结构体了还是改回数组吧\r\n","categories":["-OI-笔记"],"tags":["数据结构","线段树"]},{"title":"背包问题详解（01背包，完全背包与多重背包）","url":"/articles/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%8801%E8%83%8C%E5%8C%85%EF%BC%8C%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E4%B8%8E%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%EF%BC%89/","content":"\r\n前段时间学背包问题的时候发现的一篇学长的宝藏博客QwQ，写得真的好\r\n\r\n背包问题\r\n01背包\r\n问题简述：有m个物品待放入一个容量为V的背包，每件物品都有其对应的体积w与价值v，从中选取一些物品放入背包，使得物品总价值最大。\r\n算法思路：考虑动态规划，令f(i,j)为只考虑前i件物品，背包容量为j时能得到的最大价值。那么当只考虑第i件物品放不放时，便有以下两种情况：\r\n1，第i件物品体积大于当前背包容量，不放：f(i,j)=f(i-1,j)；\r\n2，第i件物品体积小于等于当前背包容量，则考虑放与不放哪个更优：\r\nf(i,j)=max(f(i-1,j),f(i-1,j-w[i])+v[i])\r\n那么就得到核心代码：\r\nfor(int i=1;i&lt;=m;i++)    for(int j=1;j&lt;=V;j++)    {       if(j=w[i])            f[i][j]=max(f[i-1][j],f[i-1][j-w[i]]+v[i]);       else            f[i][j]=f[i-1][j];    }\r\n观察状态转移方程式，我们发现，对第i件物品的选择只与对前一件物品的选择有关，于是考虑滚动数组优化空间。\r\n注意：当使用滚动数组时，第二层循环应由V到w[i]。这是因为在状态转移时用到的背包容量均小于等于j，倒着循环可以保证j前面都是只考虑i-1件物品时的数据，而j后面是更新过的前i件物品的数据，这样顺带保证了当j&lt;w[i]，f(i,j)=f(i-1,j)。\r\nfor(int i=1;i&lt;=m;i++)\tfor(int j=V;j&gt;=w[i];j--)   \t\tf[j]=max(f[j],f[j-w[i]]+v[i]);\r\n练手板子题：传送门\r\n完全背包\r\n问题简述：有m种物品待放入一个容量为V的背包，每种物品都有无穷多件且有其对应的体积w与价值v，从中选取一些物品放入背包，使得物品总价值最大。\r\n算法思路：在01背包的基础上，由于每种物品都能被重复选择，考虑从1开始枚举每件物品被选择的次数k直到当前物品所占体积超过容量j，则有：f(i,j)=max(f(i,j),f(i,j-k*w[i])+k*v[i])。由于在每次循环中讨论的都是第i件物品的选择次数，故数组第一维为i，这也决定了在每次对j进行枚举后要将f(i,j)初始化：f(i,j)=f(i-1,j)。\r\n上核心代码：\r\nfor(int i=1;i&lt;=m;i++)\tfor(int j=1;j&lt;=V;j++)\t{        f[i][j]=f[i-1][j];        for(int k=1;k*w[i]&lt;=j;k++)                f[i][j]=max(f[i][j],f[i][j-k*w[i]]+k*v[i]);\t}\r\n观察状态转移方程式，参照01背包的思想再次考虑滚动数组优化：\r\n不难发现，完全背包的第二层循环是无需倒着枚举的。如上文所说，在每次对k进行枚举时讨论的都是对第i件物品的选择，故j前面的数据应为只考虑前i件物品时的数据，所以应正着循环。\r\n再考虑对k的枚举。每次循环都是在前一次循环的基础上多选择一件物品i放入背包，所以可以考虑变乘为加：f(j)=max(f(j),f(j-w[i])+v[i])，进一步优化时间。\r\nfor(int i=1;i&lt;=m;i++)\tfor(int j=w[i];j&lt;=V;j++)\t\tf[j]=max(f[j],f[j-w[i]]+v[i]);\r\n日常板子题时刻：传送门\r\n（不开longlong见祖宗哦\r\n多重背包\r\n问题简述：有n种物品待放入一个容量为V的背包，每种物品都有其对应的数量m，体积w与价值v，从中选取一些物品放入背包，使得物品总价值最大。\r\n算法思路：由于不能无限选择，这个问题又变回了01背包，只是加了对k的枚举。当我们熟练掌握前两种背包，想写出来一个多重背包也就不难了。\r\n核心代码又来了。\r\nfor(int i=1;i&lt;=n;i++)\tfor(int j=V;j&gt;=w[i];j--)\t\tfor(int k=1;k&lt;=m[i]&amp;&amp;k*w[i]&lt;=j;k++)\t\t\tf[j]=max(f[j],f[j-k*w[i]]+k*v[i]);\r\n我们发现，由于物品有数量的限制，第三层循环无法删去，那么又如何对时间进行优化呢？\r\n此时可以考虑使用二进制，由于可以表示之内的所有数，故m件物品一定可以进行二进制拆分成许多堆物品，每堆件又能看作一件质量为，价值为的物品，使复杂度优化一个。\r\n二进制拆分模拟如下：\r\nint vv,ww,mm,cnt=0;for(int i=1;i&lt;=n;i++){\tvv=read(),ww=read(),mm=read();\tfor(int j=1;j&lt;=mm;j&lt;&lt;=1)\t{\t\tv[++cnt]=vv*j,w[cnt]=ww*j;\t\tmm-=j;\t}\tif(mm) \t\tv[++cnt]=vv*mm,w[cnt]=ww*mm;}\r\n然后就是朴实无华01背包啦。\r\n板子：传送门\r\n（几天前用快读不加二进制优化还能卡过呢qwq\r\n","categories":["-OI-笔记"],"tags":["算法","转载"]},{"title":"链表——以P1160为例","url":"/articles/%E9%93%BE%E8%A1%A8%E2%80%94%E2%80%94%E4%BB%A5P1160%E4%B8%BA%E4%BE%8B/","content":"链表有很多种。下面列举一些。\r\n\r\n单链表：每个节点记录自己的后继。\r\n双链表：每个结点记录自己的前驱和后继。\r\n循环单链表：本身是一个单链表。最后一个节点的后继为第一个界点。\r\n循环双链表：本身是一个双链表，连成环形。\r\n块状链表：基本思想是将若干元素压缩成一块，将这些块串联起来。\r\n跳表：相当于平衡树。每个结点拥有自己的右指针和下指针，通过分层的方式来加速查询，而每个元素的层数由概率决定。\r\n\r\nP1160：\r\n利用一个双向链表维护这个队伍，每个同学记录自己左边和右边的同学。这样各种操作都可以O(1)的时间复杂度完成了。使用数组index定位某位同学的节点编号。\r\n#include &lt;iostream&gt;using namespace std;//注意万能头里有index数组struct node{    int pre,nxt,key;    node(int _key=0,int _pre=0,int _nxt=0)    {        pre=_pre;        nxt=_nxt;        key=_key;    }};node s[100005];int n,m,tot=0;int index[100005];void ins_back(int x,int y){    int now=index[x];    s[++tot]=node(y,now,s[now].nxt);    s[s[now].nxt].pre=tot;    s[now].nxt=tot;    index[y]=tot;}void ins_front(int x,int y){\tint now=index[x];\ts[++tot]=node(y,s[now].pre,now);    s[s[now].pre].nxt=tot;    s[now].pre=tot;    index[y]=tot;}void del(int x){\tint now=index[x];\tint le=s[now].pre,rt=s[now].nxt;\ts[le].nxt=rt;\ts[rt].pre=le;\tindex[x]=0;}int main(){\tindex[0]=0;    int x,k,p,now;    cin&gt;&gt;n;    s[0]=node();//  令0恒为最右边的结点 \tins_back(0,1);\tfor(int i=2;i&lt;=n;i++)\t{\t\tcin&gt;&gt;k&gt;&gt;p;\t\tp?ins_back(k,i):ins_front(k,i);\t}\t\tcin&gt;&gt;m;\tfor(int i=1;i&lt;=m;i++)\t{\t\tcin&gt;&gt;x;\t\tif(index[x])\t\t{\t\t\tdel(x);\t\t}\t}\tnow=s[0].nxt;\twhile(now)\t{\t\tcout&lt;&lt;s[now].key&lt;&lt;' ';\t\tnow=s[now].nxt;\t}\t    return 0;   }\r\n","categories":["-OI-题解"],"tags":["数据结构"]},{"title":"费马小定理、欧拉定理学习笔记","url":"/articles/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86%E3%80%81%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"费马小定理\r\n如果是一个质数，而整数不是的倍数，则有。\r\n一般情况：\r\n欧拉定理\r\n欧拉函数\r\n对正整数，欧拉函数是小于等于的数中与互质的数的数目。\r\n引理1\r\n\r\n如果为某一个素数，则：；\r\n如果为某一个素数的的幂次，则：；\r\n如果为任意两个互质的数，的积，则：。\r\n\r\n引理2\r\n设为正整数的素数幂乘积表达式，则：。\r\n欧拉定理\r\n若与互质，则。\r\n","categories":["-OI-笔记"],"tags":["数学"]}]