[{"title":"2022.11 and 2022.12","url":"/articles/2022.11%20and%202022.12/","content":"感慨万千。\r\n\r\n\r\n2022年11月，某组拍摄心理剧时空荡荡的教室\r\n\r\n\r\n\r\n2022年12月，疫情“放开”之后大面积感染，迫于形势不得不再次线上后，空荡荡的教室\r\n\r\n","categories":["随笔"]},{"title":"BST学习笔记","url":"/articles/BST%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"前置芝士\r\n喜闻乐见的英语学习时间（大雾）。\r\n二叉查找树（BST），即Binary Search Tree。\r\n举个栗子：\r\n\r\n\r\nimage-20230104170517065\r\n\r\n性质\r\n\r\n树中每个结点被赋予了一个权值。\r\n若结点的左子树不空，则的左子树中所有节点的值均小于结点的值。\r\n若结点的右子树不空，则右子树中所有结点的值均大于结点的值。\r\n任意结点的左、右子树也分别是二叉搜索树。\r\n\r\n作用\r\n\r\n表示有序集合\r\n建立索引或优先队列\r\n维护有序数集\r\n\r\n操作\r\n遍历\r\n对于一棵已知的二叉查找树，从小到大输出其结点的值，只需对其进行二叉树的中序遍历，即递归地先输出其左子树，再输出其本身，然后输出其右子树。\r\n时间复杂度为。\r\n代码如下：\r\nvoid print(int p){    if(!p) return;    print(left[p]);    printf(\"%d\\n\",a[p]);    print(right[p]);}\r\n","categories":["OI"],"tags":["数据结构","笔记","BST"]},{"title":"Floyd算法进阶版学习笔记","url":"/articles/Floyd%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"\r\n","categories":["OI"],"tags":["笔记","Floyd算法","最小环","传递闭包"]},{"title":"KMP学习笔记","url":"/articles/KMP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"\r\n","categories":["OI"],"tags":["笔记","KMP","字符串"]},{"title":"OI回忆录","url":"/articles/OI%E5%9B%9E%E5%BF%86%E5%BD%95/","content":"OI回忆录，顾名思义，是即将AFO的OIer写的回忆录。\r\n然鹅，目前为止我并没有AFO，写这篇OI回忆录，其实是因为最近看了太多很强的OIer退役了，多愁善感的基因令我也有些伤感——我也会有这一天，是在寒假集训结束后，模拟赛被薄纱而退役？还是苟到了CSP、NOIP，考完之后以一个对不起自己的成绩退役？还是……\r\n一些这样的文章，就有点儿伤感捏。\r\n高一上\r\n高一上，最先来的便是五科竞赛布道宣讲，自己一直对计算机很感兴趣，所以虽然父母想让选数学/物理但最后还是选了信息。（现在想想是好的毕竟我的数学和物理真的有点儿拉）\r\n当时新高一零基础的有个人吧（差不多）。\r\n开始gg讲的都是一些简单的东西，记得刚学的时候自己就像打了鸡血一样把OpenJudge上的题全部刷完了，好像还得到gg的表扬乐。然后我就摆了\r\n期中考试我寄了，寄的很彻底，在信竞队伍里垫底，当时其实有点儿迷茫，感觉自己好没用，当时好像还考了一场模拟赛，我虽然不是垫底但也有点儿拉胯。动力全无。\r\n期中考试之后，还剩个人，甚至连年级前的巨佬都AFO了。（后来又加入了一个）\r\n后来月的某天……算了这段是比较私人的东西就不写出来了。（大体可能就是看见了某个人然后莫名其妙地被激励了有了目标（?））自那之后努力了一段时间，每天中午不吃饭不睡觉地往机房跑（但是好像并没有学多少东西），网课的时候也在刷题，所以洛谷很快到了AC，乐。（然鹅还不是橙名呜呜呜）\r\n然后高一上就结束乐。记录一下当时会的东西（截止到2022/12/25）：\r\n\r\n寒假(1)\r\n","categories":["OI"],"tags":["回忆"]},{"title":"SPFA算法学习笔记","url":"/articles/SPFA%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"\r\n关于SPFA，它死了\r\n\r\n所以这篇博客没有什么写的必要了\r\n不过SPFA还是要学的，已经在学了，咕咕咕，学会了来填坑QwQ\r\n","categories":["OI"],"tags":["笔记","图论","SPFA"]},{"title":"RMQ学习笔记","url":"/articles/RMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"前置芝士\r\nRMQ，即Range Maximum(Minimum)\r\nQuery的缩写。（记住它叫RMQ就对了）\r\n顾名思义，RMQ就是询问某个区间内的最大值或最小值。\r\nST算法\r\n简介\r\nST算法通常用在要多次询问一些区间的最值的问题中。\r\n时间复杂度\r\n它可以做到的预处理，回答每个询问。\r\n使用条件\r\n使用ST算法的条件是没有修改操作，它适用于没有修改操作并且询问次数较多（级别甚至更大）的情况。\r\n原理\r\n动态规划。\r\n流程\r\n预处理\r\n我们用a[1…n]表示一组数。\r\n设表示从到这个范围内的最大值，也就是以为起点连续个数的最大值。由于元素个数为个，所以从中间平均分成两部分，每一部分的元素个数刚好为个，也就是说，把分为和。\r\n整个区间的最大值一定是左右两部分最大值的较大值，满足动态规划的最优化原理。\r\n状态转移方程：，边界条件为f[i][0]=a[i]。\r\n预处理时间复杂度：。\r\n询问\r\n要询问区间的最大值，则先求出最大的满足，那么区间。\r\n两个区间的元素个数都为，所以的最大值为，可以在内计算出来。\r\n虽然这两个区间有交集，但是对于求区间最值来说没有影响，这就是ST算法适用于求区间最值的原因。\r\n求区间最大值，直接给出表达式： \r\n技巧\r\n因为cmath库中的log2函数效率不高，通常还会使用递推预处理出这种区间长度各自对应的值。具体地，。\r\nST VS 线段树\r\n\r\nST算法的优势\r\n\r\n实现非常简单\r\n效率比线段树更高\r\n\r\n线段树的优势\r\n\r\n可以更好地维护动态的信息，而ST算法不易推广到动态\r\n可以维护更多的信息，而ST算法只能维护最值\r\n\r\n\r\n\r\n练手板子题\r\n\r\n友情提供板子题代码：\r\n#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=1e6+5,logn=20;int log[maxn],f[maxn][logn+5];int n,m,x,y;inline int read(){\tint x=0,f=1;\tchar ch=getchar();\twhile(ch&gt;'9'||ch&lt;'0'){if(ch=='-') f=-1;ch=getchar();}\twhile(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}\treturn x*f;}int main(){    n=read(),m=read();    for(int i=1;i&lt;=n;++i)    {        f[i][0]=read();    }    log[0]=-1;    for(int i=1;i&lt;=n;++i)        log[i]=log[i/2]+1;    for(int j=1;j&lt;=logn;++j)        for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;++i)            f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;j-1)][j-1]);    \t\t//注意加减乘除运算符的优先级高于位移运算符    while(m--)    {        x=read(),y=read();        int s=log[y-x+1];        printf(\"%d\\n\",max(f[x][s],f[y-(1&lt;&lt;s)+1][s]));    }    return 0;}\r\n","categories":["OI"],"tags":["数据结构","笔记","RMQ"]},{"title":"最短路学习笔记","url":"/articles/SSSP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"\r\n","categories":["OI"],"tags":["笔记","图论","最短路","SSSP"]},{"title":"Treap学习笔记","url":"/articles/Treap%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"\r\n","categories":["OI"],"tags":["数据结构","笔记","Treap","平衡树"]},{"title":"My Blog","url":"/articles/My-Blog/","content":"我的博客来了！！！\r\n","categories":["随笔"]},{"title":"UVA11806题解","url":"/articles/UVA11806%E9%A2%98%E8%A7%A3/","content":"设满足“第一行没有石子”的方案集为 ，最后一行没有石子的方案集为 ，第一列没有石子的方案集为 ，最后一列没有石子的方案集为 ，全集为 ，则所求答案是“在  中但不在\r\n任何一个集合中”的元素个数，可以用容斥原理求解。\r\n我们用二进制来表示 \r\n的所有搭配（\r\n对应于“空搭配”），如果在集合  或\r\n 中，相当于少了一列。假定最后剩了\r\n 行  列，方法数就是 。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int mod=1000007;const int maxk=500;int c[maxk+10][maxk+10];int main(){    memset(c,0,sizeof(c));    c[0][0]=1;    for(int i=0;i&lt;=maxk;i++)    {        c[i][0]=c[i][i]=1;        for(int j=1;j&lt;i;j++)            c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;    }    int t;    cin&gt;&gt;t;    for(int kase=1;kase&lt;=t;kase++)    {        int n,m,k,sum=0;        cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;        for(int s=0;s&lt;16;s++)        {            int b=0,r=n,qaq=m;            if(s&amp;1)            {                r--;                b++;            }            if(s&amp;2)            {                r--;                b++;            }            if(s&amp;4)            {                qaq--;                b++;            }            if(s&amp;8)            {                qaq--;                b++;            }            if(b&amp;1) sum=(sum+mod-c[r*qaq][k])%mod;            else sum=(sum+c[r*qaq][k])%mod;        }        printf(\"Case %d: %d\\n\",kase,sum);    }    return 0;}\r\n","categories":["OI"],"tags":["题解","容斥原理"]},{"title":"lower_bound和upper_bound——从零基础到入门","url":"/articles/lower-bound%E5%92%8Cupper-bound%E2%80%94%E2%80%94%E4%BB%8E%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%88%B0%E5%85%A5%E9%97%A8/","content":"\r\nlower_bound(begin,end,val)：在值有序的数组连续地址[begin,end)中找到第一个位置并返回其地址，使得val插入在这个位置前面，整个数组仍然保持有序。\r\nupper_bound(begin,end,val)：在值有序的数组连续地址[begin,end)中找到最后一个位置并返回其地址，使得val插入在这个位置前面，整个数组仍然保持有序。\r\n\r\n假如排序后的数组名为a，可以认为其返回值减去数组名a（其实等于a[0]）刚好等于所要找的元素的数组下标。\r\n我们可以用lower_bound和upper_bound求数的出现次数，即upper_bound()-lower_bound()。\r\n","categories":["OI"],"tags":["笔记"]},{"title":"map——从零基础到入门","url":"/articles/map%E2%80%94%E2%80%94%E4%BB%8E%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%88%B0%E5%85%A5%E9%97%A8/","content":"map容器是一个映射表（key-value型），其内部实现是一棵红黑树。\r\nmap的key和value可以是任意类型。\r\nmap容器经常被当作Hash表使用，但是操作的时间复杂度为，略慢于传统Hash表。\r\n常见操作\r\n\r\nsize、empty、clear、begin、end、count\r\nh.find(x)：在变量名为h的map中查找key为的二元组。\r\ninsert、erase\r\n搭配迭代器\r\n添加注释小能手上线\r\nmap&lt;int,int&gt; h;h.insert(make_pair(1,2));map&lt;int,int&gt;::iterator it=h.begin(),itlow,itup;itlow=h.lower_bound('b');//itlow指向大于等于‘b’的第一个元素itup=h.upper_bound('d');//同理，指向大于‘d’键值的第一个元素pair&lt;int,int&gt; p=*it;h.erase(it);h.erase(make_pair(2,3));\r\n[]操作\r\nh[key]返回key映射到的value的引用，时间复杂度为。\r\n还可以对h[key]进行赋值操作，改变key对应的value。\r\n若查找的key不存在，执行h[key]后，h会自动新建一个二元组(key,zero)，zero表示一个广义零值，如整数，空字符串等。\r\n强烈建议在[]操作查询之前，先用find检查key的存在性。\r\n\r\n","categories":["OI"],"tags":["笔记","STL"]},{"title":"rope——从零基础到入门","url":"/articles/rope%E2%80%94%E2%80%94%E4%BB%8E%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%88%B0%E5%85%A5%E9%97%A8/","content":"众所周知，可以用STL里的rope实现简单的可持久化数据结构。\r\n","tags":["数据结构","STL"]},{"title":"vector——从零基础到入门","url":"/articles/vector%E2%80%94%E2%80%94%E4%BB%8E%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%88%B0%E5%85%A5%E9%97%A8/","content":"\r\n来自于一个邻接表建图建了半天没建明白的蒟蒻，他现在已经改用结构体存图了\r\nSTL大法好\r\n\r\nvector可理解为变长数组，它的内部实现基于倍增思想。\r\n前置芝士\r\n设，为vector的实际长度和最大长度。\r\n向vector加入元素前，若，则在内存申请的连续空间，并把内容转移到新的地址上（同时释放旧的空间），再执行插入。从vector中删除元素后，若，则释放一半的空间。\r\nvector支持随机访问，即对于任意的下标，可以像数组一样用取值。\r\n但它不是链表，不支持在任意位置插入。为了保证效率，元素的增删一般应该在末尾进行。\r\n声明\r\n#include &lt;vector&gt;vector&lt;int&gt; a;vector&lt;int&gt; b[233];//第一维长233，第二维长度动态变化struct rec{}vector&lt;rec&gt; c;\r\n操作\r\nvector&lt;int&gt; a;a.empty();//返回一个bool类型，表明a是否为空a.resize(10);//将a的元素个数调整为10，多删少补，值随机a.resize(10,2);//将a的元素个数调整为10，多删少补，值为2a.reserve(100);//将a的容量扩展为100a.swap(b);//将a和b中的元素整体交换reverse(a.begin(),a.end());//将元素翻转，逆序排列a.size();//返回vector的实际长度（包含的元素个数）a.clear();//把vector清空a.back()//返回尾a.front();//返回首a.insert(a,begin()+i,qwq);//在第i个元素后面插入qwqa.push_back(qwq);//尾部插入qwqa.pop_back();//删除尾a.at(i);//访问i号元素a.erase(a.begin()+i);//删除第i+1个元素a.erase(a.begin()+i,a.end()+j);//删除区间[i,j-1]\r\n","categories":["OI"],"tags":["笔记","STL","vector"]},{"title":"不！要！再！摆！啦！","url":"/articles/%E4%B8%8D%EF%BC%81%E8%A6%81%EF%BC%81%E5%86%8D%EF%BC%81%E6%91%86%EF%BC%81%E5%95%A6%EF%BC%81/","content":"从某种意义上说我的假期已经开始天了，而我也已经摆了天了，可能学了一点儿东西，已经全就饭吃了。\r\n看了大佬的博客，总结了一下在四月份之前（然鹅还有春季赛）要学的东西：\r\n（还有我之前那一堆写了题目没有内容的笔记）\r\n\r\n图论\r\n先学会链式向前星再说呜呜呜\r\n\r\n割点\r\n桥\r\n连通块\r\n\r\nDP\r\n\r\n所有\r\n\r\n数据结构\r\n\r\n分块\r\n树状数组\r\n此处省略项\r\n\r\n字符串\r\n\r\n自动机\r\n哈希表\r\n\r\n基本算法\r\n\r\n熟练掌握\r\n\r\n\r\n哦哦哦，还有whk\r\n\r\n数学\r\n\r\n必修三四\r\n\r\n物理\r\n\r\n必修二+一半三\r\n\r\n化学\r\n\r\n必修二\r\n\r\n英语\r\n\r\n套卷\r\n阅读练习\r\n\r\n生物\r\n\r\n必修二\r\n\r\n\r\n","categories":["随笔"],"tags":["flag"]},{"title":"位运算——从零基础到入门","url":"/articles/%E4%BD%8D%E8%BF%90%E7%AE%97%E2%80%94%E2%80%94%E4%BB%8E%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%88%B0%E5%85%A5%E9%97%A8/","content":"\r\n左移：左移一位，相当于某数乘以。比如左移位变为  变为，表示为。因此左移位,相当于该数乘以。\r\n右移：右移一位，相当于某数除以，比如右移1位变为  变为，表示为。因此右移位，相当于该数除以。\r\n与运算：按位进行“与”运算，两数同一位都为时结果为，否则为。例如：101&amp;110=100。\r\n或运算：按位进行“或”运算，两数同一位都为时结果为，否则为。例如：101|110=111。\r\n非运算：按位取反。例如~101=010；\r\n\r\n若当前状态为s，对s有下列操作。 1. 判断第位是否为：\r\n(s&amp;(1&lt;&lt;i))==0，意思是将左移位与s进行与运算后，看结果是否为。 2. 将第位设置为：\r\ns|(1&lt;&lt;i)，意思是将左移位与s进行或运算。 3. 将第位设置为：\r\ns&amp;~(1&lt;&lt;i)，意思是s与第位为，其余位为的数进行与运算。\r\n例如：s=1010101，i=5；\r\ns&amp;(1&lt;&lt;i)：1010101&amp;0100000=0000000；\r\ns|(1&lt;&lt;i)：1010101&amp;0100000=1110101；\r\ns&amp;~(1&lt;&lt;i)：1010101&amp;1011111=1010101；\r\n发现自己真的是鱼，半个多月前学的位运算现在基本都已经忘得差不多了（悲）\r\n","categories":["OI"],"tags":["笔记","进制","位运算"]},{"title":"图的存储学习笔记","url":"/articles/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"开幕雷击\r\n\r\n\r\n图(A)\r\n\r\n\r\n\r\n图(B)\r\n\r\n\r\n\r\n图(C)\r\n\r\n二维数组邻接矩阵存储\r\n定义int g[105][105]。\r\n的值，表示从点到点的边的权值，定义如下：\r\n\r\n当与之间有边或弧时，取值为（不带权）或权值。\r\n当与之间无边或弧时，取值为（不带权）或。\r\n\r\n举个例子：\r\n\r\n图(A) \r\n图(B) \r\n图(C) \r\n\r\n代码如下：\r\n#include &lt;bits/stdc++.h&gt;using namespace std;int i,j,k,e,n;double g[105][105];double w;int main(){    cin&gt;&gt;n;\tmemset(g,127,sizeof(g));    cin&gt;&gt;e;    for(k=1;k&lt;=e;k++)    {        cin&gt;&gt;i&gt;&gt;j&gt;&gt;w;        g[i][j]=w;        g[j][i]=w;//有向图省略    }    return 0;}\r\n数组模拟邻接表存储\r\n前置芝士\r\n\r\n出边：以这个结点为起点的边。\r\n入边：以这个结点为终点的边。\r\n\r\n图的邻接表存储法，又叫链式存储法。\r\n\r\n可以采用数组模拟链表。\r\n适合于稀疏图。\r\n\r\n​ 对于一个有个点条边的图，在使用\r\n代码如下：\r\n#include &lt;bits/stdc++.h&gt;using namespace std;//寄了，建不明白了，我不适合图论，然鹅今年CSP-S三道图论题，寄\r\n","categories":["OI"],"tags":["笔记","图论"]},{"title":"倍增——从零基础到入门","url":"/articles/%E5%80%8D%E5%A2%9E%E2%80%94%E2%80%94%E4%BB%8E%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%88%B0%E5%85%A5%E9%97%A8/","content":"\r\n","categories":["OI"],"tags":["笔记","倍增"]},{"title":"倍增求LCA学习笔记","url":"/articles/%E5%80%8D%E5%A2%9E%E6%B1%82LCA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"\r\n","categories":["OI"],"tags":["数据结构","笔记","倍增","LCA"]},{"title":"图论前置芝士","url":"/articles/%E5%9B%BE%E8%AE%BA%E5%89%8D%E7%BD%AE%E8%8A%9D%E5%A3%AB/","content":"图的定义\r\n点用边连起来就是图。严格意义上讲，图是一种数据结构。\r\n常用名词集合\r\n有向图\r\n图的边有方向，只能按箭头方向从一点到另一点。\r\n无向图\r\n图的边没有方向，可以双向。\r\n节点的度\r\n无线图中与结点相连的边的数目。\r\n结点的入度\r\n在有向图中，以这个结点为终点的有向边的数目。\r\n结点的出度\r\n在有向图中，以这个结点为起点的有向边的数目。\r\n权值\r\n边的“费用”。\r\n连通\r\n如果图中结点U、V之间存在一条从U通过若干边、点到V的通路，则称U、V是连通的。\r\n回路&amp;环\r\n起点和终点相同的路径。\r\n阶\r\n图中结点的个数。\r\n完全图\r\n一个阶的完全无向图含有条边；一个阶的完全有向图含有条边。\r\n稠密图\r\n一个边数接近完全图的图。\r\n稀疏图\r\n一个边数远远少于完全图的图。\r\n强连通分量\r\n有向图中任意两点都连通的最大子图。\r\n特殊地，单个点也算一个强连通分量。\r\n奇点\r\n跟这个点相连的边数目有奇数个的点。\r\nE、V\r\nE代表边的集合，V代表结点的集合。\r\n","categories":["OI"],"tags":["笔记","图论"]},{"title":"字符串Hash学习笔记","url":"/articles/%E5%AD%97%E7%AC%A6%E4%B8%B2Hash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"前置芝士\r\n哈希算法\r\n哈希算法是通过一个哈希函数H，将一种数据（包括字符串、较大的数等）转化为能够用变量表示或是直接就可作为数组下标的数。\r\n哈希值\r\n通过哈希函数转化的得到的数值。\r\n可以通过哈希值实现快速查找和匹配。\r\n字符串Hash\r\n简介\r\n寻找长度为的主串中的匹配串（长度为）出现的位置或次数的问题属于字符串匹配问题。\r\n朴素的想法是枚举所有起始位置，再直接检查是否匹配。\r\n可以不适用的直接比较字符串的方法，而是比较长度为的主串S的子串的哈希值是否相等，这就是哈希算法的原理——字符串Hash。\r\n流程\r\n\r\n前置芝士：进制转换\r\n\r\n如果我们用的时间计算长度为的字符串的哈希值，那么我们就没必要学字符串Hash了。\r\n所以我们需要用到一个叫做滚动哈希的优化技巧。\r\n我们选取两个合适的互质常数和（），假设字符串，那么我们定义哈希函数：。\r\n正常的数字是十进制的，这里是基数，相当于把字符串看作是进制数。\r\n这一过程是递推计算的。因为我太菜了下面讲解省略求模运算，因为可以用自然溢出大法！！！\r\n 举个栗子：\r\n字符串，令A表示1，B表示2。  判断字符串从位置开始的长度为的子串的哈希值与另一匹配串的哈希值是否相等。 \r\n容易证明，上面的柿子是正确的，所以大家牢记即可。\r\n于是只需要预求得，就能在时间内得到任意字符串的子串哈希值，从而完成字符串匹配。于是乎，字符串匹配问题的算法时间复杂度就为。\r\n举个栗子：\r\n字符串，，，。 \r\n正确性\r\n出现不同字符串哈希值相等的概率越低越好。\r\n所以有以下两种方法：\r\n\r\n自然溢出法\r\n利用unsigned long long无符号整数计算哈希值，相当于对哈希值。\r\n双模法\r\n顾名思义，就是搞一个二元数组存储哈希值，两个数，两个数都相同哈希值才相同。\r\n\r\n在速度上单模法会被自然溢出法虐，在正确率上单模法不如双模法和自然溢出法（毕竟自然溢出法的重复概率是），所以它是废物，所以不介绍单模法了QwQ。\r\n实现\r\n练手板子题\r\n友情赠送板子题代码（自然溢出法）：\r\n#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;//POJ不支持万能头QAQusing namespace std;typedef unsigned long long ull;const int maxn=1e6+5,maxm=1e4+5;ull power[maxn],hash[maxn];char s1[maxm],s2[maxn];int b=520;int main(){    power[0]=1;    for(int i=1;i&lt;1e6;i++)        power[i]=power[i-1]*b;    int t;    cin&gt;&gt;t;    while(t--)    {        scanf(\"%s%s\",s1+1,s2+1);        int n=strlen(s1+1),m=strlen(s2+1);        hash[0]=0;        for(int i=1;i&lt;=m;++i)            hash[i]=hash[i-1]*b+(ull)(s2[i]-'A'+1);        ull s=0;        for(int i=1;i&lt;=n;i++)            s=s*b+(ull)(s1[i]-'A'+1);        int ans=0;        for(int i=0;i&lt;=m-n;i++)            if(s==hash[i+n]-hash[i]*power[n]) ++ans;        cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}\r\n完结撒花！\r\n","categories":["OI"],"tags":["笔记","字符串","Hash"]},{"title":"快速幂学习笔记","url":"/articles/%E5%BF%AB%E9%80%9F%E5%B9%82%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"引入\r\n\r\n求。\r\n\r\n快速幂\r\n对于\r\n\r\n若是偶数，则；\r\n若是奇数，则。\r\n\r\n继续将分解成、……次后，就会变成。我们称这种快速计算幂运算的方法为快速幂算法。\r\n代码如下：\r\n\r\n递归版\r\nint quickpow(int a,int b,int n){    if(b==1) turn a;    if(b%2==0)    {        int t=quickpow(a,b/2,n);        turn t*t%n;    }    else    {        int t=quickpow(a,b/2,n);        t=t*t%n;        t=t*a%n;        turn t;    }}\r\n非递归版\r\nint quickpow(int a,int b,int n){    int t=1;    while(b)    {        if(b%2==1) t=t*a%n;        a=a*a%n;        b=b/2;    }    return t;}\r\n\r\n\r\n练手板子题\r\n\r\n","categories":["OI"],"tags":["笔记","数学"]},{"title":"廿四的雪(1)","url":"/articles/%E5%BB%BF%E5%9B%9B%E7%9A%84%E9%9B%AA(1)/","content":"\r\n\r\n下雪啦！\r\n\r\n","categories":["随笔"],"tags":["廿四的雪"]},{"title":"排序方式笔记","url":"/articles/%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F%E7%AC%94%E8%AE%B0/","content":"最好情况下\r\n\r\n冒泡排序\r\n\r\n图解： \r\n\r\n插入排序\r\n\r\n图解： \r\n\r\n\r\n平均情况下\r\n\r\n快速排序\r\n\r\n图解： \r\n\r\n\r\n最坏情况下\r\n\r\n堆排序 （等学会之后再填坑）\r\n归并排序\r\n\r\n图解： \r\n\r\n\r\n","categories":["OI"],"tags":["笔记","算法","排序"]},{"title":"我的2022","url":"/articles/%E6%88%91%E7%9A%842022/","content":"中考前篇\r\n九上期末\r\n要写我的，其实要从年的年末开始。\r\n话说那是一次西安交大少年班的考试，我十分愚蠢地报了名，其实这也没啥；但是，在校内人选的选拔中，由于是按照八年级下的期末考试成绩排名的（注意当时我们已经初三了诶！但是还是初二的成绩），再加上我们居然要和大佬云集的理工本部一起比成绩，期末考试拉胯的我自然是以一名之差成功落选，其实这也没啥嗷（其实有啥，毕竟可以去西安交大玩儿诶0v0谁不想呢）；但是，居然被隔壁班的某哥们儿暗戳戳的嘲讽了QAQ，寄😭，结果就因为这次刺激，我成功地发奋学习了一个月（具体就是每天学到点，然后记忆特别深的是当时我把理化的错题都手敲了一遍打印出来，加起来能有五六十页纸（由此可见我的蒻，错的题都快赶上对的了呜呜呜），导致那个学期我的物理化学笔记本超级厚），然后期末考试还是寄了吧，据说算政史是名，不算政史可能是年级前了（注意看今年我们一共只有个的还有一个学习很牛的特长生），所以说我肯定是和无缘了嗷。\r\n寒假\r\n然后我的寒假就开始了。这个寒假也是一个难忘的寒假。主要内容包括：爆看冬奥会每场有中国的比赛+爆抄本练习册答案，注意看，这时候的我还在抄中考复习练习册的答案，这么看我开学考试肯定是要寄了，事实的确如此。不过看冬奥会其实不是没有一点用处，我中考语文议论文撞大运考可能也是跟看冬奥会有关ψ(｀∇´)ψ。\r\n\r\n插入一段，说到这儿不多不少我中考之后的私信还被徐梦桃回复了诶0v0：\r\n\r\n\r\n私信被世界冠军回复！！！\r\n\r\n（具体内容就是感谢桃姐的论据让我在议论文上嘎嘎乱杀)\r\n\r\n书接上文，讲到了我在中考前最后一个假期的离谱经历，当时其实没有想那么多，貌似是觉得时间还很充裕（?）或者感觉自己稳了（?也不知道是稳上啥，可能是三甲吧QwQ），现在发现自己真是心大。\r\n备考\r\n假期很快就结束乐，但是貌似开学不久就又回归线上了，然鹅本心大人居然都没拿几本书回家（虽然当时离中考已经只有天啦啦啦啦），然后好像百日誓师就是线上开的，再然后天也是线上开的，上了一个多月网课之后初三就开学了。关于网课的听课效果我觉得还行吧，毕竟我是那种再上课时候喜欢疯狂发言（当然现在越发腼腆）的性格（笑），回归线下乐！\r\n然鹅，回归线下之后直接就来了一场双基，没记错的话（肯定不会记错）是年级名，这个成绩差不多是中水平吧，当时可能有一点心理波动（因为我的心理定位是名左右，上个育明也不错😉），但是想想初中三年，从一开始被很多人看好，到后来逐渐成为了年级笑话（浅浅提一下我的黑历史，包括但不仅限于把老师气得上不了课，被班主任赶回家，撤凳子发蹲一个上午……），可能那些曾经看好我的老师都认为我是个华而不实的弱鸡吧，想想其实也挺不甘的，但是没办法，初中三年教会我最重要的就是：拿实力说话，没有实力，没人会把你当根葱；你要是够强，你怎么样都是好的。\r\n双基之后，度过了一段平淡的时光，现在想想备考的日子其实很美好，那种紧张中带着一丝放松，焦虑中带着一丝释然，真的好好。这期间发生的一件最重要的事就是：我已经全面放弃记叙文了（因为我的记叙文分数上限就是56呜呜呜），感谢这次选择，要不就不会有我那中考杀疯了的语文分数和我出人意料的结果。\r\n紧接着就是一模了（突然发现的前半段全部都是围绕着中考的(✿◡‿◡)），算是我的一个辉煌时刻吧，虽然只是年级，但是谁能想到我是在数学动点暴扣分再搭配上班级倒数的语文成绩下达到的呢。写到这儿我突然想起来前文那个隔壁班的哥们儿，他在上述的所有考试其实是初二以来的所有考试都在薄纱我（悲，不过马上就要上演逆转大戏了，当然上了高中我又被他薄纱了）。这里还要提到一位我的发小，之前我和她的成绩算是同病相怜，结果到了双基我已经是被单方面薄纱了。写到这儿发现自己又菜又没用，呜呜呜，可能我的水平就是育明了（悲）。发现现实好残酷，小学的时候人人都觉得上是小菜一碟（甚至初一初二我都觉得还有机会），后来逐渐被现实击垮了。不甘心，但是实力不行。话说期末考试之后我们晚课分出来一个小班（这是可以说的吗），在这个小班里我当然是被疯狂薄纱，还记得前面说的隔壁班哥们儿吗（他现在居然还在我隔壁班），他分钟一道题，我分钟都切不了，作出的正解辅助线都能被我给写挂，寄。记得当时我们有数学晚课前个小时都是小考试，一道一道，做完了才能去吃饭啊啊啊啊，结果每次我都是最后一个做完的（数学老师还是我们班主任结果我每天被疯狂鄙视呜呜呜），我天我的数学水平居然被一个现在要选文的女生嘎嘎乱杀这岂是我能忍的，但是我真的不会呜呜呜感觉自己好没用呜呜呜他们分钟就能全切我却一直卡着呜呜呜，题暴力解法也能写挂呜呜呜，所以每天数学晚课就成了我的减肥日，根本吃不上饭呜呜呜，好不容易食堂整点儿人吃的东西啥也抢不上呜呜呜；物理晚课多选题训练，我直接一看到托里拆利实验装置就傻眼一遇到浮力压强就懵逼但是其他人全都哐哐列式只有我哐哐懵逼哐哐瞎搞，寄；英语晚课写作文，别人：高中四六级雅思托福词汇，我：乱套句式+疯狂套路+小学词汇。寄。\r\n紧接着就是二模了，突然发现自己真是鱼，居然连中考前的事儿都已经忘了呜呜呜，我现在连圆周运动公式都记不住呜呜呜，我好没用呜呜呜，不过二模好像也挺平常的，但是遗憾也肯定有，比如没有成功AK一张数学卷（初中数学从未拿过星人）（但是二模数学是真的简单），比如语文作文开头爆改字不知道的还以为我已经成一代绝世文豪了写作文怎么飘逸，一看分数成功挂大分稳稳拿下，这一次的排名是，因为这次考试的难度所以有很多后起之秀来到了那个小班，但毕竟是后起之秀所以我本以为自己能在数学和物理上找回自信但没想到我居然被曾经年级名开外的选手乱杀呜呜呜我好没用。\r\n二模之后就是最激动人心的环节——报考！！！当然我没有丝毫犹豫因为太菜报了指标育明、统招+育明、统调是啥我忘了，反正就是纯托底选择，普高本来说是文谷，结果文谷不能保证我不去渤海，所以报考结束的几小时前临时改成了中（很长一段时间里我认为这里才是我的归宿）。话说这其中也想过报冲一下，毕竟很多一模年级前十二模都掉出前二十了还报了，所以在那张愚蠢的腾讯文档表格里有一段时间我是在那一栏的，然鹅后来我被嘲了，也被别的家长嘲了，所以后来只能改成育明，注意看此时此刻以我的成绩在报育明的人里是绝对是数一数二，然鹅马上转折就来了。\r\n报考结束之后感觉大多数人好像都觉得自己报的啥就能考上啥（说白了就是飘了），但是我不敢啊，因为就在去年我认识的一个学习超好的小哥哥就是因为中考前觉得自己稳了结果最后分之差从直接掉到中了，所以我必须以此为鉴！！！所以中考前的一两周当别人都在play的时候只有我在默默地胡乱study（其实还是实力不行，怕自己中考挂了），然后中考前还请了几次短假自己在家整理了一些知识，好像就是这样。\r\n然后就是中考啦啦啦啦啦！中考前一天还真是有点儿小感动（毕竟是朝夕相处了年呢），老师、同学……可能中考之后就很难再见面了。当时可能大多数人都觉得我稳了吧（但是马上就要到转折点了0v0），记得当时团员要交块钱团费，我去送的时候收团费的老师还跟我说了一声加油，挺感动的。这所学校，真的就要和我分开了，还是有一些不舍的呜呜呜，其实自己挺容易被感动的。（多愁善感的基因）\r\n中考篇\r\n（其实这一段在之前貌似写过）\r\nDay 1\r\n语文\r\n具体可以看我前面的朋友圈内容乐，当时记忆比较深的就是别人都在大太阳底下站着唠嗑等待入场，然后我因为没找到同学一个人跑到那个木亭子下面看我蒟蒻的笔记，然后进了考场答题，嗯，挺顺的，作文和大阅读可能卡了一下，但也还好吧。\r\n估分：，运气好的话+\r\n理化\r\n同样挺顺的，物理它没出浮力和压强啦啦啦啦啦！当时出考场听到有人说难（?）有人说简单，我觉得简单的有点儿让人不敢相信。（真的，非凡尔赛）\r\n估分：+=\r\nDay 2\r\n数学\r\n寄了。前面答得还挺顺手，题折纸题不会果断放弃（直到最后我都不会正解，直接拿刻度尺+量角器瞎搞算的破数居然对了），到了题看了看旁边的哥们儿，嗯，比我慢一点儿，还行，现在距离考试结束还有一个多小时，然鹅谁会想到我在接下来的一个多小时里颗粒无收😭。\r\n先开，送分；开始瞎搞结果发现自己假证了，寄；想开，又不会。忙活了一会儿，胡写几个相似三角形证明，写了一波假证上去，跑了。毕竟题切不掉我已经习惯了呜呜呜。瞎搞操作熟练的让人心疼。\r\n再开，送分；好像是一道很水的计算题，切了；看起来很简单，一上手做直接被我的暴力解法搞成了次方程，不会解，扔那儿，摆了。\r\n在考场上估了个分，吧，不过当时我还天真的以为这次数学超级难，大家都不会，嗯，还行。\r\n看了看旁边的哥们儿，呦呵，他题好像切了，难不成这题其实很简单？\r\n接下来一直到考试结束的半小时里，我就开始在、之间反复横跳，期间还水掉了题，但是其他的没有一点进展啊啊啊啊啊啊啊啊。\r\n还有分钟，看了看旁边的哥们儿，呦呵，他题好像也切了，难不成这题其实很简单？\r\n难道他是绝世高手？还是我寄了？\r\n出考场，听到有人说数学简单，比一模简单（?），一模我可是切了啊，满脑问号.jpg。算了，不管了。\r\n估分：\r\n英语\r\n很顺手，考试结束前还检查出来一个价值分的愚蠢错误。\r\n估分：\r\n崩溃\r\n考完英语，听到了一堆人说数学简单，、都切了，连之前数学难优秀的几个女同学居然都全切了在考场外面拉着数学老师的手活蹦乱跳，只有我据说手脚冰凉。\r\n回家就崩溃了，应该是寄了。数学就得和别人差+。完了，天要亡我。\r\nDay 3\r\n政史\r\n凑数用。唯一记得的就是那天下雨了，结果我下车的时候校长就在马路对面，给我喊了个加油，可是我已经寄了诶╯︿╰。感觉自己会成为下一届的标准反面教材，最有希望却摔得最惨。\r\n估分：必过\r\n中考后篇\r\n中考后玩了几天吧，还拍了毕业照，同学老师问我考得怎么样，我只能说寄了，说自己数学的惨，结果他们都不信（?），崩了，真的感觉完了。\r\n7.14\r\n出分日。\r\n本来说点出分，后来改成了点，本来想先睡一觉，结果一直睡不着。\r\n实际：\r\n乐了！！！数学瞎搞居然给了我这么多过程分！！！两道题加在一起只扣分诶！！！\r\n和同学比了一下，出乎意料的高，年级第，我天，历史最佳成绩了。\r\n还记得那个隔壁班的哥们儿吗，时隔两年，我终于有一次战胜了他。\r\n一堆老师来问我分（甚至还有前面那位收团费的老师），结果全惊了，毕竟在这之前连我自己都觉得我寄了，已经做好去中报道的准备了。\r\n泪目了。不负我。\r\n7.20\r\n出录取结果日。\r\n其实还在纠结这个分够不够的统招，我觉得挺稳的，果然，高分踩统招线入学。虽然没进羟基班但已经是意外之喜了。毕竟我是蒟蒻爆发户。有效防止了我在羟基班被人薄纱\r\n开始了自己在廿四被薄纱的日子\r\n新生活篇\r\n\r\n学了OI（但是我好菜呜呜呜希望假期结束能有所长进吧呜呜呜）\r\n当了一种很新的班委——纪律委员。这个职务可能别的班都没有吧。主要是由于班的特殊性。说到我是怎么当上的，其实挺奇妙的（毕竟曾经的我可是开班会被点名批评的不安定分子）。话说期中考试结束后的一天，老师叫鸡哥出去，然后我蚌埠住了乐了一下，然后老师就叫我也出去。然后老师表扬了鸡哥，然后问我能不能管理班级纪律，然后鸡哥蚌埠住了乐了一下，然后我就乐了，然后我就说能，然后就没有然后了。\r\n真心希望有一天班不需要纪律委员来管纪律，大家都能自己管好自己的纪律啊（相信会的OwO）\r\n认识了很多新同学\r\n学到了很多东西（比如自己真的很菜）\r\n考了一次期中考试，寄了\r\n期中考试之后努力学习了，不知道期末考试怎么样\r\n被薄纱\r\n得了一次新冠，已经好乐\r\n\r\n终章\r\n这篇年终总结算是结束了，现在想想我的真是跌宕起伏又精彩纷呈呢。\r\n年结束了，我很怀念它。\r\n年，对我好一点啊QwQ。\r\n\r\n愿一切美好，都能如愿以偿。\r\n\r\n","categories":["随笔"],"tags":["回忆","我的20××"]},{"title":"整数快读模板","url":"/articles/%E6%95%B4%E6%95%B0%E5%BF%AB%E8%AF%BB%E6%A8%A1%E6%9D%BF/","content":"inline int read(){\tint x=0,f=1;\tchar ch=getchar();\twhile(ch&gt;'9'||ch&lt;'0'){if(ch=='-') f=-1;ch=getchar();}\twhile(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}\treturn x*f;}\r\n","categories":["OI"],"tags":["模板"]},{"title":"欧拉回路学习笔记","url":"/articles/%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"\r\n"},{"title":"DFS剪枝学习笔记","url":"/articles/%E6%B7%B1%E6%90%9C%E5%89%AA%E6%9E%9D%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"前置芝士\r\n搜索的进程可以看作是从树根出发，遍历一棵倒置的树——搜索树的过程。\r\n剪枝，顾名思义，就是通过某种判断，避免一些不必要的遍历过程。\r\n剪枝的原则\r\n正确性\r\n保证不丢失正确的结果\r\n准确性\r\n尽可能多地剪去不能通向正解的枝条。\r\n高效性\r\n剪枝的技巧\r\n优化搜索顺序\r\n排除等效冗余\r\n在搜索过程中，如果能够判定从搜索树的的当前节点上沿着某几条不同分支到达的子树是等效的，那么只需要对其中的一条分值进行搜索。\r\n可行性剪枝\r\n在搜索过程中，及时对当前状态进行检查，如果发现分支已经无法到达递归边界，就执行回溯。\r\n某些题目条件的范围限制是一个区间，此时可行性剪枝也被称为“上下界剪枝”。\r\n最优性剪枝\r\n在最优化问题的搜索过程中，如果当前花费的代价已经超过当前搜到的最优解，此时可以停止对当前分支的搜索，执行回溯。\r\n记忆化\r\n记录每个状态的搜索结果，在重复遍历一个状态时直接检索并返回。\r\n类似于对图进行深搜时，标记一个节点是否已经被访问过。\r\n\r\n练手板子题\r\n提示：最优性剪枝、可行性剪枝\r\n\r\n","categories":["OI"],"tags":["笔记","DFS","剪枝"]},{"title":"组合数学学习笔记","url":"/articles/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"前置芝士\r\n加法原理\r\n若完成一件事的方法有类，其中第类方法包括种不同的方法，且这些方法互不重合，则完成这件事共有：种不同的方法。\r\n乘法原理（分步计数原理）\r\n若完成一件事需要个步骤，其中第个步骤有种不同的完成方法，且这些步骤互不干扰，则完成这件事共有：种不同的方法。\r\n\n            区别：一个与分类有关，一个与分步有关；\r加法原理是“分步完成”，乘法原理是“分类完成”。\r\n          \r\n排列及其公式\r\n线排列\r\n定义\r\n一般地，从个不同的元素中，取出（）个元素按照一定的顺序排成一列，叫做从个不同的元素中取出个元素的一个线排列。\r\n从个不同的元素中取出（）个元素的所有线排列的个数，叫做从个不同元素中取出个元素的排列数，用符号或表示。\r\n排列数公式\r\n\r\n全排列\r\n把个不同的元素全部取出，按照一定的顺序排成一列，叫做个不同的元素的一个全排列。\r\n全排列的个数叫做个元素的全排列数，用符号表示。\r\n此时，。\r\n相异元素可重复排列\r\n从个不同元素中可以重复地选取出个元素的排列，叫做相异元素可重复排列。\r\n排列总数为。\r\n不全相异元素的全排列\r\n如果在个元素中，\r\n","categories":["OI"],"tags":["数学","组合数学"]},{"title":"线段树学习笔记","url":"/articles/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"\r\n事情的起因来自于年的元旦，一位蒟蒻百无聊赖中误入了大佬们的团队作业，好奇心满满地点开了第一道题，看着一行半的题干信心满满地准备大干一场，调了分钟写出一个分治+DP的思路，直接忽略时间复杂度是的事实，结果UKE了无数次后上CF一测发现第一个点就TLE了😭。然后发现这道题要用线段树优化，痛定思痛从开始学线段树。\r\n啊啊啊明天的团队作业已经出了我要切了它啊啊啊！\r\n\r\n基础\r\n线段树是一种基于分治思想的二叉树结构，用于在区间上进行信息统计。\r\n性质\r\n\r\n线段树的每一个节点都代表一个区间。\r\n线段树具有唯一的根节点，代表的区间是整个统计范围。\r\n线段树的每个叶节点都代表一个长度为的元区间。\r\n对于每个内部节点，它的左子节点是，右子节点是，其中。\r\n\r\n\r\n\r\n线段树的区间视角、二叉树视角\r\n\r\n除去树的最后一层，整棵线段树一定是一棵完全二叉树，树的深度为。\r\n编号\r\n\r\n“父子倍”节点编号\r\n\r\n根节点编号为。\r\n编号为的节点的左子节点编号为，右子节点编号为。\r\n\r\n\r\n保存线段树的数组长度要不小于。\r\n建树\r\n给定一个长度为的序列。。\r\nstruct SegmentTree{    int l,r;    int sum;    int lazy;    //lazy懒标记，下面有讲QwQ}t[size*4];void build(int k,int l,int r){    t[k].l=l,t[k].r=r;    if(l==r){t[k].sum=a[l];return;}    int mid=(l+r)/2;    build(k*2,l,mid);    build(k*2+1,mid+1,r);    t[k].sum=max(t[k].sum,t[k*2+1].sum);}build(1,1,n);\r\n单点查询+修改\r\n从根节点出发，递归找到代表区间的叶节点，然后从下往上更新以及它的所有祖先节点上保存的信息。时间复杂度为。\r\n//change A[x] to vvoid change(int k,int x,int v){    if(t[k].l==t[k].r){t[k].sum=v;return;}    int mid=(t[k].l+t[k].r)/2;    if(x&lt;=mid) change(k*2,x,v);    else change(k*2+1,x,v);    t[k].sum=max(t[2*k].sum,t[2*k+1].sum);}change(1,x,v);\r\n区间查询\r\n查询序列在区间上的最大值。\r\n从根节点开始，递归执行以下过程。\r\n\r\n若完全覆盖了当前节点代表的区间，则立即回溯，并且该节点的值为候选答案。\r\n若左子节点与有重叠部分，则递归访问左子节点。\r\n若右子节点与有重叠部分，则递归访问右子节点。\r\n\r\nint ask(int k,int l,int r){    if(l&lt;=t[k].l&amp;&amp;r&gt;=t[k].r) return t[k].sum;    int mid=(t[k].l+t[k].r)/2;    int val=-(1&lt;&lt;30);    if(l&lt;=mid) val=max(val,ask(k*2,l,r));    if(l&gt;mid) val=max(val,ask(k*2+1,l,r));    return val;}cout&lt;&lt;ask(1,l,r)&lt;&lt;endl;\r\n该查询过程会把询问区间先线段树上分成个节点，取它们的最大值作为答案。\r\n区间修改\r\n前置芝士\r\n延迟标记，可能就是懒标记。\r\n顾名思义，延迟标记就是更新到某一子区间时直接打上标记，延迟对它的子节点的更新操作。但是大家都叫它懒标记，所以下面我们叫它懒标记。\r\n\r\n当lazy[i]!=0时，表示更新过了而的子节点还没有更新。\r\n\r\n其实可以这么理解嗷。以下图为例：\r\n\r\n\r\n举个栗子\r\n\r\n如果我们要修改区间上的值，令其都，那么可以更新区间、、、，每找到一个这样的真包含区间就加上一个懒标记。我们观察到，、的子节点的值没有更新诶，但是没关系，当我们遍历到这个有懒标记的节点时，如果有懒标记，那就可以把它的子节点给更新并且打上懒标记，再把这个懒标记给置。以此类推。\r\n\r\n懒标记要和修改相同，比如要，懒标记就是。\r\n如果要进行乘法操作，和上面的一样，懒标记就是5。\r\n\r\n实操\r\n\r\n乐了，已经崩溃了，自己迷迷糊糊的，不知道能不能写明白。代码就不放出来吓唬人了。\r\n为了不误人子弟我就先咕了，等大彻大悟之后一定回来填坑！！！\r\n给自己找点儿信心：STO ncwzdlsd Orz\r\n\r\n但是，善良的蒟蒻为了防止大家抄题解欣赏别人的代码思路的时候看不懂，还是介绍一下add、pushup、pushdown、change、query操作吧QwQ。呵呵真是一个口是心非的男人\r\n注：下文的均代表当前节点。\r\n\r\nadd：给一个节点进行更新并且打上懒标记。\r\n代码如下：\r\nvoid add(int k,int l,int r,int val){    tree[k].sum+=(r-l+1)*val;    tree[k].lazy+=val;}\r\npushup：把修改上推，即更新父节点的值。\r\n代码如下：\r\nvoid pushup(int k){    //之前用的SegmentTree，现在不拽了，老老实实用tree    tree[k].sum=tree[k*2].sum+tree[k*2+1].sum;}\r\n解释：\r\n\r\n父节点的等于子节点的元素和。\r\n\r\npushdown：把修改下推，即更新子节点的值。\r\n代码如下：\r\nvoid pushdown(int k,int l,int r){    int mid=(l+r)/2;    add(k*2,l,mid,tree[k].lazy);//左子节点    add(k*2+1,mid+1,r,tree[k].lazy);//右子节点    lazy[k]=0;}\r\nchange：修改操作。把全部+val\r\n代码如下：\r\nvoid change(int k,int l,int r,int val){    if(l&lt;=tree[k].l&amp;&amp;tree[k].r&lt;=r)//真包含    {        tree[k].sum+=(tree[k].r-tree[k].l+1)*val;        tree[k].lazy+=val;        return;    }    pushdown(k,tree[k].l,tree[k].r);    int mid=(tree[k].l+tree[k].r)/2;    if(l&lt;=mid)        change(k*2,l,r,val);//左子树与更新区间有交集    if(r&gt;mid)        change(k*2+1,l,r,val);    pushup(k);}\r\nquery：查询区间和。\r\n代码如下：\r\nint query(int k,int l,int r){    if(l&lt;=tree[k].l&amp;&amp;tree[k].r&lt;=r)//当前区间真包含于查询区间        return tree[k].sum;    pushdown(k,tree[k].l,tree[k].r);    int res=0;    int mid=(tree[k].l+tree[k].r)/2;    if(l&lt;=mid)        res+=query(k*2,l,r);    if(r&gt;mid)        res+=(k*2+1,l,r);    return res;}\r\n\r\n动态开点与线段树合并\r\n\r\n不会，正在学习……咕咕咕咕咕\r\n\r\n可能没完结完结撒花！！！\r\n线段树，学了一整天，感觉自己还是半懵状态，不过慢慢来应该会懂的。\r\n不行了，我高低得拜一下自己。\r\nSTO ncwzdlsd\r\n\r\n练手板子题\r\n\r\n我天这道板子题我居然写不明白了回炉重造吧呜呜呜\r\n大家还是不要像我一样用结构体了还是改回数组吧\r\n","categories":["OI"],"tags":["数据结构","笔记","线段树"]},{"title":"背包问题详解（01背包，完全背包与多重背包）","url":"/articles/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%8801%E8%83%8C%E5%8C%85%EF%BC%8C%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E4%B8%8E%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%EF%BC%89/","content":"\r\n前段时间学背包问题的时候发现的一篇学长的宝藏博客QwQ，写得真的好\r\n\r\n背包问题\r\n01背包\r\n问题简述：有m个物品待放入一个容量为V的背包，每件物品都有其对应的体积w与价值v，从中选取一些物品放入背包，使得物品总价值最大。\r\n算法思路：考虑动态规划，令f(i,j)为只考虑前i件物品，背包容量为j时能得到的最大价值。那么当只考虑第i件物品放不放时，便有以下两种情况：\r\n1，第i件物品体积大于当前背包容量，不放：f(i,j)=f(i-1,j)；\r\n2，第i件物品体积小于等于当前背包容量，则考虑放与不放哪个更优：\r\nf(i,j)=max(f(i-1,j),f(i-1,j-w[i])+v[i])\r\n那么就得到核心代码：\r\nfor(int i=1;i&lt;=m;i++)    for(int j=1;j&lt;=V;j++)    {       if(j=w[i])            f[i][j]=max(f[i-1][j],f[i-1][j-w[i]]+v[i]);       else            f[i][j]=f[i-1][j];    }\r\n观察状态转移方程式，我们发现，对第i件物品的选择只与对前一件物品的选择有关，于是考虑滚动数组优化空间。\r\n注意：当使用滚动数组时，第二层循环应由V到w[i]。这是因为在状态转移时用到的背包容量均小于等于j，倒着循环可以保证j前面都是只考虑i-1件物品时的数据，而j后面是更新过的前i件物品的数据，这样顺带保证了当j&lt;w[i]，f(i,j)=f(i-1,j)。\r\nfor(int i=1;i&lt;=m;i++)\tfor(int j=V;j&gt;=w[i];j--)   \t\tf[j]=max(f[j],f[j-w[i]]+v[i]);\r\n练手板子题：传送门\r\n完全背包\r\n问题简述：有m种物品待放入一个容量为V的背包，每种物品都有无穷多件且有其对应的体积w与价值v，从中选取一些物品放入背包，使得物品总价值最大。\r\n算法思路：在01背包的基础上，由于每种物品都能被重复选择，考虑从1开始枚举每件物品被选择的次数k直到当前物品所占体积超过容量j，则有：f(i,j)=max(f(i,j),f(i,j-k*w[i])+k*v[i])。由于在每次循环中讨论的都是第i件物品的选择次数，故数组第一维为i，这也决定了在每次对j进行枚举后要将f(i,j)初始化：f(i,j)=f(i-1,j)。\r\n上核心代码：\r\nfor(int i=1;i&lt;=m;i++)\tfor(int j=1;j&lt;=V;j++)\t{        f[i][j]=f[i-1][j];        for(int k=1;k*w[i]&lt;=j;k++)                f[i][j]=max(f[i][j],f[i][j-k*w[i]]+k*v[i]);\t}\r\n观察状态转移方程式，参照01背包的思想再次考虑滚动数组优化：\r\n不难发现，完全背包的第二层循环是无需倒着枚举的。如上文所说，在每次对k进行枚举时讨论的都是对第i件物品的选择，故j前面的数据应为只考虑前i件物品时的数据，所以应正着循环。\r\n再考虑对k的枚举。每次循环都是在前一次循环的基础上多选择一件物品i放入背包，所以可以考虑变乘为加：f(j)=max(f(j),f(j-w[i])+v[i])，进一步优化时间。\r\nfor(int i=1;i&lt;=m;i++)\tfor(int j=w[i];j&lt;=V;j++)\t\tf[j]=max(f[j],f[j-w[i]]+v[i]);\r\n日常板子题时刻：传送门\r\n（不开longlong见祖宗哦\r\n多重背包\r\n问题简述：有n种物品待放入一个容量为V的背包，每种物品都有其对应的数量m，体积w与价值v，从中选取一些物品放入背包，使得物品总价值最大。\r\n算法思路：由于不能无限选择，这个问题又变回了01背包，只是加了对k的枚举。当我们熟练掌握前两种背包，想写出来一个多重背包也就不难了。\r\n核心代码又来了。\r\nfor(int i=1;i&lt;=n;i++)\tfor(int j=V;j&gt;=w[i];j--)\t\tfor(int k=1;k&lt;=m[i]&amp;&amp;k*w[i]&lt;=j;k++)\t\t\tf[j]=max(f[j],f[j-k*w[i]]+k*v[i]);\r\n我们发现，由于物品有数量的限制，第三层循环无法删去，那么又如何对时间进行优化呢？\r\n此时可以考虑使用二进制，由于可以表示之内的所有数，故m件物品一定可以进行二进制拆分成许多堆物品，每堆件又能看作一件质量为，价值为的物品，使复杂度优化一个。\r\n二进制拆分模拟如下：\r\nint vv,ww,mm,cnt=0;for(int i=1;i&lt;=n;i++){\tvv=read(),ww=read(),mm=read();\tfor(int j=1;j&lt;=mm;j&lt;&lt;=1)\t{\t\tv[++cnt]=vv*j,w[cnt]=ww*j;\t\tmm-=j;\t}\tif(mm) \t\tv[++cnt]=vv*mm,w[cnt]=ww*mm;}\r\n然后就是朴实无华01背包啦。\r\n板子：传送门\r\n（几天前用快读不加二进制优化还能卡过呢qwq\r\n","categories":["OI"],"tags":["笔记","算法","转载","背包"]},{"title":"费马小定理、欧拉定理学习笔记","url":"/articles/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86%E3%80%81%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"费马小定理\r\n如果是一个质数，而整数不是的倍数，则有。\r\n一般情况：\r\n欧拉定理\r\n欧拉函数\r\n对正整数，欧拉函数是小于等于的数中与互质的数的数目。\r\n引理1\r\n\r\n如果为某一个素数，则：；\r\n如果为某一个素数的的幂次，则：；\r\n如果为任意两个互质的数，的积，则：。\r\n\r\n引理2\r\n设为正整数的素数幂乘积表达式，则：。\r\n欧拉定理\r\n若与互质，则。\r\n","categories":["OI"],"tags":["笔记","数学"]},{"title":"质数筛选学习笔记","url":"/articles/%E8%B4%A8%E6%95%B0%E7%AD%9B%E9%80%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"Eratosthenes筛选法\r\n顾名思义就是数学家Eratosthenes发明的筛法，但是它的名字太长了，所以我们简称它为埃氏筛QwQ。\r\n基本思想\r\n质数的倍数一定不是质数。\r\n实现方法\r\n用一个长度为的数组保存信息，表示质数，表示合数。先假设所有的数都是质数（初始化为），从小到大枚举每一个质数，把的倍速都标记为非质数（置为）。\r\n如何枚举质数呢？从小到大扫描到时，若未被标记，则它不能被之间的任何数整除，则为质数。\r\n举个栗子：  可以发现，存在重复标记的耗时行为。实际上，小于的的倍数在扫描更小的数时就已经被标记过了。因此，可以优化一下，对于每个，把大于等于的的倍数标记为合数即可。\r\n代码如下：\r\nvoid primes(int n){    memset(v,0,sizeof(v));    for(int i=2;i&lt;=n;i++)    {        if(v[i]) continue;        cout&lt;&lt;i&lt;&lt;endl;        for(int j=i;j&lt;=n/i;j++) v[i][j]=1;    }}\r\n算法的时间复杂度为，效率非常接近于线性。时间复杂度的证明非常复杂，本蒟蒻也不太会，所以不证了QwQ\r\n线性筛法\r\n即使在优化后，埃氏筛仍然会重复标记合数。举个栗子，既会被标记又会被标记，其根本原因是算法不能确定唯一的产生的方式。\r\n所以，我们只要保证合数被它的最小质因数筛去就好啦！时间复杂度为。\r\n代码如下：（添加注释小能手上线）\r\nint v[maxn],prime[maxn];void primes(int n){    memset(v,0,sizeof(v));//存储最小质因子    int m=0;//质数数量    for(int i=2;i&lt;=n;i++)    {        if(v[i]==0)        {            v[i]=i;            prime[++m]=i;        }        for(int j=1;j&lt;=m;j++)        {            //i有比prime[j]更小的质因子或者超出n的范围            if(prime[j]&gt;v[i]||prime[j]&gt;n/i) break;            v[i*prime[j]]=prime[j];        }    }    for(int i=1;i&lt;=m;i++)        cout&lt;&lt;prime[i]&lt;&lt;endl;}\r\n","categories":["OI"],"tags":["数学","埃氏筛","线性筛"]},{"title":"贪心——从零基础到入门","url":"/articles/%E8%B4%AA%E5%BF%83%E2%80%94%E2%80%94%E4%BB%8E%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%88%B0%E5%85%A5%E9%97%A8/","content":"简介\r\n贪心算法是从问题的初始状态出发，通过若干次的贪心选择而得到的最优值（或较优值）。\r\n","categories":["OI"],"tags":["笔记","贪心"]},{"title":"逆元学习笔记","url":"/articles/%E9%80%86%E5%85%83%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"定义\r\n若，，互质，则称为的逆元，记为。\r\n用处\r\n逆元可以在计算时，转化为。\r\n求法\r\n扩展欧几里得算法\r\n根据逆元的定义，可转化为，用扩展欧几里得算法求解。\r\n友情赠送代码：\r\nvoid exgcd(int a,int b,int c,int &amp;x,int &amp;y){    if(a==0)    {        x=0;y=c/b;        return;    }    else    {        int tx,ty;        exgcd(b%a,a,tx,ty);        x=ty-(b/a)*tx;        y=tx;        return;    }}\r\n线性算法\r\n前置芝士：。\r\n设，，，则：。\r\n两边同时乘，就会得到：  于是，就可以递归求逆元啦！代码只有一行！\r\nA[i]=-(p/i)*A[p%i];\r\n实际上，这也提供了一种（众所周知表示时间复杂度更准确QwQ）的时间内求出单个数逆元的方法。\r\n","categories":["OI"],"tags":["笔记","数学","逆元"]},{"title":"链表学习笔记","url":"/articles/%E9%93%BE%E8%A1%A8%E2%80%94%E2%80%94%E4%BB%8E%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%88%B0%E5%85%A5%E9%97%A8/","content":"链表有很多种。下面列举一些。\r\n\r\n单链表：每个节点记录自己的后继。\r\n双链表：每个结点记录自己的前驱和后继。\r\n循环单链表：本身是一个单链表。最后一个节点的后继为第一个界点。\r\n循环双链表：本身是一个双链表，连成环形。\r\n块状链表：基本思想是将若干元素压缩成一块，将这些块串联起来。\r\n跳表：相当于平衡树。每个结点拥有自己的右指针和下指针，通过分层的方式来加速查询，而每个元素的层数由概率决定。\r\n\r\nP1160：\r\n利用一个双向链表维护这个队伍，每个同学记录自己左边和右边的同学。这样各种操作都可以O(1)的时间复杂度完成了。使用数组index定位某位同学的节点编号。\r\n#include &lt;iostream&gt;using namespace std;//注意万能头里有index数组struct node{    int pre,nxt,key;    node(int _key=0,int _pre=0,int _nxt=0)    {        pre=_pre;        nxt=_nxt;        key=_key;    }};node s[100005];int n,m,tot=0;int index[100005];void ins_back(int x,int y){    int now=index[x];    s[++tot]=node(y,now,s[now].nxt);    s[s[now].nxt].pre=tot;    s[now].nxt=tot;    index[y]=tot;}void ins_front(int x,int y){\tint now=index[x];\ts[++tot]=node(y,s[now].pre,now);    s[s[now].pre].nxt=tot;    s[now].pre=tot;    index[y]=tot;}void del(int x){\tint now=index[x];\tint le=s[now].pre,rt=s[now].nxt;\ts[le].nxt=rt;\ts[rt].pre=le;\tindex[x]=0;}int main(){\tindex[0]=0;    int x,k,p,now;    cin&gt;&gt;n;    s[0]=node();//  令0恒为最右边的结点 \tins_back(0,1);\tfor(int i=2;i&lt;=n;i++)\t{\t\tcin&gt;&gt;k&gt;&gt;p;\t\tp?ins_back(k,i):ins_front(k,i);\t}\t\tcin&gt;&gt;m;\tfor(int i=1;i&lt;=m;i++)\t{\t\tcin&gt;&gt;x;\t\tif(index[x])\t\t{\t\t\tdel(x);\t\t}\t}\tnow=s[0].nxt;\twhile(now)\t{\t\tcout&lt;&lt;s[now].key&lt;&lt;' ';\t\tnow=s[now].nxt;\t}\t    return 0;   }\r\n","categories":["OI"],"tags":["数据结构","笔记","题解"]},{"title":"随机数据生成与对拍","url":"/articles/%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%E4%B8%8E%E5%AF%B9%E6%8B%8D/","content":"\r\n这是一篇远古博客，之所以要重写是因为当年的我在关键时刻社死不敢找大佬请教（或者说大佬不屑搭理本蒟蒻），所以只能现在来补QAQ\r\n\r\n使用场景\r\n\r\n在无法获得实时评测反馈的比赛中，思考并实现了一个“高分解法”，但是再不会证明自己的结论，或者不能确保自己编写的程序是否完全正确。\r\n在平时解题时，自己编写的程序无法在Online\r\nJudge上取得Accepted结果，调试很久仍未发现错误。\r\n\r\n随机数据生成\r\n头文件cstdlib包含rand和srand两个函数，以及RAND_MAX常量。\r\nRAND_MAX是一个不小于的整数，一般来说，在Windows系统中为，在类Unix系统中为。\r\nrand()函数返回一个~RAND_MAX之间的随机整数int。\r\nsrand(seed)函数接受unsighed int类型的参数seed，以seed为随机种子。rand函数基于线性同余递推式生成随机数，“随机种子”相当于计算线性同余死的一个初始参数。\r\n当种子确定后，接下来产生的随机数列就是固定的，所以这种随机方法也被称为“伪随机”。因此，一般在随机数据生成程序main函数的开头，用当前系统时间作为随机种子。\r\n头文件ctime包含time函数，调用time(0)可以返回从年月日时分秒（Unix纪元）到现在的秒数。执行srand((unsigned)time(0))即可初始化随机种子。\r\n代码如下：\r\n#include&lt;cstdlib&gt;#include&lt;ctime&gt;int random(int n){    return (long long)rand()*rand()%n;}int main(){    srand((unsigned)time(0));    //···具体内容···}\r\n函数random(n)返回之间的随机整数，对int范围内的均能正常工作。\r\n对拍\r\n","categories":["OI"],"tags":["笔记","对拍","技巧"]}]