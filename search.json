[{"title":"UVA11806题解","url":"/2022/12/17/UVA11806%E9%A2%98%E8%A7%A3/","content":"设满足“第一行没有石子”的方案集为 ，最后一行没有石子的方案集为 ，第一列没有石子的方案集为 ，最后一列没有石子的方案集为 ，全集为 ，则所求答案是“在  中但不在\r\n任何一个集合中”的元素个数，可以用容斥原理求解。\r\n我们用二进制来表示 \r\n的所有搭配（\r\n对应于“空搭配”），如果在集合  或\r\n 中，相当于少了一列。假定最后剩了\r\n 行  列，方法数就是 。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int mod=1000007;const int maxk=500;int c[maxk+10][maxk+10];int main(){    memset(c,0,sizeof(c));    c[0][0]=1;    for(int i=0;i&lt;=maxk;i++)    {        c[i][0]=c[i][i]=1;        for(int j=1;j&lt;i;j++)            c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;    }    int t;    cin&gt;&gt;t;    for(int kase=1;kase&lt;=t;kase++)    {        int n,m,k,sum=0;        cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;        for(int s=0;s&lt;16;s++)        {            int b=0,r=n,qaq=m;            if(s&amp;1)            {                r--;                b++;            }            if(s&amp;2)            {                r--;                b++;            }            if(s&amp;4)            {                qaq--;                b++;            }            if(s&amp;8)            {                qaq--;                b++;            }            if(b&amp;1) sum=(sum+mod-c[r*qaq][k])%mod;            else sum=(sum+c[r*qaq][k])%mod;        }        printf(\"Case %d: %d\\n\",kase,sum);    }    return 0;}\r\n","categories":["OI"],"tags":["题解"]},{"title":"2022.11 and 2022.12","url":"/2022/12/17/2022.11%20and%202022.12/","content":"\r\n\r\n微信图片_20221217123150\r\n\r\n\r\n\r\n微信图片_20221217123200\r\n\r\n"},{"title":"我的2022","url":"/2023/01/01/%E6%88%91%E7%9A%842022/","content":"\r\n","categories":["随笔"],"tags":["我的20××"]},{"title":"算法竞赛中常用的几种排序方式","url":"/2022/11/17/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F/","content":"最好情况下\r\n\r\n冒泡排序 图解： \r\n插入排序 图解： \r\n\r\n平均情况下\r\n\r\n快速排序 图解： 代码：\r\n\r\n最坏情况下\r\n\r\n堆排序 （等我学会之后再填坑）\r\n归并排序 图解： \r\n\r\n","categories":["OI"],"tags":["算法","排序"]},{"title":"My Blog","url":"/2022/12/16/My-Blog/","content":"我的博客来了！！！\r\n","categories":["随笔"]},{"title":"廿四的雪","url":"/2022/12/18/2022-12-18-%E5%BB%BF%E5%9B%9B%E7%9A%84%E9%9B%AA/","content":"\r\n\r\n微信图片_20221218160748\r\n\r\n"},{"title":"链表——以P1160为例","url":"/2022/12/01/%E9%93%BE%E8%A1%A8%E2%80%94%E2%80%94%E4%BB%A5P1160%E4%B8%BA%E4%BE%8B/","content":"链表有很多种。下面列举一些。\r\n\r\n单链表：每个节点记录自己的后继。\r\n双链表：每个结点记录自己的前驱和后继。\r\n循环单链表：本身是一个单链表。最后一个节点的后继为第一个界点。\r\n循环双链表：本身是一个双链表，连成环形。\r\n块状链表：基本思想是将若干元素压缩成一块，将这些块串联起来。\r\n跳表：相当于平衡树。每个结点拥有自己的右指针和下指针，通过分层的方式来加速查询，而每个元素的层数由概率决定。\r\n\r\nP1160：\r\n利用一个双向链表维护这个队伍，每个同学记录自己左边和右边的同学。这样各种操作都可以O(1)的时间复杂度完成了。使用数组index定位某位同学的节点编号。\r\n#include &lt;iostream&gt;using namespace std;//注意万能头里有index数组struct node{    int pre,nxt,key;    node(int _key=0,int _pre=0,int _nxt=0)    {        pre=_pre;        nxt=_nxt;        key=_key;    }};node s[100005];int n,m,tot=0;int index[100005];void ins_back(int x,int y){    int now=index[x];    s[++tot]=node(y,now,s[now].nxt);    s[s[now].nxt].pre=tot;    s[now].nxt=tot;    index[y]=tot;}void ins_front(int x,int y){\tint now=index[x];\ts[++tot]=node(y,s[now].pre,now);    s[s[now].pre].nxt=tot;    s[now].pre=tot;    index[y]=tot;}void del(int x){\tint now=index[x];\tint le=s[now].pre,rt=s[now].nxt;\ts[le].nxt=rt;\ts[rt].pre=le;\tindex[x]=0;}int main(){\tindex[0]=0;    int x,k,p,now;    cin&gt;&gt;n;    s[0]=node();//  令0恒为最右边的结点 \tins_back(0,1);\tfor(int i=2;i&lt;=n;i++)\t{\t\tcin&gt;&gt;k&gt;&gt;p;\t\tp?ins_back(k,i):ins_front(k,i);\t}\t\tcin&gt;&gt;m;\tfor(int i=1;i&lt;=m;i++)\t{\t\tcin&gt;&gt;x;\t\tif(index[x])\t\t{\t\t\tdel(x);\t\t}\t}\tnow=s[0].nxt;\twhile(now)\t{\t\tcout&lt;&lt;s[now].key&lt;&lt;' ';\t\tnow=s[now].nxt;\t}\t    return 0;   }\r\n","categories":["OI"],"tags":["题解","数据结构"]}]