[{"title":"2022-12-18 廿四的雪","url":"/2022/12/18/2022-12-18-%E5%BB%BF%E5%9B%9B%E7%9A%84%E9%9B%AA/","content":"\r\n"},{"title":"2022.11 and 2022.12","url":"/2022/12/17/2022.11%20and%202022.12/","content":"\r\n\r\n"},{"title":"My Blog","url":"/2022/12/16/My-Blog/","content":"我的Hexo博客来了！！！\r\n","categories":["随笔"]},{"title":"UVA11806题解","url":"/2022/12/17/UVA11806%E9%A2%98%E8%A7%A3/","content":"设满足“第一行没有石子”的方案集为 ，最后一行没有石子的方案集为 ，第一列没有石子的方案集为 ，最后一列没有石子的方案集为 ，全集为 ，则所求答案是“在  中但不在\r\n任何一个集合中”的元素个数，可以用容斥原理求解。\r\n我们用二进制来表示 \r\n的所有搭配（\r\n对应于“空搭配”），如果在集合  或\r\n 中，相当于少了一列。假定最后剩了\r\n 行  列，方法数就是 。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int mod=1000007;const int maxk=500;int c[maxk+10][maxk+10];int main(){    memset(c,0,sizeof(c));    c[0][0]=1;    for(int i=0;i&lt;=maxk;i++)    {        c[i][0]=c[i][i]=1;        for(int j=1;j&lt;i;j++)            c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;    }    int t;    cin&gt;&gt;t;    for(int kase=1;kase&lt;=t;kase++)    {        int n,m,k,sum=0;        cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;        for(int s=0;s&lt;16;s++)        {            int b=0,r=n,qaq=m;            if(s&amp;1)            {                r--;                b++;            }            if(s&amp;2)            {                r--;                b++;            }            if(s&amp;4)            {                qaq--;                b++;            }            if(s&amp;8)            {                qaq--;                b++;            }            if(b&amp;1) sum=(sum+mod-c[r*qaq][k])%mod;            else sum=(sum+c[r*qaq][k])%mod;        }        printf(\"Case %d: %d\\n\",kase,sum);    }    return 0;}\r\n","categories":["OI"],"tags":["题解"]},{"title":"我的2022","url":"/2023/01/01/%E6%88%91%E7%9A%842022/","content":"\r\n","categories":["随笔"],"tags":["我的20××"]},{"title":"算法竞赛中常用的几种排序方式","url":"/2022/11/17/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F/","content":"最好情况下\r\n\r\n冒泡排序 图解： \r\n插入排序 图解： \r\n\r\n平均情况下\r\n\r\n快速排序 图解： 代码：\r\n\r\n最坏情况下\r\n\r\n堆排序 （等我学会之后再填坑）\r\n归并排序 图解： \r\n\r\n","categories":["OI"],"tags":["算法","排序"]},{"title":"链表——以P1160为例","url":"/2022/12/01/%E9%93%BE%E8%A1%A8%E2%80%94%E2%80%94%E4%BB%A5P1160%E4%B8%BA%E4%BE%8B/","content":"链表有很多种。下面列举一些。\r\n\r\n单链表：每个节点记录自己的后继。\r\n双链表：每个结点记录自己的前驱和后继。\r\n循环单链表：本身是一个单链表。最后一个节点的后继为第一个界点。\r\n循环双链表：本身是一个双链表，连成环形。\r\n块状链表：基本思想是将若干元素压缩成一块，将这些块串联起来。\r\n跳表：相当于平衡树。每个结点拥有自己的右指针和下指针，通过分层的方式来加速查询，而每个元素的层数由概率决定。\r\n\r\nP1160：\r\n利用一个双向链表维护这个队伍，每个同学记录自己左边和右边的同学。这样各种操作都可以O(1)的时间复杂度完成了。使用数组index定位某位同学的节点编号。\r\n#include &lt;iostream&gt;using namespace std;//注意万能头里有index数组struct node{    int pre,nxt,key;    node(int _key=0,int _pre=0,int _nxt=0)    {        pre=_pre;        nxt=_nxt;        key=_key;    }};node s[100005];int n,m,tot=0;int index[100005];void ins_back(int x,int y){    int now=index[x];    s[++tot]=node(y,now,s[now].nxt);    s[s[now].nxt].pre=tot;    s[now].nxt=tot;    index[y]=tot;}void ins_front(int x,int y){\tint now=index[x];\ts[++tot]=node(y,s[now].pre,now);    s[s[now].pre].nxt=tot;    s[now].pre=tot;    index[y]=tot;}void del(int x){\tint now=index[x];\tint le=s[now].pre,rt=s[now].nxt;\ts[le].nxt=rt;\ts[rt].pre=le;\tindex[x]=0;}int main(){\tindex[0]=0;    int x,k,p,now;    cin&gt;&gt;n;    s[0]=node();//  令0恒为最右边的结点 \tins_back(0,1);\tfor(int i=2;i&lt;=n;i++)\t{\t\tcin&gt;&gt;k&gt;&gt;p;\t\tp?ins_back(k,i):ins_front(k,i);\t}\t\tcin&gt;&gt;m;\tfor(int i=1;i&lt;=m;i++)\t{\t\tcin&gt;&gt;x;\t\tif(index[x])\t\t{\t\t\tdel(x);\t\t}\t}\tnow=s[0].nxt;\twhile(now)\t{\t\tcout&lt;&lt;s[now].key&lt;&lt;' ';\t\tnow=s[now].nxt;\t}\t    return 0;   }\r\n","categories":["OI"],"tags":["题解","数据结构"]},{"title":"随机数据生成与对拍","url":"/2022/11/19/%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%E4%B8%8E%E5%AF%B9%E6%8B%8D/","content":"\r\n这是一篇远古博客，之所以要重写是因为当年的我在关键时刻社死不敢找大佬请教（或者说大佬不屑搭理本蒟蒻），所以只能现在来补QAQ\r\n\r\n使用场景\r\n\r\n在无法获得实时评测反馈的比赛中，思考并实现了一个“高分解法”，但是再不会证明自己的结论，或者不能确保自己编写的程序是否完全正确\r\n在平时解题时，自己编写的程序无法在Online\r\nJudge上取得Accepted结果，调试很久仍未发现错误\r\n\r\n随机数据生成\r\n头文件cstdlib包含rand和srand两个函数，以及RAND_MAX常量。\r\nRAND_MAX是一个不小于的整数，一般来说，在Windows系统中为，在类Unix系统中为。\r\nrand()函数返回一个~RAND_MAX之间的随机整数int。\r\nsrand(seed)函数接受unsighed int类型的参数seed，以seed为随机种子。rand函数基于线性同余递推式生成随机数，“随机种子”相当于计算线性同余死的一个初始参数。\r\n当种子确定后，接下来产生的随机数列就是固定的，所以这种随机方法也被称为“伪随机”。因此，一般在随机数据生成程序main函数的开头，用当前系统时间作为随机种子。\r\n头文件ctime包含time函数，调用time(0)可以返回从年月日时分秒（Unix纪元）到现在的秒数。执行srand((unsigned)time(0))即可初始化随机种子。\r\n代码如下：\r\n#include&lt;cstdlib&gt;#include&lt;ctime&gt;int random(int n){    return (long long)rand()*rand()%n;}int main(){    srand((unsigned)time(0));    //···具体内容···}\r\n函数random(n)返回之间的随机整数，对int范围内的均能正常工作。\r\n对拍\r\n","categories":["OI"],"tags":["对拍","技巧"]}]