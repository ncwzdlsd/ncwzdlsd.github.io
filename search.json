[{"title":"2022.11 and 2022.12","url":"/articles/2022.11%20and%202022.12/","content":"感慨万千。\n\n\n","categories":["随笔"]},{"title":"BST学习笔记","url":"/articles/BST%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"前置芝士\n喜闻乐见的英语学习时间（大雾）。\n二叉查找树（BST），即Binary Search Tree。\n举个栗子：\n\n性质\n\n\n树中每个结点被赋予了一个权值。\n\n\n若结点xxx的左子树不空，则xxx的左子树中所有节点的值均小于结点xxx的值。\n\n\n若结点xxx的右子树不空，则xxx右子树中所有结点的值均大于结点xxx的值。\n\n\n任意结点的左、右子树也分别是二叉搜索树。\n\n\n作用\n\n\n表示有序集合\n\n\n建立索引或优先队列\n\n\n维护有序数集\n\n\n操作\n遍历\n对于一棵已知的二叉查找树，从小到大输出其结点的值，只需对其进行二叉树的中序遍历，即递归地先输出其左子树，再输出其本身，然后输出其右子树。\n时间复杂度为O(n)O(n)O(n)。\n代码如下：\nvoid print(int p){    if(!p) return;    print(left[p]);    printf(\"%d\\n\",a[p]);    print(right[p]);}\n","categories":["OI"],"tags":["数据结构","笔记","BST"]},{"title":"Floyd算法进阶版学习笔记","url":"/articles/Floyd%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"","categories":["OI"],"tags":["笔记","Floyd算法","最小环","传递闭包"]},{"title":"KMP学习笔记","url":"/articles/KMP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"","categories":["OI"],"tags":["笔记","KMP","字符串"]},{"title":"My Blog","url":"/articles/My-Blog/","content":"我的博客来了！！！\n","categories":["随笔"]},{"title":"RMQ学习笔记","url":"/articles/RMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"前置芝士\nRMQ，即Range Maximum(Minimum) Query的缩写。（记住它叫RMQ就对了）\n顾名思义，RMQ就是询问某个区间内的最大值或最小值。\nST算法\n简介\nST算法通常用在要多次询问一些区间的最值的问题中。\n时间复杂度\n它可以做到O(nlog⁡n)O(n \\log n)O(nlogn)的预处理，O(1)O(1)O(1)回答每个询问。\n使用条件\n使用ST算法的条件是没有修改操作，它适用于没有修改操作并且询问次数较多（10610^6106级别甚至更大）的情况。\n原理\n动态规划。\n流程\n预处理\n我们用a[1…n]表示一组数。\n设f(i,j)f(i,j)f(i,j)表示从aia_iai​到ai+2j−1−1a_{i+2^{j-1}-1}ai+2j−1−1​这个范围内的最大值，也就是以aia_iai​为起点连续2j2^j2j个数的最大值。由于元素个数为2j2^j2j个，所以从中间平均分成两部分，每一部分的元素个数刚好为2j−12^{j-1}2j−1个，也就是说，把f(i,j)f(i,j)f(i,j)分为f(i,j−1)f(i,j-1)f(i,j−1)和f(i+2j−1,j−1)f(i+2^{j-1},j-1)f(i+2j−1,j−1)。\n整个区间的最大值一定是左右两部分最大值的较大值，满足动态规划的最优化原理。\n状态转移方程：f(i,j)=max⁡(f(i,j−1),f(i+2j−1,j−1)f(i,j)=\\max(f(i,j-1),f(i+2^j-1,j-1)f(i,j)=max(f(i,j−1),f(i+2j−1,j−1)，边界条件为f[i][0]=a[i]。\n预处理时间复杂度：O(nlog⁡n)O(n \\log n)O(nlogn)。\n询问\n要询问区间[li,ri][l_i,r_i][li​,ri​]的最大值，则先求出最大的xxx满足2x≤ri−li+12^x \\leq r_i-l_i+12x≤ri​−li​+1，那么区间[li,ri]=[li,li+2x−1]∪[ri−2x+1,ri][l_i,r_i]=[l_i,l_i+2^x-1] \\cup [r_i-2^x+1,r_i][li​,ri​]=[li​,li​+2x−1]∪[ri​−2x+1,ri​]。\n两个区间的元素个数都为2x2^x2x，所以[li,ri][l_i,r_i][li​,ri​]的最大值为max⁡(f(li,x),f(ri−2x+1,x))\\max(f(l_i,x),f(r_i-2^x+1,x))max(f(li​,x),f(ri​−2x+1,x))，可以在O(1)O(1)O(1)内计算出来。\n虽然这两个区间有交集，但是对于求区间最值来说没有影响，这就是ST算法适用于求区间最值的原因。\n求区间[x,y][x,y][x,y]最大值，直接给出表达式：\nk=log⁡2(y−x+1),ans=max⁡(f(x,k),f(y−2k)+1,x).\\begin{split}\n\\\\&amp;k=\\log_2(y-x+1),\n\\\\&amp;ans=\\max(f(x,k),f(y-2^k)+1,x).\n\\end{split}\n​k=log2​(y−x+1),ans=max(f(x,k),f(y−2k)+1,x).​\n技巧\n因为cmath库中的log2函数效率不高，通常还会使用O(N)O(N)O(N)递推预处理出1∼N1 \\sim N1∼N这NNN种区间长度各自对应的kkk值。具体地，⌊log⁡2d⌋=⌊log⁡2d2⌋+1\\lfloor \\log_2d \\rfloor=\\lfloor \\log_2\\dfrac{d}{2} \\rfloor+1⌊log2​d⌋=⌊log2​2d​⌋+1。\nST VS 线段树\n\n\nST算法的优势\n\n\n实现非常简单\n\n\n效率比线段树更高\n\n\n\n\n线段树的优势\n\n可以更好地维护动态的信息，而ST算法不易推广到动态\n可以维护更多的信息，而ST算法只能维护最值\n\n\n\n\n练手板子题\n\n友情提供板子题代码：\n#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=1e6+5,logn=20;int log[maxn],f[maxn][logn+5];int n,m,x,y;inline int read(){\tint x=0,f=1;\tchar ch=getchar();\twhile(ch&gt;'9'||ch&lt;'0'){if(ch=='-') f=-1;ch=getchar();}\twhile(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}\treturn x*f;}int main(){    n=read(),m=read();    for(int i=1;i&lt;=n;++i)    {        f[i][0]=read();    }    log[0]=-1;    for(int i=1;i&lt;=n;++i)        log[i]=log[i/2]+1;    for(int j=1;j&lt;=logn;++j)        for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;++i)            f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;j-1)][j-1]);    \t\t//注意加减乘除运算符的优先级高于位移运算符    while(m--)    {        x=read(),y=read();        int s=log[y-x+1];        printf(\"%d\\n\",max(f[x][s],f[y-(1&lt;&lt;s)+1][s]));    }    return 0;}\n","categories":["OI"],"tags":["数据结构","笔记","RMQ"]},{"title":"OI回忆录","url":"/articles/OI%E5%9B%9E%E5%BF%86%E5%BD%95/","content":"OI回忆录，顾名思义，是即将AFO的OIer写的回忆录。\n然鹅，目前为止我并没有AFO，写这篇OI回忆录，其实是因为最近看了太多很强的OIer退役了，多愁善感的基因令我也有些伤感——我也会有这一天，是在寒假集训结束后，模拟赛被薄纱而退役？还是苟到了CSP、NOIP，考完之后以一个对不起自己的成绩退役？还是……\n一些这样的文章，就有点儿伤感捏。\n高一上\n高一上，最先来的便是五科竞赛布道宣讲，自己一直对计算机很感兴趣，所以虽然父母想让选数学/物理但最后还是选了信息。（现在想想是好的毕竟我的数学和物理真的有点儿拉）\n当时新高一零基础的有131313个人吧（差不多）。\n开始gg讲的都是一些简单的东西，记得刚学的时候自己就像打了鸡血一样把OpenJudge上1.1∼1.41.1 \\sim 1.41.1∼1.4的题全部刷完了，好像还得到gg的表扬乐。然后我就摆了\n期中考试我寄了，寄的很彻底，在信竞队伍里垫底，当时其实有点儿迷茫，感觉自己好没用，当时好像还考了一场模拟赛，我虽然不是垫底但也有点儿拉胯。动力全无。\n期中考试之后，还剩777个人，甚至连年级前202020的巨佬都AFO了。（后来又加入了一个）\n后来111111月的某天……算了这段是比较私人的东西就不写出来了。（大体可能就是看见了某个人然后莫名其妙地被激励了有了目标（?））自那之后努力了一段时间，每天中午不吃饭不睡觉地往机房跑（但是好像并没有学多少东西），网课的时候也在刷题，所以洛谷很快到了300+300+300+AC，乐。（然鹅还不是橙名呜呜呜）\n然后高一上就结束乐。记录一下当时会的东西（截止到2022/12/25）：\n\n寒假(1)\n","categories":["OI"],"tags":["回忆"]},{"title":"SPFA算法学习笔记","url":"/articles/SPFA%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"\n关于SPFA，它死了\n\n所以这篇博客没有什么写的必要了\n不过SPFA还是要学的，已经在学了，咕咕咕，学会了来填坑QwQ\n","categories":["OI"],"tags":["笔记","图论","SPFA"]},{"title":"Treap学习笔记","url":"/articles/Treap%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"","categories":["OI"],"tags":["数据结构","笔记","Treap","平衡树"]},{"title":"最短路学习笔记","url":"/articles/SSSP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"","categories":["OI"],"tags":["笔记","图论","最短路","SSSP"]},{"title":"UVA11806题解","url":"/articles/UVA11806%E9%A2%98%E8%A7%A3/","content":"设满足“第一行没有石子”的方案集为 AAA，最后一行没有石子的方案集为 BBB，第一列没有石子的方案集为 CCC，最后一列没有石子的方案集为 DDD，全集为 SSS，则所求答案是“在 SSS 中但不在A,B,C,DA,B,C,DA,B,C,D 任何一个集合中”的元素个数，可以用容斥原理求解。\n我们用二进制来表示 A,B,C,DA,B,C,DA,B,C,D 的所有搭配（SSS 对应于“空搭配”），如果在集合 CCC 或 DDD 中，相当于少了一列。假定最后剩了 rrr 行 ccc 列，方法数就是 C(rc,k)C(rc,k)C(rc,k)。\n#include &lt;bits/stdc++.h&gt;using namespace std;const int mod=1000007;const int maxk=500;int c[maxk+10][maxk+10];int main(){    memset(c,0,sizeof(c));    c[0][0]=1;    for(int i=0;i&lt;=maxk;i++)    {        c[i][0]=c[i][i]=1;        for(int j=1;j&lt;i;j++)            c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;    }    int t;    cin&gt;&gt;t;    for(int kase=1;kase&lt;=t;kase++)    {        int n,m,k,sum=0;        cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;        for(int s=0;s&lt;16;s++)        {            int b=0,r=n,qaq=m;            if(s&amp;1)            {                r--;                b++;            }            if(s&amp;2)            {                r--;                b++;            }            if(s&amp;4)            {                qaq--;                b++;            }            if(s&amp;8)            {                qaq--;                b++;            }            if(b&amp;1) sum=(sum+mod-c[r*qaq][k])%mod;            else sum=(sum+c[r*qaq][k])%mod;        }        printf(\"Case %d: %d\\n\",kase,sum);    }    return 0;}\n","categories":["OI"],"tags":["题解","容斥原理"]},{"title":"lower_bound和upper_bound——从零基础到入门","url":"/articles/lower-bound%E5%92%8Cupper-bound%E2%80%94%E2%80%94%E4%BB%8E%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%88%B0%E5%85%A5%E9%97%A8/","content":"\n\nlower_bound(begin,end,val)：在值有序的数组连续地址[begin,end)中找到第一个位置并返回其地址，使得val插入在这个位置前面，整个数组仍然保持有序。\n\n\nupper_bound(begin,end,val)：在值有序的数组连续地址[begin,end)中找到最后一个位置并返回其地址，使得val插入在这个位置前面，整个数组仍然保持有序。\n\n\n假如排序后的数组名为a，可以认为其返回值减去数组名a（其实等于a[0]）刚好等于所要找的元素的数组下标。\n我们可以用lower_bound和upper_bound求数的出现次数，即upper_bound()-lower_bound()。\n","categories":["OI"],"tags":["笔记"]},{"title":"rope——从零基础到入门","url":"/articles/rope%E2%80%94%E2%80%94%E4%BB%8E%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%88%B0%E5%85%A5%E9%97%A8/","content":"~~众所周知，~~可以用STL里的rope实现简单的可持久化数据结构。\n","tags":["数据结构","STL"]},{"title":"map——从零基础到入门","url":"/articles/map%E2%80%94%E2%80%94%E4%BB%8E%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%88%B0%E5%85%A5%E9%97%A8/","content":"map容器是一个映射表（key-value型），其内部实现是一棵红黑树。\nmap的key和value可以是任意类型。\nmap容器经常被当作Hash表使用，但是操作的时间复杂度为O(log⁡n)O(\\log n)O(logn)，略慢于传统Hash表。\n常见操作\n\n\nsize、empty、clear、begin、end、count\n\n\nh.find(x)：在变量名为h的map中查找key为xxx的二元组。\n\n\ninsert、erase\n\n\n搭配迭代器\n添加注释小能手上线\nmap&lt;int,int&gt; h;h.insert(make_pair(1,2));map&lt;int,int&gt;::iterator it=h.begin(),itlow,itup;itlow=h.lower_bound('b');//itlow指向大于等于‘b’的第一个元素itup=h.upper_bound('d');//同理，指向大于‘d’键值的第一个元素pair&lt;int,int&gt; p=*it;h.erase(it);h.erase(make_pair(2,3));\n\n\n[]操作\nh[key]返回key映射到的value的引用，时间复杂度为O(log⁡n)O(\\log n)O(logn)。\n还可以对h[key]进行赋值操作，改变key对应的value。\n若查找的key不存在，执行h[key]后，h会自动新建一个二元组(key,zero)，zero表示一个广义零值，如整数000，空字符串等。\n强烈建议在[]操作查询之前，先用find检查key的存在性。\n\n\n","categories":["OI"],"tags":["笔记","STL"]},{"title":"vector——从零基础到入门","url":"/articles/vector%E2%80%94%E2%80%94%E4%BB%8E%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%88%B0%E5%85%A5%E9%97%A8/","content":"\n来自于一个邻接表建图建了半天没建明白的蒟蒻，他现在已经改用结构体存图了\nSTL大法好\n\nvector可理解为变长数组，它的内部实现基于倍增思想。\n前置芝士\n设nnn，mmm为vector的实际长度和最大长度。\n向vector加入元素前，若n=mn=mn=m，则在内存申请2m2m2m的连续空间，并把内容转移到新的地址上（同时释放旧的空间），再执行插入。从vector中删除元素后，若n≤m4n \\leq \\dfrac{m}{4}n≤4m​，则释放一半的空间。\nvector支持随机访问，即对于任意的下标0≤i&lt;n0 \\leq i &lt; n0≤i&lt;n，可以像数组一样用[i][i][i]取值。\n但它不是链表，不支持在任意位置O(1)O(1)O(1)插入。为了保证效率，元素的增删一般应该在末尾进行。\n声明\n#include &lt;vector&gt;vector&lt;int&gt; a;vector&lt;int&gt; b[233];//第一维长233，第二维长度动态变化struct rec{}vector&lt;rec&gt; c;\n操作\nvector&lt;int&gt; a;a.empty();//返回一个bool类型，表明a是否为空a.resize(10);//将a的元素个数调整为10，多删少补，值随机a.resize(10,2);//将a的元素个数调整为10，多删少补，值为2a.reserve(100);//将a的容量扩展为100a.swap(b);//将a和b中的元素整体交换reverse(a.begin(),a.end());//将元素翻转，逆序排列a.size();//返回vector的实际长度（包含的元素个数）a.clear();//把vector清空a.back()//返回尾a.front();//返回首a.insert(a,begin()+i,qwq);//在第i个元素后面插入qwqa.push_back(qwq);//尾部插入qwqa.pop_back();//删除尾a.at(i);//访问i号元素a.erase(a.begin()+i);//删除第i+1个元素a.erase(a.begin()+i,a.end()+j);//删除区间[i,j-1]","categories":["OI"],"tags":["笔记","STL","vector"]},{"title":"位运算——从零基础到入门","url":"/articles/%E4%BD%8D%E8%BF%90%E7%AE%97%E2%80%94%E2%80%94%E4%BB%8E%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%88%B0%E5%85%A5%E9%97%A8/","content":"\n\n左移：左移一位，相当于某数乘以222。比如110110110左移111位变为110011001100 ⇔\\Leftrightarrow⇔ 666变为121212，表示为(110&lt;&lt;1)=1100(110&lt;&lt;1)=1100(110&lt;&lt;1)=1100。因此左移xxx位,相当于该数乘以2x2^x2x。\n\n\n右移：右移一位，相当于某数除以222，比如110110110右移1位变为111111 ⇔\\Leftrightarrow⇔ 666变为333，表示为(110&gt;&gt;1)=11(110&gt;&gt;1)=11(110&gt;&gt;1)=11。因此右移xxx位，相当于该数除以2x2^x2x。\n\n\n与运算：按位进行“与”运算，两数同一位都为111时结果为111，否则为000。例如：101&amp;110=100。\n\n\n或运算：按位进行“或”运算，两数同一位都为000时结果为000，否则为111。例如：101|110=111。\n\n\n非运算：按位取反。例如~101=010；\n\n\n若当前状态为s，对s有下列操作。\n\n\n判断第iii位是否为000：(s&amp;(1&lt;&lt;i))==0，意思是将111左移iii位与s进行与运算后，看结果是否为000。\n\n\n将第iii位设置为111：s|(1&lt;&lt;i)，意思是将111左移iii位与s进行或运算。\n\n\n将第iii位设置为000：s&amp;~(1&lt;&lt;i)，意思是s与第iii位为000，其余位为111的数进行与运算。\n\n\n例如：s=1010101，i=5；s&amp;(1&lt;&lt;i)：1010101&amp;0100000=0000000；s|(1&lt;&lt;i)：1010101&amp;0100000=1110101；s&amp;~(1&lt;&lt;i)：1010101&amp;1011111=1010101；\n发现自己真的是鱼，半个多月前学的位运算现在基本都已经忘得差不多了（悲）\n","categories":["OI"],"tags":["笔记","进制","位运算"]},{"title":"倍增——从零基础到入门","url":"/articles/%E5%80%8D%E5%A2%9E%E2%80%94%E2%80%94%E4%BB%8E%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%88%B0%E5%85%A5%E9%97%A8/","content":"简介\n倍增，顾名思义就是成倍增长，主要是在进行递推时，如果状态空间很大，通常的线性做法无法满足时间与空间复杂度的要求，可以通过成倍增长的方式，递推状态空间中在222的整数次幂位置上的值作为代表。当需要其他位置上的值时，通过“任意整数可以表示成若干个222的次幂项的和”这一性质，使用之前求出的代表值拼成所需的值。\n“倍增”与“二进制划分”思想结合，降低了很多问题的时间与空间复杂度。\n应用\n快速幂\nRMQ\nLCA\n","categories":["OI"],"tags":["笔记","倍增"]},{"title":"向心力的6个公式","url":"/articles/%E5%90%91%E5%BF%83%E5%8A%9B%E7%9A%846%E4%B8%AA%E5%85%AC%E5%BC%8F/","content":"一直背不下来QAQ\n向心力FnF_nFn​，线速度vvv，角速度ω\\omegaω，周期TTT，频率fff，转速nnn。\n\n\nFn=mω2rF_n=m\\omega^2rFn​=mω2r\n\n\nFn=mv2rF_n=m\\dfrac{v^2}{r}Fn​=mrv2​\n\n\nFn=mωvF_n=m\\omega vFn​=mωv\n\n\nFn=m(2πT)2rF_n=m\\left(\\dfrac{2\\pi}{T}\\right)^2rFn​=m(T2π​)2r\n\n\nFn=m(2πf)2rF_n=m(2\\pi f)^2rFn​=m(2πf)2r\n\n\nFn=m(2πn)2rF_n=m(2\\pi n)^2rFn​=m(2πn)2r\n\n\n","categories":["whk"],"tags":["笔记","物理","力学","公式"]},{"title":"倍增求LCA学习笔记","url":"/articles/%E5%80%8D%E5%A2%9E%E6%B1%82LCA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"","categories":["OI"],"tags":["数据结构","笔记","倍增","LCA"]},{"title":"图论前置芝士","url":"/articles/%E5%9B%BE%E8%AE%BA%E5%89%8D%E7%BD%AE%E8%8A%9D%E5%A3%AB/","content":"图的定义\n点用边连起来就是图。严格意义上讲，图是一种数据结构。\n常用名词集合\n有向图\n图的边有方向，只能按箭头方向从一点到另一点。\n无向图\n图的边没有方向，可以双向。\n节点的度\n无线图中与结点相连的边的数目。\n结点的入度\n在有向图中，以这个结点为终点的有向边的数目。\n结点的出度\n在有向图中，以这个结点为起点的有向边的数目。\n权值\n边的“费用”。\n连通\n如果图中结点U、V之间存在一条从U通过若干边、点到V的通路，则称U、V是连通的。\n回路&amp;环\n起点和终点相同的路径。\n阶\n图中结点的个数。\n完全图\n一个nnn阶的完全无向图含有n×(n−1)2\\dfrac{n \\times (n-1)}{2}2n×(n−1)​条边；一个nnn阶的完全有向图含有n×(n−1)n \\times (n-1)n×(n−1)条边。\n稠密图\n一个边数接近完全图的图。\n稀疏图\n一个边数远远少于完全图的图。\n强连通分量\n有向图中任意两点都连通的最大子图。\n特殊地，单个点也算一个强连通分量。\n奇点\n跟这个点相连的边数目有奇数个的点。\nE、V\nE代表边的集合，V代表结点的集合。\n","categories":["OI"],"tags":["笔记","图论"]},{"title":"字符串Hash学习笔记","url":"/articles/%E5%AD%97%E7%AC%A6%E4%B8%B2Hash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"前置芝士\n哈希算法\n哈希算法是通过一个哈希函数H，将一种数据（包括字符串、较大的数等）转化为能够用变量表示或是直接就可作为数组下标的数。\n哈希值\n通过哈希函数转化的得到的数值。\n可以通过哈希值实现快速查找和匹配。\n字符串Hash\n简介\n寻找长度为nnn的主串SSS中的匹配串TTT（长度为mmm）出现的位置或次数的问题属于字符串匹配问题。\n朴素的想法是枚举所有起始位置，再直接检查是否匹配。\n可以不适用O(m)O(m)O(m)的直接比较字符串的方法，而是比较长度为mmm的主串S的子串的哈希值是否相等，这就是哈希算法的原理——字符串Hash。\n流程\n\n\n前置芝士：进制转换\n\n\n如果我们用O(m)O(m)O(m)的时间计算长度为mmm的字符串的哈希值，那么我们就没必要学字符串Hash了。\n所以我们需要用到一个叫做滚动哈希的优化技巧。\n我们选取两个合适的互质常数bbb和hhh（b&lt;hb&lt;hb&lt;h），假设字符串C=c1c2⋯cmC=c_1c_2 \\cdots c_mC=c1​c2​⋯cm​，那么我们定义哈希函数：H(C)=(c1bm−1+c2bm−2+⋯+cmb0) mod hH(C)=(c_1b^{m-1}+c_2b^{m-2}+ \\cdots +c_mb^0) \\bmod hH(C)=(c1​bm−1+c2​bm−2+⋯+cm​b0)modh。\n正常的数字是十进制的，这里bbb是基数，相当于把字符串看作是bbb进制数。\n这一过程是递推计算的。因为我太菜了下面讲解省略求模运算，因为可以用自然溢出大法！！！\nH(C,k+1)=H(C,k)×b+ck+1H(C,k+1)=H(C,k) \\times b+c_{k+1}\nH(C,k+1)=H(C,k)×b+ck+1​\n举个栗子：\n字符串C=ACDAC=\\texttt{ACDA}C=ACDA，令A表示1，B表示2。\nH(C,1)=1H(C,2)=1×b+3H(C,3)=1×b2+3×b+4H(C,4)=1×b3+3×b2+4×b+1\\begin{align}\n&amp;H(C,1)=1\\\\\n&amp;H(C,2)=1 \\times b+3\\\\\n&amp;H(C,3)=1 \\times b^2+3 \\times b+4\\\\\n&amp;H(C,4)=1 \\times b^3+3 \\times b^2+4 \\times b+1\n\\end{align}\n​H(C,1)=1H(C,2)=1×b+3H(C,3)=1×b2+3×b+4H(C,4)=1×b3+3×b2+4×b+1​​\n判断字符串C=c1c2⋯cmC=c_1c_2 \\cdots c_mC=c1​c2​⋯cm​从位置k+1k+1k+1开始的长度为nnn的子串C′=ck+1ck+2⋯ck+nC'=c_{k+1}c_{k+2} \\cdots c_{k+n}C′=ck+1​ck+2​⋯ck+n​的哈希值与另一匹配串S=s1s2⋯snS=s_1s_2 \\cdots s_nS=s1​s2​⋯sn​的哈希值是否相等。\nH(C′)=H(C,k+n)−H(C,k)×bnH(C')=H(C,k+n)-H(C,k) \\times b^n\nH(C′)=H(C,k+n)−H(C,k)×bn\n容易证明，上面的柿子是正确的，所以大家牢记即可。\n于是只需要预求得bnb^nbn，就能在O(1)O(1)O(1)时间内得到任意字符串的子串哈希值，从而完成字符串匹配。于是乎，字符串匹配问题的算法时间复杂度就为O(n+m)O(n+m)O(n+m)。\n举个栗子：\n字符串C=ACDAC=\\texttt{ACDA}C=ACDA，S=CDS=\\texttt{CD}S=CD，k=1k=1k=1，n=2n=2n=2。\nH(C′)=H(C,1+2)−H(C,1)×b2=(1×b2+3×b+4)−(1×b2)=3×b+4H(S)=3×b+4\\begin{align}\nH(C')&amp;=H(C,1+2)-H(C,1) \\times b^2\\\\\n\t &amp;=(1 \\times b^2+3 \\times b+4)-(1 \\times b^2)\\\\\n\t &amp;=3 \\times b+4\\\\\nH(S)&amp;=3 \\times b+4\n\\end{align}\nH(C′)H(S)​=H(C,1+2)−H(C,1)×b2=(1×b2+3×b+4)−(1×b2)=3×b+4=3×b+4​​\n正确性\n出现不同字符串哈希值相等的概率越低越好。\n所以有以下两种方法：\n\n\n自然溢出法\n利用unsigned long long无符号整数计算哈希值，相当于对哈希值 mod 264\\bmod 2^{64}mod264。\n\n\n双模法\n顾名思义，就是搞一个二元数组存储哈希值， mod \\bmodmod两个数，两个数都相同哈希值才相同。\n\n\n在速度上单模法会被自然溢出法虐，在正确率上单模法不如双模法和自然溢出法（毕竟自然溢出法的重复概率是1264\\dfrac{1}{2^{64}}2641​），~~所以它是废物，~~所以不介绍单模法了QwQ。\n实现\n练手板子题\n友情赠送板子题代码（自然溢出法）：\n#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;//POJ不支持万能头QAQusing namespace std;typedef unsigned long long ull;const int maxn=1e6+5,maxm=1e4+5;ull power[maxn],hash[maxn];char s1[maxm],s2[maxn];int b=520;int main(){    power[0]=1;    for(int i=1;i&lt;1e6;i++)        power[i]=power[i-1]*b;    int t;    cin&gt;&gt;t;    while(t--)    {        scanf(\"%s%s\",s1+1,s2+1);        int n=strlen(s1+1),m=strlen(s2+1);        hash[0]=0;        for(int i=1;i&lt;=m;++i)            hash[i]=hash[i-1]*b+(ull)(s2[i]-'A'+1);        ull s=0;        for(int i=1;i&lt;=n;i++)            s=s*b+(ull)(s1[i]-'A'+1);        int ans=0;        for(int i=0;i&lt;=m-n;i++)            if(s==hash[i+n]-hash[i]*power[n]) ++ans;        cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}\n完结撒花！\n","categories":["OI"],"tags":["笔记","字符串","Hash"]},{"title":"图的存储学习笔记","url":"/articles/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"开幕雷击\n\n\n\n二维数组邻接矩阵存储\n定义int g[105][105]。\ng(i,j)g(i,j)g(i,j)的值，表示从点iii到点jjj的边的权值，定义如下：\n\n\n当viv_ivi​与vjv_jvj​之间有边或弧时，取值为111（不带权）或权值。\n\n\n当viv_ivi​与vjv_jvj​之间无边或弧时，取值为000（不带权）或∞\\infty∞。\n\n\n举个例子：\n\n\n图(A)\ng(A)=[0111101111001100]\\begin{aligned}\n&amp;g(A)=\\begin{bmatrix} 0&amp;1&amp;1&amp;1\\\\1&amp;0&amp;1&amp;1\\\\1&amp;1&amp;0&amp;0\\\\1&amp;1&amp;0&amp;0 \\end{bmatrix} &amp;\n\\end{aligned}\n​g(A)=​0111​1011​1100​1100​​​​\n\n\n图(B)\ng(B)=[011001010]\\begin{aligned}\n&amp;g(B)=\\begin{bmatrix} 0&amp;1&amp;1\\\\0&amp;0&amp;1\\\\0&amp;1&amp;0 \\end{bmatrix}\n\\end{aligned}\n​g(B)=​000​101​110​​​\n\n\n图©\ng(C)=[∞583∞5∞2∞6∞∞10∞1136411∞]\\begin{aligned}\n&amp;g(C)=\\begin{bmatrix} \\infty&amp;5&amp;8&amp;3&amp;\\infty \\\\ 5&amp;\\infty&amp;2&amp;\\infty&amp;6 \\\\ \\infty&amp;\\infty&amp;10&amp;\\infty&amp;11 \\\\3&amp;6&amp;4&amp;11&amp;\\infty \\end{bmatrix}\n\\end{aligned}\n​g(C)=​∞5∞3​5∞∞6​82104​3∞∞11​∞611∞​​​\n\n\n代码如下：\n#include &lt;bits/stdc++.h&gt;using namespace std;int i,j,k,e,n;double g[105][105];double w;int main(){    cin&gt;&gt;n;\tmemset(g,127,sizeof(g));    cin&gt;&gt;e;    for(k=1;k&lt;=e;k++)    {        cin&gt;&gt;i&gt;&gt;j&gt;&gt;w;        g[i][j]=w;        g[j][i]=w;//有向图省略    }    return 0;}\n数组模拟邻接表存储\n前置芝士\n\n\n出边：以这个结点为起点的边。\n\n\n入边：以这个结点为终点的边。\n\n\n图的邻接表存储法，又叫链式存储法。\n\n\n可以采用数组模拟链表。\n\n\n适合于稀疏图。\n\n\n​\t对于一个有nnn个点mmm条边的图，在使用\n代码如下：\n#include &lt;bits/stdc++.h&gt;using namespace std;//寄了，建不明白了，我不适合图论，然鹅今年CSP-S三道图论题，寄\n","categories":["OI"],"tags":["笔记","图论"]},{"title":"廿四的雪(1)","url":"/articles/%E5%BB%BF%E5%9B%9B%E7%9A%84%E9%9B%AA(1)/","content":"\n","categories":["随笔"],"tags":["廿四的雪"]},{"title":"快速幂学习笔记","url":"/articles/%E5%BF%AB%E9%80%9F%E5%B9%82%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"引入\n\n求(ab) mod n(a^b) \\bmod n(ab)modn。\n\n快速幂\n对于aba^bab\n\n\n若bbb是偶数，则ab=ab2×ab2a^b=a^{\\frac{b}{2}} \\times a^{\\frac{b}{2}}ab=a2b​×a2b​；\n\n\n若bbb是奇数，则ab=a⌊b2⌋×a⌊b2⌋×aa^b=a^{\\lfloor \\frac{b}{2} \\rfloor} \\times a^{\\lfloor \\frac{b}{2} \\rfloor} \\times aab=a⌊2b​⌋×a⌊2b​⌋×a。\n\n\n继续将b2\\dfrac{b}{2}2b​分解成b4\\dfrac{b}{4}4b​、b8\\dfrac{b}{8}8b​……log⁡b\\log blogb次后，bbb就会变成111。我们称这种快速计算幂运算的方法为快速幂算法。\n代码如下：\n\n\n递归版\nint quickpow(int a,int b,int n){    if(b==1) turn a;    if(b%2==0)    {        int t=quickpow(a,b/2,n);        turn t*t%n;    }    else    {        int t=quickpow(a,b/2,n);        t=t*t%n;        t=t*a%n;        turn t;    }}\n\n\n非递归版\nint quickpow(int a,int b,int n){    int t=1;    while(b)    {        if(b%2==1) t=t*a%n;        a=a*a%n;        b=b/2;    }    return t;}\n\n\n\n练手板子题\n\n","categories":["OI"],"tags":["笔记","数学"]},{"title":"我的2022","url":"/articles/%E6%88%91%E7%9A%842022/","content":"中考前篇\n九上期末\n要写我的202220222022，其实要从202120212021年的年末开始。\n话说那是一次西安交大少年班的考试，我十分愚蠢地报了名，其实这也没啥；但是，在校内人选的选拔中，由于是按照八年级下的期末考试成绩排名的（注意当时我们已经初三了诶！但是还是初二的成绩），再加上我们居然要和大佬云集的理工本部一起比成绩，期末考试拉胯的我自然是以一名之差成功落选，其实这也没啥嗷（其实有啥，毕竟可以去西安交大玩儿诶0v0谁不想呢）；但是，居然被隔壁班的某哥们儿暗戳戳的嘲讽了QAQ，寄😭，结果就因为这次刺激，我成功地发奋学习了一个月（具体就是每天学到121212点，然后记忆特别深的是当时我把理化的错题都手敲了一遍打印出来，加起来能有五六十页纸（由此可见我的蒻，错的题都快赶上对的了呜呜呜），导致那个学期我的物理化学笔记本超级厚），然后期末考试还是寄了吧，据说算政史是111111名，不算政史可能是年级前101010了（注意看今年我们一共只有101010个242424的还有一个学习很牛的特长生），所以说我肯定是和242424无缘了嗷。\n寒假\n然后我的寒假就开始了。这个寒假也是一个难忘的寒假。主要内容包括：爆看冬奥会每场有中国的比赛+爆抄101010本练习册答案，注意看，这时候的我还在抄中考复习练习册的答案，这么看我开学考试肯定是要寄了，事实的确如此。不过看冬奥会其实不是没有一点用处，我中考语文议论文撞大运考686868可能也是跟看冬奥会有关ψ(｀∇´)ψ。\n\n插入一段，说到这儿不多不少我中考之后的私信还被徐梦桃回复了诶0v0：\n\n（具体内容就是感谢桃姐的论据让我在议论文上嘎嘎乱杀)\n\n书接上文，讲到了我在中考前最后一个假期的离谱经历，当时其实没有想那么多，貌似是觉得时间还很充裕（?）或者感觉自己稳了（?也不知道是稳上啥，可能是三甲吧QwQ），现在发现自己真是心大。\n备考\n假期很快就结束乐，但是貌似开学不久就又回归线上了，然鹅本心大人居然都没拿几本书回家（虽然当时离中考已经只有100100100天啦啦啦啦），然后好像百日誓师就是线上开的，再然后666666天也是线上开的，上了一个多月网课之后初三就开学了。关于网课的听课效果我觉得还行吧，毕竟我是那种再上课时候喜欢疯狂发言~~（当然现在越发腼腆）~~的性格（笑），回归线下乐！\n然鹅，回归线下之后直接就来了一场双基，没记错的话~~（肯定不会记错）~~是年级202020名，这个成绩差不多是888中水平吧，当时可能有一点心理波动（因为我的心理定位是121212名左右，上个育明也不错😉），但是想想初中三年，从一开始被很多人看好，到后来逐渐成为了年级笑话（浅浅提一下我的黑历史，包括但不仅限于把老师气得上不了课，被班主任赶回家，撤凳子发蹲一个上午……），可能那些曾经看好我的老师都认为我是个华而不实的弱鸡吧，想想其实也挺不甘的，但是没办法，初中三年教会我最重要的就是：拿实力说话，没有实力，没人会把你当根葱；你要是够强，你怎么样都是好的。\n双基之后，度过了一段平淡的时光，现在想想备考的日子其实很美好，那种紧张中带着一丝放松，焦虑中带着一丝释然，真的好好。这期间发生的一件最重要的事就是：我已经全面放弃记叙文了~~（因为我的记叙文分数上限就是56呜呜呜）~~，感谢这次选择，要不就不会有我那中考杀疯了的语文分数和我出人意料的结果。\n紧接着就是一模了（突然发现202220222022的前半段全部都是围绕着中考的(✿◡‿◡)），算是我的一个辉煌时刻吧，虽然只是年级111111，但是谁能想到我是在数学动点暴扣999分再搭配上班级倒数的语文成绩下达到的呢。写到这儿我突然想起来前文那个隔壁班的哥们儿，他在上述的所有考试其实是初二以来的所有考试都在薄纱我（悲，不过马上就要上演逆转大戏了~~，当然上了高中我又被他薄纱了~~）。这里还要提到一位我的发小，之前我和她的成绩算是同病相怜，结果到了双基我已经是被单方面薄纱了。写到这儿发现自己又菜又没用，呜呜呜，可能我的水平就是育明了（悲）。发现现实好残酷，小学的时候人人都觉得上242424是小菜一碟~~（甚至初一初二我都觉得还有机会），后来逐渐被现实击垮了。不甘心，但是实力不行。话说期末考试之后我们晚课分出来一个小班（这是可以说的吗），在这个小班里我当然是被疯狂薄纱，还记得前面说的隔壁班哥们儿吗（他现在居然还在我隔壁班），他555分钟一道252525题，我505050分钟都切不了，作出的正解辅助线都能被我给写挂，寄。记得当时我们有数学晚课前111个小时都是小~~考试，一道252525一道262626，做完了才能去吃饭啊啊啊啊，结果每次我都是最后一个做完的（数学老师还是我们班主任结果我每天被疯狂鄙视呜呜呜），我天我的数学水平居然被一个现在要选文的女生嘎嘎乱杀这岂是我能忍的，但是我真的不会呜呜呜感觉自己好没用呜呜呜他们454545分钟就能全切我却一直卡着呜呜呜，262626题暴力解法也能写挂呜呜呜，所以每天数学晚课就成了我的减肥日，根本吃不上饭呜呜呜，好不容易食堂整点儿人吃的东西啥也抢不上呜呜呜；物理晚课多选题训练，我直接一看到托里拆利实验装置就傻眼一遇到浮力压强就懵逼但是其他人全都哐哐列式只有我哐哐懵逼哐哐瞎搞，寄；英语晚课写作文，别人：高中四六级雅思托福词汇，我：乱套句式+疯狂套路+小学词汇。寄。\n紧接着就是二模了，突然发现自己真是鱼，居然连中考前的事儿都已经忘了呜呜呜，我现在连圆周运动公式都记不住呜呜呜，我好没用呜呜呜，不过二模好像也挺平常的，但是遗憾也肯定有，比如没有成功AK一张数学卷（初中数学从未拿过150150150星人）（但是二模数学是真的简单），比如语文作文开头爆改200200200字不知道的还以为我已经成一代绝世文豪了写作文怎么飘逸，一看分数成功挂大分稳稳拿下545454，这一次的排名是141414，因为这次考试的难度所以有很多后起之秀来到了那个小班，但毕竟是后起之秀所以我本以为自己能在数学和物理上找回自信但没想到我居然被曾经年级505050名开外的选手乱杀呜呜呜我好没用。\n二模之后就是最激动人心的环节——报考！！！当然我没有丝毫犹豫因为太菜报了指标育明、统招242424+育明、统调是啥我忘了，反正就是纯托底选择，普高本来说是文谷，结果文谷不能保证我不去渤海，所以报考结束的几小时前临时改成了333中~~（很长一段时间里我认为这里才是我的归宿）~~。话说这其中也想过报242424冲一下，毕竟很多一模年级前十二模都掉出前二十了还报了242424，所以在那张愚蠢的腾讯文档表格里有一段时间我是在242424那一栏的，然鹅后来我被嘲了，也被别的家长嘲了，所以后来只能改成育明，注意看此时此刻以我的成绩在报育明的人里是绝对是数一数二，然鹅马上转折就来了。\n报考结束之后感觉大多数人好像都觉得自己报的啥就能考上啥~~（说白了就是飘了），但是我不敢啊，因为就在去年我认识的一个学习超好的小哥哥就是因为中考前觉得自己稳了结果最后111分之差从242424直接掉到121212中了，所以我必须以此为鉴！！！所以中考前的一两周当别人都在play的时候只有我在默默地胡乱study（其实还是实力不行，怕自己中考挂了）~~，然后中考前还请了几次短假自己在家整理了一些知识，好像就是这样。\n然后就是中考啦啦啦啦啦！中考前一天还真是有点儿小感动（毕竟是朝夕相处了333年呢），老师、同学……可能中考之后就很难再见面了。当时可能大多数人都觉得我稳了吧（但是马上就要到转折点了0v0），记得当时团员要交111块钱团费，我去送的时候收团费的老师还跟我说了一声加油，挺感动的。这所学校，真的就要和我分开了，还是有一些不舍的呜呜呜，其实自己挺容易被感动的。（多愁善感的基因）\n中考篇\n（其实这一段在之前貌似写过）\nDay 1\n语文\n具体可以看我前面的朋友圈内容乐，当时记忆比较深的就是别人都在大太阳底下站着唠嗑等待入场，然后我因为没找到同学一个人跑到那个木亭子下面看我蒟蒻的笔记，然后进了考场答题，嗯，挺顺的，作文和大阅读可能卡了一下，但也还好吧。\n估分：(125,130)(125,130)(125,130)，运气好的话130130130+\n理化\n同样挺顺的，物理它没出浮力和压强啦啦啦啦啦！当时出考场听到有人说难（?）有人说简单，我觉得简单的有点儿让人不敢相信。（真的，非凡尔赛）\n估分：(84,88)(84,88)(84,88)+(64,67)(64,67)(64,67)=(148,155)(148,155)(148,155)\nDay 2\n数学\n寄了。前面答得还挺顺手，161616题折纸题不会果断放弃（直到最后我都不会正解，直接拿刻度尺+量角器瞎搞算的破数居然对了），到了242424题看了看旁边的哥们儿，嗯，比我慢一点儿，还行，现在距离考试结束还有一个多小时，然鹅谁会想到我在接下来的一个多小时里颗粒无收😭。\n先开252525，(1)(1)(1)送分；(2)(2)(2)开始瞎搞结果发现自己假证了，寄；想开(3)(3)(3)，又不会。忙活了一会儿，胡写几个相似三角形证明，(2)(2)(2)写了一波假证上去，跑了。毕竟252525题切不掉我已经习惯了呜呜呜。瞎搞操作熟练的让人心疼。\n再开262626，(1)(1)(1)送分；(2)(2)(2)好像是一道很水的计算题，切了；(3)(3)(3)看起来很简单，一上手做直接被我的暴力解法搞成了444次方程，不会解，扔那儿，摆了。\n在考场上估了个分，(130,140)(130,140)(130,140)吧，不过当时我还天真的以为这次数学超级难，大家都不会，嗯，还行。\n看了看旁边的哥们儿，呦呵，他252525题好像切了，难不成这题其实很简单？\n接下来一直到考试结束的半小时里，我就开始在252525、262626之间反复横跳，期间还水掉了161616题，但是其他的没有一点进展啊啊啊啊啊啊啊啊。\n还有555分钟，看了看旁边的哥们儿，呦呵，他262626题好像也切了，难不成这题其实很简单？\n难道他是绝世高手？还是我寄了？\n出考场，听到有人说数学简单，比一模简单（?），一模我252525可是切了啊，满脑问号.jpg。算了，不管了。\n估分：(130,140)(130,140)(130,140)\n英语\n很顺手，考试结束前还检查出来一个价值222分的愚蠢错误。\n估分：(130,135)(130,135)(130,135)\n崩溃\n考完英语，听到了一堆人说数学简单，252525、262626都切了，连之前数学难优秀的几个女同学居然都全切了在考场外面拉着数学老师的手活蹦乱跳，只有我据说手脚冰凉。\n回家就崩溃了，应该是寄了。数学就得和别人差101010+。完了，天要亡我。\nDay 3\n政史\n凑数用。唯一记得的就是那天下雨了，结果我下车的时候校长就在马路对面，给我喊了个加油，可是我已经寄了诶╯︿╰。感觉自己会成为下一届的标准反面教材，最有希望却摔得最惨。\n估分：必过\n中考后篇\n中考后玩了几天吧，还拍了毕业照，同学老师问我考得怎么样，我只能说寄了，说自己数学的惨，结果他们都不信（?），崩了，真的感觉完了。\n7.14\n出分日。\n本来说444点出分，后来改成了222点，本来想先睡一觉，结果一直睡不着。\n实际：140.5+156(89+67)+141.5+134.5+95=668.5140.5+156(89+67)+141.5+134.5+95=668.5140.5+156(89+67)+141.5+134.5+95=668.5\n乐了！！！数学瞎搞居然给了我这么多过程分！！！两道题加在一起只扣888分诶！！！\n和同学比了一下，出乎意料的高，年级第333，我天，历史最佳成绩了。\n还记得那个隔壁班的哥们儿吗，时隔两年，我终于有一次战胜了他。\n一堆老师来问我分（甚至还有前面那位收团费的老师），结果全惊了，毕竟在这之前连我自己都觉得我寄了，已经做好去333中报道的准备了。\n泪目了。不负我。\n7.20\n出录取结果日。\n其实还在纠结这个分够不够242424的统招，我觉得挺稳的，果然，高111分踩统招线入学。虽然没进羟基班但已经是意外之喜了。毕竟我是蒟蒻爆发户。有效防止了我在羟基班被人薄纱\n开始了自己在廿四被薄纱的日子\n新生活篇\n\n\n学了OI（但是我好菜呜呜呜希望假期结束能有所长进吧呜呜呜）\n\n\n当了一种很新的班委——纪律委员。这个职务可能别的班都没有吧。主要是由于111111班的特殊性。说到我是怎么当上的，其实挺奇妙的~~（毕竟曾经的我可是开班会被点名批评的不安定分子）~~。话说期中考试结束后的一天，老师叫鸡哥出去，然后我蚌埠住了乐了一下，然后老师就叫我也出去。然后老师表扬了鸡哥，然后问我能不能管理班级纪律，然后鸡哥蚌埠住了乐了一下，然后我就乐了，然后我就说能，然后就没有然后了。\n真心希望有一天111111班不需要纪律委员来管纪律，大家都能自己管好自己的纪律啊（相信会的OwO）\n\n\n认识了很多新同学\n\n\n学到了很多东西~~（比如自己真的很菜）~~\n\n\n考了一次期中考试，寄了\n\n\n期中考试之后努力学习了，不知道期末考试怎么样\n\n\n被薄纱\n\n\n得了一次新冠，已经好乐\n\n\n终章\n这篇年终总结算是结束了，现在想想我的202220222022真是跌宕起伏又精彩纷呈呢。\n202220222022年结束了，我很怀念它。\n202320232023年，对我好一点啊QwQ。\n\n愿一切美好，都能如愿以偿。\n\n","categories":["随笔"],"tags":["回忆","我的20××"]},{"title":"排序方式笔记","url":"/articles/%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F%E7%AC%94%E8%AE%B0/","content":"最好情况下\n\n\n冒泡排序\n\n图解：\n\n\n\n\n插入排序\n\n图解：\n\n\n\n\n平均情况下\n\n\n快速排序\n\n图解：\n\n\n\n\n最坏情况下\n\n\n堆排序 （等学会之后再填坑）\n\n\n归并排序\n\n图解：\n\n\n\n\n","categories":["OI"],"tags":["笔记","算法","排序"]},{"title":"整数快读模板","url":"/articles/%E6%95%B4%E6%95%B0%E5%BF%AB%E8%AF%BB%E6%A8%A1%E6%9D%BF/","content":"inline int read(){\tint x=0,f=1;\tchar ch=getchar();\twhile(ch&gt;'9'||ch&lt;'0'){if(ch=='-') f=-1;ch=getchar();}\twhile(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}\treturn x*f;}\n","categories":["OI"],"tags":["模板"]},{"title":"欧拉回路学习笔记","url":"/articles/%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":""},{"title":"DFS剪枝学习笔记","url":"/articles/%E6%B7%B1%E6%90%9C%E5%89%AA%E6%9E%9D%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"前置芝士\n搜索的进程可以看作是从树根出发，遍历一棵倒置的树——搜索树的过程。\n剪枝，顾名思义，就是通过某种判断，避免一些不必要的遍历过程。\n剪枝的原则\n正确性\n保证不丢失正确的结果\n准确性\n尽可能多地剪去不能通向正解的枝条。\n高效性\n剪枝的技巧\n优化搜索顺序\n排除等效冗余\n在搜索过程中，如果能够判定从搜索树的的当前节点上沿着某几条不同分支到达的子树是等效的，那么只需要对其中的一条分值进行搜索。\n可行性剪枝\n在搜索过程中，及时对当前状态进行检查，如果发现分支已经无法到达递归边界，就执行回溯。\n某些题目条件的范围限制是一个区间，此时可行性剪枝也被称为“上下界剪枝”。\n最优性剪枝\n在最优化问题的搜索过程中，如果当前花费的代价已经超过当前搜到的最优解，此时可以停止对当前分支的搜索，执行回溯。\n记忆化\n记录每个状态的搜索结果，在重复遍历一个状态时直接检索并返回。\n类似于对图进行深搜时，标记一个节点是否已经被访问过。\n\n练手板子题\n提示：最优性剪枝、可行性剪枝\n\n","categories":["OI"],"tags":["笔记","DFS","剪枝"]},{"title":"线段树学习笔记","url":"/articles/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"\n事情的起因来自于202320232023年的元旦，一位蒟蒻百无聊赖中误入了大佬们的团队作业，好奇心满满地点开了第一道题，看着一行半的题干信心满满地准备大干一场，调了303030分钟写出一个分治+DP的思路，直接忽略时间复杂度是O(n2×k)O(n^2 \\times k)O(n2×k)的事实，结果UKE了无数次后上CF一测发现第一个点就TLE了😭。然后发现这道题要用线段树优化，痛定思痛从000开始学线段树。\n啊啊啊明天的团队作业已经出了我要切了它啊啊啊！\n\n基础\n线段树是一种基于分治思想的二叉树结构，用于在区间上进行信息统计。\n性质\n\n\n线段树的每一个节点都代表一个区间。\n\n\n线段树具有唯一的根节点，代表的区间是整个统计范围。\n\n\n线段树的每个叶节点都代表一个长度为111的元区间[x,x][x,x][x,x]。\n\n\n对于每个内部节点[l,r][l,r][l,r]，它的左子节点是[l,mid][l,mid][l,mid]，右子节点是[mid+1,r][mid+1,r][mid+1,r]，其中mid=⌊l+r2⌋mid=\\lfloor \\dfrac{l+r}{2} \\rfloormid=⌊2l+r​⌋。\n\n\n\n除去树的最后一层，整棵线段树一定是一棵完全二叉树，树的深度为O(log⁡N)O(\\log N)O(logN)。\n编号\n\n\n“父子222倍”节点编号\n\n根节点编号为111。\n编号为xxx的节点的左子节点编号为x×2x \\times 2x×2，右子节点编号为x×2+1x \\times 2+1x×2+1。\n\n\n\n保存线段树的数组长度要不小于4N4N4N。\n建树\n给定一个长度为NNN的序列。sum(l,r)=max⁡l≤i≤rA[i]\\text{sum}(l,r)=\\max _{l \\leq i \\leq r}{A[i]}sum(l,r)=maxl≤i≤r​A[i]。\nstruct SegmentTree{    int l,r;    int sum;    int lazy;    //lazy懒标记，下面有讲QwQ}t[size*4];void build(int k,int l,int r){    t[k].l=l,t[k].r=r;    if(l==r){t[k].sum=a[l];return;}    int mid=(l+r)/2;    build(k*2,l,mid);    build(k*2+1,mid+1,r);    t[k].sum=max(t[k].sum,t[k*2+1].sum);}build(1,1,n);\n单点查询+修改\n从根节点出发，递归找到代表区间[x,x][x,x][x,x]的叶节点，然后从下往上更新[x,x][x,x][x,x]以及它的所有祖先节点上保存的信息。时间复杂度为O(log⁡N)O(\\log N)O(logN)。\n//change A[x] to vvoid change(int k,int x,int v){    if(t[k].l==t[k].r){t[k].sum=v;return;}    int mid=(t[k].l+t[k].r)/2;    if(x&lt;=mid) change(k*2,x,v);    else change(k*2+1,x,v);    t[k].sum=max(t[2*k].sum,t[2*k+1].sum);}change(1,x,v);\n区间查询\n查询序列AAA在区间[l,r][l,r][l,r]上的最大值。\n从根节点开始，递归执行以下过程。\n\n\n若[l,r][l,r][l,r]完全覆盖了当前节点代表的区间，则立即回溯，并且该节点的sum\\text{sum}sum值为候选答案。\n\n\n若左子节点与[l,r][l,r][l,r]有重叠部分，则递归访问左子节点。\n\n\n若右子节点与[l,r][l,r][l,r]有重叠部分，则递归访问右子节点。\n\n\nint ask(int k,int l,int r){    if(l&lt;=t[k].l&amp;&amp;r&gt;=t[k].r) return t[k].sum;    int mid=(t[k].l+t[k].r)/2;    int val=-(1&lt;&lt;30);    if(l&lt;=mid) val=max(val,ask(k*2,l,r));    if(l&gt;mid) val=max(val,ask(k*2+1,l,r));    return val;}cout&lt;&lt;ask(1,l,r)&lt;&lt;endl;\n该查询过程会把询问区间[l,r][l,r][l,r]先线段树上分成O(log⁡N)O(\\log N)O(logN)个节点，取它们的最大值作为答案。\n区间修改\n前置芝士\n延迟标记，可能就是懒标记。\n顾名思义，延迟标记就是更新到某一子区间时直接打上标记，延迟对它的子节点的更新操作。但是大家都叫它懒标记，所以下面我们叫它懒标记。\n\n\n当lazy[i]!=0时，表示iii更新过了而iii的子节点还没有更新。\n\n\n其实可以这么理解嗷。以下图为例：\n\n如果我们要修改区间[2,8][2,8][2,8]上的值，令其都+5+5+5，那么可以更新区间[2,2][2,2][2,2]、[3,3][3,3][3,3]、[4,5][4,5][4,5]、[6,8][6,8][6,8]，每找到一个这样的真包含区间就加上一个懒标记。我们观察到，[4,5][4,5][4,5]、[6,8][6,8][6,8]的子节点的值没有更新诶，但是没关系，当我们遍历到这个有懒标记的节点时，如果有懒标记，那就可以把它的子节点给更新并且打上懒标记，再把这个懒标记给置000。以此类推。\n\n\n懒标记要和修改相同，比如要+5+5+5，懒标记就是555。\n\n\n如果要进行乘法操作，和上面的一样，×5\\times 5×5懒标记就是5。\n\n\n实操\n\n乐了，已经崩溃了，自己迷迷糊糊的，不知道能不能写明白。代码就不放出来吓唬人了。\n为了不误人子弟我就先咕了，等大彻大悟之后一定回来填坑！！！\n给自己找点儿信心：STO ncwzdlsd Orz\n\n但是，善良的蒟蒻为了防止大家抄题解欣赏别人的代码思路的时候看不懂，还是介绍一下add、pushup、pushdown、change、query操作吧QwQ。呵呵真是一个口是心非的男人\n注：下文的kkk均代表当前节点。\n\n\nadd：给一个节点进行更新并且打上懒标记。\n代码如下：\nvoid add(int k,int l,int r,int val){    tree[k].sum+=(r-l+1)*val;    tree[k].lazy+=val;}\n\n\npushup：把修改上推，即更新父节点的sum\\text{sum}sum值。\n代码如下：\nvoid pushup(int k){    //之前用的SegmentTree，现在不拽了，老老实实用tree    tree[k].sum=tree[k*2].sum+tree[k*2+1].sum;}\n解释：\n\n\n父节点的sum\\text{sum}sum等于子节点的元素和。\n\n\n\n\npushdown：把修改下推，即更新子节点的sum\\text{sum}sum值。\n代码如下：\nvoid pushdown(int k,int l,int r){    int mid=(l+r)/2;    add(k*2,l,mid,tree[k].lazy);//左子节点    add(k*2+1,mid+1,r,tree[k].lazy);//右子节点    lazy[k]=0;}\n\n\nchange：修改操作。把[l,r][l,r][l,r]全部+val\n代码如下：\nvoid change(int k,int l,int r,int val){    if(l&lt;=tree[k].l&amp;&amp;tree[k].r&lt;=r)//真包含    {        tree[k].sum+=(tree[k].r-tree[k].l+1)*val;        tree[k].lazy+=val;        return;    }    pushdown(k,tree[k].l,tree[k].r);    int mid=(tree[k].l+tree[k].r)/2;    if(l&lt;=mid)        change(k*2,l,r,val);//左子树与更新区间有交集    if(r&gt;mid)        change(k*2+1,l,r,val);    pushup(k);}\n\n\nquery：查询区间和。\n代码如下：\nint query(int k,int l,int r){    if(l&lt;=tree[k].l&amp;&amp;tree[k].r&lt;=r)//当前区间真包含于查询区间        return tree[k].sum;    pushdown(k,tree[k].l,tree[k].r);    int res=0;    int mid=(tree[k].l+tree[k].r)/2;    if(l&lt;=mid)        res+=query(k*2,l,r);    if(r&gt;mid)        res+=(k*2+1,l,r);    return res;}\n\n\n动态开点与线段树合并\n\n\n不会，正在学习……咕咕咕咕咕\n\n\n可能没完结完结撒花！！！\n线段树，学了一整天~~，感觉自己还是半懵状态，不过慢慢来应该会懂的~~。\n不行了，我高低得拜一下自己。\nSTO ncwzdlsd\n\n练手板子题\n\n我天这道板子题我居然写不明白了回炉重造吧呜呜呜\n大家还是不要像我一样用结构体了还是改回数组吧\n","categories":["OI"],"tags":["数据结构","笔记","线段树"]},{"title":"背包问题详解（01背包，完全背包与多重背包）","url":"/articles/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%8801%E8%83%8C%E5%8C%85%EF%BC%8C%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E4%B8%8E%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%EF%BC%89/","content":"\n前段时间学背包问题的时候发现的一篇学长的宝藏博客QwQ，写得真的好\n\n背包问题\n01背包\n问题简述：有m个物品待放入一个容量为V的背包，每件物品都有其对应的体积w与价值v，从中选取一些物品放入背包，使得物品总价值最大。\n算法思路：考虑动态规划，令f(i,j)为只考虑前i件物品，背包容量为j时能得到的最大价值。那么当只考虑第i件物品放不放时，便有以下两种情况：\n1，第i件物品体积大于当前背包容量，不放：f(i,j)=f(i-1,j)；\n2，第i件物品体积小于等于当前背包容量，则考虑放与不放哪个更优：\nf(i,j)=max(f(i-1,j),f(i-1,j-w[i])+v[i])\n那么就得到核心代码：\nfor(int i=1;i&lt;=m;i++)    for(int j=1;j&lt;=V;j++)    {       if(j=w[i])            f[i][j]=max(f[i-1][j],f[i-1][j-w[i]]+v[i]);       else            f[i][j]=f[i-1][j];    }\n观察状态转移方程式，我们发现，对第i件物品的选择只与对前一件物品的选择有关，于是考虑滚动数组优化空间。\n注意：当使用滚动数组时，第二层循环应由V到w[i]。这是因为在状态转移时用到的背包容量均小于等于j，倒着循环可以保证j前面都是只考虑i-1件物品时的数据，而j后面是更新过的前i件物品的数据，这样顺带保证了当j&lt;w[i]，f(i,j)=f(i-1,j)。\nfor(int i=1;i&lt;=m;i++)\tfor(int j=V;j&gt;=w[i];j--)   \t\tf[j]=max(f[j],f[j-w[i]]+v[i]);\n练手板子题：传送门\n完全背包\n问题简述：有m种物品待放入一个容量为V的背包，每种物品都有无穷多件且有其对应的体积w与价值v，从中选取一些物品放入背包，使得物品总价值最大。\n算法思路：在01背包的基础上，由于每种物品都能被重复选择，考虑从1开始枚举每件物品被选择的次数k直到当前物品所占体积超过容量j，则有：f(i,j)=max(f(i,j),f(i,j-k*w[i])+k*v[i])。由于在每次循环中讨论的都是第i件物品的选择次数，故数组第一维为i，这也决定了在每次对j进行枚举后要将f(i,j)初始化：f(i,j)=f(i-1,j)。\n上核心代码：\nfor(int i=1;i&lt;=m;i++)\tfor(int j=1;j&lt;=V;j++)\t{        f[i][j]=f[i-1][j];        for(int k=1;k*w[i]&lt;=j;k++)                f[i][j]=max(f[i][j],f[i][j-k*w[i]]+k*v[i]);\t}\n观察状态转移方程式，参照01背包的思想再次考虑滚动数组优化：\n不难发现，完全背包的第二层循环是无需倒着枚举的。如上文所说，在每次对k进行枚举时讨论的都是对第i件物品的选择，故j前面的数据应为只考虑前i件物品时的数据，所以应正着循环。\n再考虑对k的枚举。每次循环都是在前一次循环的基础上多选择一件物品i放入背包，所以可以考虑变乘为加：f(j)=max(f(j),f(j-w[i])+v[i])，进一步优化时间。\nfor(int i=1;i&lt;=m;i++)\tfor(int j=w[i];j&lt;=V;j++)\t\tf[j]=max(f[j],f[j-w[i]]+v[i]);\n日常板子题时刻：传送门\n（不开longlong见祖宗哦\n多重背包\n问题简述：有n种物品待放入一个容量为V的背包，每种物品都有其对应的数量m，体积w与价值v，从中选取一些物品放入背包，使得物品总价值最大。\n算法思路：由于不能无限选择，这个问题又变回了01背包，只是加了对k的枚举。当我们熟练掌握前两种背包，想写出来一个多重背包也就不难了。\n核心代码又来了。\nfor(int i=1;i&lt;=n;i++)\tfor(int j=V;j&gt;=w[i];j--)\t\tfor(int k=1;k&lt;=m[i]&amp;&amp;k*w[i]&lt;=j;k++)\t\t\tf[j]=max(f[j],f[j-k*w[i]]+k*v[i]);\n我们发现，由于物品有数量的限制，第三层循环无法删去，那么又如何对时间进行优化呢？\n此时可以考虑使用二进制，由于20+21+……+2k2^0+2^1+……+2^k20+21+……+2k可以表示2k+1−12^{k+1}-12k+1−1之内的所有数，故m件物品一定可以进行二进制拆分成许多堆物品，每堆2n2^n2n件又能看作一件质量为w∗2nw*2^nw∗2n，价值为v∗2nv*2^nv∗2n的物品，使复杂度优化一个logloglog。\n二进制拆分模拟如下：\nint vv,ww,mm,cnt=0;for(int i=1;i&lt;=n;i++){\tvv=read(),ww=read(),mm=read();\tfor(int j=1;j&lt;=mm;j&lt;&lt;=1)\t{\t\tv[++cnt]=vv*j,w[cnt]=ww*j;\t\tmm-=j;\t}\tif(mm) \t\tv[++cnt]=vv*mm,w[cnt]=ww*mm;}\n然后就是朴实无华01背包啦。\n板子：传送门\n（几天前用快读不加二进制优化还能卡过呢qwq\n","categories":["OI"],"tags":["笔记","算法","转载","背包"]},{"title":"组合数学学习笔记","url":"/articles/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"前置芝士\n加法原理\n若完成一件事的方法有nnn类，其中第iii类方法包括mim_imi​种不同的方法，且这些方法互不重合，则完成这件事共有：N=m1+m2+⋯+mnN=m_1+m_2+\\cdots+m_nN=m1​+m2​+⋯+mn​种不同的方法。\n乘法原理（分步计数原理）\n若完成一件事需要nnn个步骤，其中第iii个步骤有mim_imi​种不同的完成方法，且这些步骤互不干扰，则完成这件事共有：N=m1×m2×⋯×mnN=m_1\\times m_2\\times\\cdots\\times m_nN=m1​×m2​×⋯×mn​种不同的方法。\n\n            区别：一个与分类有关，一个与分步有关；加法原理是“分步完成”，乘法原理是“分类完成”。\n          \n排列及其公式\n线排列\n定义\n一般地，从nnn个不同的元素中，取出mmm（m≤nm\\leq nm≤n）个元素按照一定的顺序排成一列，叫做从nnn个不同的元素中取出mmm个元素的一个线排列。\n从nnn个不同的元素中取出mmm（m≤nm\\leq nm≤n）个元素的所有线排列的个数，叫做从nnn个不同元素中取出mmm个元素的排列数，用符号P(n,m)P(n,m)P(n,m)或PnmP_n^mPnm​表示。\n排列数公式\nPnm=n(n−1)(n−2)⋯(n−m+1)=n!(n−m)!P_n^m=n(n-1)(n-2)\\cdots(n-m+1)=\\dfrac{n!}{(n-m)!}\nPnm​=n(n−1)(n−2)⋯(n−m+1)=(n−m)!n!​\n全排列\n把nnn个不同的元素全部取出，按照一定的顺序排成一列，叫做nnn个不同的元素的一个全排列。\n全排列的方案个数叫做nnn个元素的全排列数，用符号PnnP_n^nPnn​表示。\n此时，Pnm=n(n−1)(n−2)×⋯×3×2×1=n!P_n^m=n(n-1)(n-2)\\times\\cdots\\times3\\times2\\times1=n!Pnm​=n(n−1)(n−2)×⋯×3×2×1=n!。\n相异元素可重复排列\n从nnn个不同元素中可以重复地选取出mmm个元素的排列，叫做相异元素可重复排列。\n排列方案数：nmn^mnm。\n不全相异元素的全排列\n圆排列\n从nnn个不同元素中选取出mmm个元素，不分首尾地排成一个圆圈的排列叫做圆排列。\n排列方案数：Pnm=n!m(n−m)!P^m_n=\\dfrac{n!}{m(n-m)!}Pnm​=m(n−m)!n!​；如果m=nm=nm=n，Pnm(n−1)!P_n^m(n-1)!Pnm​(n−1)!\n组合及其公式\n非重组合\n可重组合\n二项式定理\n(a+b)n=∑k=0nCnkan−1bk(a+b)^n=\\sum_{k=0}^nC^k_na^{n-1}b^k\n(a+b)n=k=0∑n​Cnk​an−1bk\n","categories":["OI"],"tags":["数学","组合数学"]},{"title":"贪心——从零基础到入门","url":"/articles/%E8%B4%AA%E5%BF%83%E2%80%94%E2%80%94%E4%BB%8E%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%88%B0%E5%85%A5%E9%97%A8/","content":"简介\n贪心算法是从问题的初始状态出发，通过若干次的贪心选择而得到的最优值（或较优值）。\n贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，至于当前状态有关。\n适用前提是，局部最优策略能导致全局最优策略。\n基本思路\n\n\n描述问题\n\n\n分解问题\n\n\n求解子问题，得到局部最优解\n\n\n合并子问题最优解\n\n\n简单贪心问题\n最优装载问题\nnnn个物体，第iii个物体重量为wiw_iwi​，选择尽量多的物体，使得总重量不超过SSS。\n贪心策略：先装最轻的\n部分背包问题\nnnn个物体，第iii个物体重量为wiw_iwi​，价值为viv_ivi​，选择物体，每一个物体可以只取走一部分，使得总重量不超过SSS且总价值尽量高。\n贪心策略：先选出性价比高的\n乘船问题\nnnn个人，第iii个人重量为wiw_iwi​，每艘船载重量为CCC，最多可乘两人。用最少的船装载所有人。\n贪心策略：最轻的人和最重的人配对\n常见应用\n选择不相交区间问题\n练手板子题\n区间选点问题\n练手板子题\n区间覆盖问题\n练手板子题\n流水作业调度问题\n练手板子题\n带限期和罚款的单位时间任务调度问题\n练手板子题\n","categories":["OI"],"tags":["笔记","贪心"]},{"title":"质数筛选学习笔记","url":"/articles/%E8%B4%A8%E6%95%B0%E7%AD%9B%E9%80%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"Eratosthenes筛选法\n顾名思义就是数学家Eratosthenes发明的筛法，但是它的名字太长了，所以我们简称它为埃氏筛QwQ。\n基本思想\n质数的倍数一定不是质数。\n实现方法\n用一个长度为N+1N+1N+1的数组保存信息，000表示质数，111表示合数。先假设所有的数都是质数（初始化为000），从小到大枚举每一个质数xxx，把xxx的倍速都标记为非质数（置为111）。\n如何枚举质数xxx呢？从小到大扫描到xxx时，若xxx未被标记，则它不能被2∼x−12\\sim x-12∼x−1之间的任何数整除，则xxx为质数。\n举个栗子：\n2,3,4,5,6,7,8,9,10,11,12,⋯2,3,5,7,9,11,⋯2,3,5,7,11,⋯⋯\\begin{align}\n&amp;2,3,4,5,6,7,8,9,10,11,12,\\cdots\\\\\n&amp;2,3,5,7,9,11,\\cdots\\\\\n&amp;2,3,5,7,11,\\cdots\\\\\n&amp;\\cdots\n\\end{align}\n​2,3,4,5,6,7,8,9,10,11,12,⋯2,3,5,7,9,11,⋯2,3,5,7,11,⋯⋯​​\n可以发现，存在重复标记的耗时行为。实际上，小于x2x^2x2的xxx的倍数在扫描更小的数时就已经被标记过了。因此，可以优化一下，对于每个xxx，把大于等于x2x^2x2的xxx的倍数标记为合数即可。\n代码如下：\nvoid primes(int n){    memset(v,0,sizeof(v));    for(int i=2;i&lt;=n;i++)    {        if(v[i]) continue;        cout&lt;&lt;i&lt;&lt;endl;        for(int j=i;j&lt;=n/i;j++) v[i][j]=1;    }}\n算法的时间复杂度为O(nlog⁡log⁡n)O(n\\log\\log n)O(nloglogn)，效率非常接近于线性。时间复杂度的证明非常复杂，本蒟蒻也不太会，所以不证了QwQ\n线性筛法\n即使在优化后，埃氏筛仍然会重复标记合数。举个栗子，121212既会被222标记又会被333标记，其根本原因是算法不能确定唯一的产生121212的方式。\n所以，我们只要保证合数被它的最小质因数筛去就好啦！时间复杂度为O(n)O(n)O(n)。\n代码如下：（添加注释小能手上线）\nint v[maxn],prime[maxn];void primes(int n){    memset(v,0,sizeof(v));//存储最小质因子    int m=0;//质数数量    for(int i=2;i&lt;=n;i++)    {        if(v[i]==0)        {            v[i]=i;            prime[++m]=i;        }        for(int j=1;j&lt;=m;j++)        {            //i有比prime[j]更小的质因子或者超出n的范围            if(prime[j]&gt;v[i]||prime[j]&gt;n/i) break;            v[i*prime[j]]=prime[j];        }    }    for(int i=1;i&lt;=m;i++)        cout&lt;&lt;prime[i]&lt;&lt;endl;}\n","categories":["OI"],"tags":["数学","埃氏筛","线性筛"]},{"title":"费马小定理、欧拉定理学习笔记","url":"/articles/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86%E3%80%81%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"费马小定理\n如果ppp是一个质数，而整数aaa不是ppp的倍数，则有ap−1=1(modp)a^{p-1}=1\\pmod pap−1=1(modp)。\n一般情况：ap=a(modp)a^p=a \\pmod pap=a(modp)\n欧拉定理\n欧拉函数\n对正整数nnn，欧拉函数是小于等于nnn的数中与nnn互质的数的数目。\n引理1\n\n\n如果nnn为某一个素数ppp，则：φ(p)=p−1\\varphi(p)=p-1φ(p)=p−1；\n\n\n如果nnn为某一个素数的ppp的幂次pnp^npn，则：φ(pn)=(p−1)×pn−1\\varphi(p^n)=(p-1) \\times p^{n-1}φ(pn)=(p−1)×pn−1；\n\n\n如果nnn为任意两个互质的数aaa，bbb的积，则：φ(a×b)=φ(a)φ(b)\\varphi(a\\times b)=\\varphi(a)\\varphi(b)φ(a×b)=φ(a)φ(b)。\n\n\n引理2\n设n=p1a1×p2a2×⋅⋅⋅×pkakn=p_1^{a_1}\\times p_2^{a_2}\\times···\\times p_k^{a_k}n=p1a1​​×p2a2​​×⋅⋅⋅×pkak​​为正整数nnn的素数幂乘积表达式，则：φ(n)=n×(1−1p1)×(1−1p2)×⋅⋅⋅×(1−1pk)\\varphi(n)=n\\times(1-\\frac{1}{p_1})\\times(1-\\frac{1}{p_2})\\times···\\times(1-\\frac{1}{p_k})φ(n)=n×(1−p1​1​)×(1−p2​1​)×⋅⋅⋅×(1−pk​1​)。\n欧拉定理\n若aaa与mmm互质，则aφ(m)=1(modm)a^{\\varphi(m)}=1\\pmod maφ(m)=1(modm)。\n","categories":["OI"],"tags":["笔记","数学"]},{"title":"链表学习笔记","url":"/articles/%E9%93%BE%E8%A1%A8%E2%80%94%E2%80%94%E4%BB%8E%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%88%B0%E5%85%A5%E9%97%A8/","content":"链表有很多种。下面列举一些。\n\n\n单链表：每个节点记录自己的后继。\n\n\n双链表：每个结点记录自己的前驱和后继。\n\n\n循环单链表：本身是一个单链表。最后一个节点的后继为第一个界点。\n\n\n循环双链表：本身是一个双链表，连成环形。\n\n\n块状链表：基本思想是将若干元素压缩成一块，将这些块串联起来。\n\n\n跳表：相当于平衡树。每个结点拥有自己的右指针和下指针，通过分层的方式来加速查询，而每个元素的层数由概率决定。\n\n\nP1160：\n利用一个双向链表维护这个队伍，每个同学记录自己左边和右边的同学。这样各种操作都可以O(1)的时间复杂度完成了。使用数组index定位某位同学的节点编号。\n#include &lt;iostream&gt;using namespace std;//注意万能头里有index数组struct node{    int pre,nxt,key;    node(int _key=0,int _pre=0,int _nxt=0)    {        pre=_pre;        nxt=_nxt;        key=_key;    }};node s[100005];int n,m,tot=0;int index[100005];void ins_back(int x,int y){    int now=index[x];    s[++tot]=node(y,now,s[now].nxt);    s[s[now].nxt].pre=tot;    s[now].nxt=tot;    index[y]=tot;}void ins_front(int x,int y){\tint now=index[x];\ts[++tot]=node(y,s[now].pre,now);    s[s[now].pre].nxt=tot;    s[now].pre=tot;    index[y]=tot;}void del(int x){\tint now=index[x];\tint le=s[now].pre,rt=s[now].nxt;\ts[le].nxt=rt;\ts[rt].pre=le;\tindex[x]=0;}int main(){\tindex[0]=0;    int x,k,p,now;    cin&gt;&gt;n;    s[0]=node();//  令0恒为最右边的结点 \tins_back(0,1);\tfor(int i=2;i&lt;=n;i++)\t{\t\tcin&gt;&gt;k&gt;&gt;p;\t\tp?ins_back(k,i):ins_front(k,i);\t}\t\tcin&gt;&gt;m;\tfor(int i=1;i&lt;=m;i++)\t{\t\tcin&gt;&gt;x;\t\tif(index[x])\t\t{\t\t\tdel(x);\t\t}\t}\tnow=s[0].nxt;\twhile(now)\t{\t\tcout&lt;&lt;s[now].key&lt;&lt;' ';\t\tnow=s[now].nxt;\t}\t    return 0;   }\n","categories":["OI"],"tags":["数据结构","笔记","题解"]},{"title":"随机数据生成与对拍","url":"/articles/%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%E4%B8%8E%E5%AF%B9%E6%8B%8D/","content":"\n这是一篇远古博客，之所以要重写是因为当年的我在关键时刻社死不敢找大佬请教~~（或者说大佬不屑搭理本蒟蒻）~~，所以只能现在来补QAQ\n\n使用场景\n\n\n在无法获得实时评测反馈的比赛中，思考并实现了一个“高分解法”，但是再不会证明自己的结论，或者不能确保自己编写的程序是否完全正确。\n\n\n在平时解题时，自己编写的程序无法在Online Judge上取得Accepted结果，调试很久仍未发现错误。\n\n\n随机数据生成\n头文件cstdlib包含rand和srand两个函数，以及RAND_MAX常量。\nRAND_MAX是一个不小于376273762737627的整数，一般来说，在Windows系统中为376273762737627，在类Unix系统中为214748364721474836472147483647。\nrand()函数返回一个000~RAND_MAX之间的随机整数int。\nsrand(seed)函数接受unsighed int类型的参数seed，以seed为随机种子。rand函数基于线性同余递推式生成随机数，“随机种子”相当于计算线性同余死的一个初始参数。\n当种子确定后，接下来产生的随机数列就是固定的，所以这种随机方法也被称为“伪随机”。因此，一般在随机数据生成程序main函数的开头，用当前系统时间作为随机种子。\n头文件ctime包含time函数，调用time(0)可以返回从197019701970年111月111日000时000分000秒（Unix纪元）到现在的秒数。执行srand((unsigned)time(0))即可初始化随机种子。\n代码如下：\n#include&lt;cstdlib&gt;#include&lt;ctime&gt;int random(int n){    return (long long)rand()*rand()%n;}int main(){    srand((unsigned)time(0));    //···具体内容···}\n函数random(n)返回0∼n−10 \\sim n-10∼n−1之间的随机整数，对int范围内的nnn均能正常工作。\n对拍\n","categories":["OI"],"tags":["笔记","对拍","技巧"]},{"title":"逆元学习笔记","url":"/articles/%E9%80%86%E5%85%83%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"定义\n若ax=1(modb)ax=1 \\pmod bax=1(modb)，aaa，bbb互质，则称xxx为aaa的逆元，记为a−1a^{-1}a−1。\n用处\n逆元可以在计算ta mod b\\dfrac{t}{a}\\bmod bat​modb时，转化为t×a−1 mod bt\\times a^{-1}\\bmod bt×a−1modb。\n求法\n扩展欧几里得算法\n根据逆元的定义，可转化为ax+by=1ax+by=1ax+by=1，用扩展欧几里得算法求解。\n友情赠送代码：\nvoid exgcd(int a,int b,int c,int &amp;x,int &amp;y){    if(a==0)    {        x=0;y=c/b;        return;    }    else    {        int tx,ty;        exgcd(b%a,a,tx,ty);        x=ty-(b/a)*tx;        y=tx;        return;    }}\n线性算法\n前置芝士：1−1≡1(modp)1^{-1}\\equiv1\\pmod p1−1≡1(modp)。\n设p=k×i+rp=k\\times i+rp=k×i+r，r&lt;ir&lt;ir&lt;i，1&lt;i&lt;p1&lt;i&lt;p1&lt;i&lt;p，则：k×i+r≡0(modp)k\\times i+r\\equiv 0\\pmod pk×i+r≡0(modp)。\n两边同时乘i−1i^{-1}i−1，r−1r^{-1}r−1就会得到：\nk×r−1+i−1≡0i−1≡−k×r−1i−1≡−[pi]×(p mod i)−1\\begin{align}\nk\\times r^{-1}+i^{-1}&amp;\\equiv0\\\\\ni^{-1}&amp;\\equiv-k\\times r^{-1}\\\\\ni^{-1}&amp;\\equiv-\\left[\\dfrac{p}{i}\\right]\\times (p\\bmod i)^{-1}\\\\\n\\end{align}\nk×r−1+i−1i−1i−1​≡0≡−k×r−1≡−[ip​]×(pmodi)−1​​\n于是，就可以递归求逆元啦！代码只有一行！\nA[i]=-(p/i)*A[p%i];\n实际上，这也提供了一种Θ(log⁡2p)\\Theta(\\log_2p)Θ(log2​p)（众所周知Θ\\ThetaΘ表示时间复杂度更准确QwQ）的时间内求出单个数逆元的方法。\n","categories":["OI"],"tags":["笔记","数学","逆元"]}]