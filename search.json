[{"title":"My Blog","url":"/2022/12/16/My-Blog/","content":"我的Hexo博客来了！！！\r\n","categories":["随笔"]},{"title":"2022.11 and 2022.12","url":"/2022/12/17/2022.11%20and%202022.12/","content":"\r\n\r\n"},{"title":"UVA11806题解","url":"/2022/12/17/UVA11806%E9%A2%98%E8%A7%A3/","content":"设满足“第一行没有石子”的方案集为 ，最后一行没有石子的方案集为 ，第一列没有石子的方案集为 ，最后一列没有石子的方案集为 ，全集为 ，则所求答案是“在  中但不在\r\n任何一个集合中”的元素个数，可以用容斥原理求解。\r\n我们用二进制来表示 \r\n的所有搭配（\r\n对应于“空搭配”），如果在集合  或\r\n 中，相当于少了一列。假定最后剩了\r\n 行  列，方法数就是 。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int mod=1000007;const int maxk=500;int c[maxk+10][maxk+10];int main(){    memset(c,0,sizeof(c));    c[0][0]=1;    for(int i=0;i&lt;=maxk;i++)    {        c[i][0]=c[i][i]=1;        for(int j=1;j&lt;i;j++)            c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;    }    int t;    cin&gt;&gt;t;    for(int kase=1;kase&lt;=t;kase++)    {        int n,m,k,sum=0;        cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;        for(int s=0;s&lt;16;s++)        {            int b=0,r=n,qaq=m;            if(s&amp;1)            {                r--;                b++;            }            if(s&amp;2)            {                r--;                b++;            }            if(s&amp;4)            {                qaq--;                b++;            }            if(s&amp;8)            {                qaq--;                b++;            }            if(b&amp;1) sum=(sum+mod-c[r*qaq][k])%mod;            else sum=(sum+c[r*qaq][k])%mod;        }        printf(\"Case %d: %d\\n\",kase,sum);    }    return 0;}\r\n","categories":["OI"],"tags":["题解"]},{"title":"算法竞赛中常用的几种排序方式","url":"/2022/12/18/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F/","content":"最好情况下\r\n\r\n冒泡排序 图解： \r\n插入排序 图解： \r\n\r\n平均情况下\r\n\r\n快速排序 图解： 代码：\r\n\r\n最坏情况下\r\n\r\n堆排序 （等我学会之后再填坑）\r\n归并排序 图解： \r\n\r\n","categories":["OI"],"tags":["算法,排序"]}]