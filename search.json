[{"title":"2022.11 and 2022.12","url":"/2022/12/17/2022.11%20and%202022.12/","content":"\r\n\r\n"},{"title":"My Blog","url":"/2022/12/16/My-Blog/","content":"我的Hexo博客来了！！！\r\n","categories":["随笔"]},{"title":"UVA11806题解","url":"/2022/12/17/UVA11806%E9%A2%98%E8%A7%A3/","content":"设满足“第一行没有石子”的方案集为 ，最后一行没有石子的方案集为 ，第一列没有石子的方案集为 ，最后一列没有石子的方案集为 ，全集为 ，则所求答案是“在  中但不在\r\n任何一个集合中”的元素个数，可以用容斥原理求解。\r\n我们用二进制来表示 \r\n的所有搭配（\r\n对应于“空搭配”），如果在集合  或\r\n 中，相当于少了一列。假定最后剩了\r\n 行  列，方法数就是 。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int mod=1000007;const int maxk=500;int c[maxk+10][maxk+10];int main(){    memset(c,0,sizeof(c));    c[0][0]=1;    for(int i=0;i&lt;=maxk;i++)    {        c[i][0]=c[i][i]=1;        for(int j=1;j&lt;i;j++)            c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;    }    int t;    cin&gt;&gt;t;    for(int kase=1;kase&lt;=t;kase++)    {        int n,m,k,sum=0;        cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;        for(int s=0;s&lt;16;s++)        {            int b=0,r=n,qaq=m;            if(s&amp;1)            {                r--;                b++;            }            if(s&amp;2)            {                r--;                b++;            }            if(s&amp;4)            {                qaq--;                b++;            }            if(s&amp;8)            {                qaq--;                b++;            }            if(b&amp;1) sum=(sum+mod-c[r*qaq][k])%mod;            else sum=(sum+c[r*qaq][k])%mod;        }        printf(\"Case %d: %d\\n\",kase,sum);    }    return 0;}\r\n","categories":["OI"],"tags":["题解"]}]