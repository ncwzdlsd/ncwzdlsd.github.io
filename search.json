[{"title":"2022-12-18 廿四的雪","url":"/2022/12/18/2022-12-18-%E5%BB%BF%E5%9B%9B%E7%9A%84%E9%9B%AA/","content":"\r\n"},{"title":"My Blog","url":"/2022/12/16/My-Blog/","content":"我的Hexo博客来了！！！\r\n","categories":["随笔"]},{"title":"UVA11806题解","url":"/2022/12/17/UVA11806%E9%A2%98%E8%A7%A3/","content":"设满足“第一行没有石子”的方案集为 ，最后一行没有石子的方案集为 ，第一列没有石子的方案集为 ，最后一列没有石子的方案集为 ，全集为 ，则所求答案是“在  中但不在\r\n任何一个集合中”的元素个数，可以用容斥原理求解。\r\n我们用二进制来表示 \r\n的所有搭配（\r\n对应于“空搭配”），如果在集合  或\r\n 中，相当于少了一列。假定最后剩了\r\n 行  列，方法数就是 。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int mod=1000007;const int maxk=500;int c[maxk+10][maxk+10];int main(){    memset(c,0,sizeof(c));    c[0][0]=1;    for(int i=0;i&lt;=maxk;i++)    {        c[i][0]=c[i][i]=1;        for(int j=1;j&lt;i;j++)            c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;    }    int t;    cin&gt;&gt;t;    for(int kase=1;kase&lt;=t;kase++)    {        int n,m,k,sum=0;        cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;        for(int s=0;s&lt;16;s++)        {            int b=0,r=n,qaq=m;            if(s&amp;1)            {                r--;                b++;            }            if(s&amp;2)            {                r--;                b++;            }            if(s&amp;4)            {                qaq--;                b++;            }            if(s&amp;8)            {                qaq--;                b++;            }            if(b&amp;1) sum=(sum+mod-c[r*qaq][k])%mod;            else sum=(sum+c[r*qaq][k])%mod;        }        printf(\"Case %d: %d\\n\",kase,sum);    }    return 0;}\r\n","categories":["OI"],"tags":["题解"]},{"title":"2022.11 and 2022.12","url":"/2022/12/17/2022.11%20and%202022.12/","content":"\r\n\r\n"},{"title":"公告板and讨论区","url":"/2022/12/18/%E5%85%AC%E5%91%8A%E6%9D%BFand%E8%AE%A8%E8%AE%BA%E5%8C%BA/","content":"在下面的评论中会发布一些公告\r\n同时大家也可以在这里讨论啊QwQ\r\n"},{"title":"我的博客搭建记录","url":"/2022/12/18/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/","content":"\r\n动态博客篇\r\n\r\nTypecho\r\n开始，我想的是用最著名的博客框架之一——WordPress，但是发现这玩意儿必须得配服务器+数据库，很烧钱，被我否了。\r\n后来，发现了一个基于可以运行代码的平台Replit搭建的博客框架——Typecho，火速开干。在Replit上运行代码+FreeDB白嫖数据库+网站监测（我用的是Uptime\r\nKuma）（否则Replit上的代码过30分钟会自动休眠），完成。\r\n然鹅，最大的问题是，Typecho不支持Markdown，并且还有借用Replit的域名，并且Replit访问速度慢的和GitHub有的一拼，so——否了。\r\nWordPress\r\n没办法，只好回归WordPress，这里我试了三个方案：\r\n\r\n阿贝云白嫖服务器，千万不要上当，还花了我2块钱实名认证+3块钱虚拟机安装系统\r\n同样是借用别人的二级域名（好烦啊QAQ），试了两种方案，都不太满意\r\n\r\n\r\n并且：动态博客还有数据库之类的各种事儿，很麻烦！很烧钱！\r\n\r\n\r\n静态博客篇\r\n\r\nHexo\r\n曾经的我，对OI圈常用的Hexo搭建静态博客嗤之以鼻，直到吃了动态博客的亏后才发现静态博客的优点：\r\n\r\n易于管理（内容直接在本地，不用备份和管理数据库）\r\n便宜！！！（一年30买个域名就可以享受自己的独家博客它不香吗）\r\n\r\n一通操作之后（教程网上很多），我的Hexo博客部署成功！\r\n（如你所见，就是现在这样）\r\n\r\n\r\n","categories":["随笔"],"tags":["日常","实用"]},{"title":"我的2022","url":"/2022/12/18/%E6%88%91%E7%9A%842022/","content":"\r\n","categories":["随笔"],"tags":["我的20××"]},{"title":"链表——以P1160为例","url":"/2022/12/01/%E9%93%BE%E8%A1%A8%E2%80%94%E2%80%94%E4%BB%A5P1160%E4%B8%BA%E4%BE%8B/","content":"链表有很多种。下面列举一些。\r\n\r\n单链表：每个节点记录自己的后继。\r\n双链表：每个结点记录自己的前驱和后继。\r\n循环单链表：本身是一个单链表。最后一个节点的后继为第一个界点。\r\n循环双链表：本身是一个双链表，连成环形。\r\n块状链表：基本思想是将若干元素压缩成一块，将这些块串联起来。\r\n跳表：相当于平衡树。每个结点拥有自己的右指针和下指针，通过分层的方式来加速查询，而每个元素的层数由概率决定。\r\n\r\nP1160：\r\n利用一个双向链表维护这个队伍，每个同学记录自己左边和右边的同学。这样各种操作都可以O(1)的时间复杂度完成了。使用数组index定位某位同学的节点编号。\r\n#include &lt;iostream&gt;using namespace std;//注意万能头里有index数组struct node{    int pre,nxt,key;    node(int _key=0,int _pre=0,int _nxt=0)    {        pre=_pre;        nxt=_nxt;        key=_key;    }};node s[100005];int n,m,tot=0;int index[100005];void ins_back(int x,int y){    int now=index[x];    s[++tot]=node(y,now,s[now].nxt);    s[s[now].nxt].pre=tot;    s[now].nxt=tot;    index[y]=tot;}void ins_front(int x,int y){\tint now=index[x];\ts[++tot]=node(y,s[now].pre,now);    s[s[now].pre].nxt=tot;    s[now].pre=tot;    index[y]=tot;}void del(int x){\tint now=index[x];\tint le=s[now].pre,rt=s[now].nxt;\ts[le].nxt=rt;\ts[rt].pre=le;\tindex[x]=0;}int main(){\tindex[0]=0;    int x,k,p,now;    cin&gt;&gt;n;    s[0]=node();//  令0恒为最右边的结点 \tins_back(0,1);\tfor(int i=2;i&lt;=n;i++)\t{\t\tcin&gt;&gt;k&gt;&gt;p;\t\tp?ins_back(k,i):ins_front(k,i);\t}\t\tcin&gt;&gt;m;\tfor(int i=1;i&lt;=m;i++)\t{\t\tcin&gt;&gt;x;\t\tif(index[x])\t\t{\t\t\tdel(x);\t\t}\t}\tnow=s[0].nxt;\twhile(now)\t{\t\tcout&lt;&lt;s[now].key&lt;&lt;' ';\t\tnow=s[now].nxt;\t}\t    return 0;   }\r\n","categories":["OI"],"tags":["题解","数据结构"]},{"title":"算法竞赛中常用的几种排序方式","url":"/2022/11/17/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F/","content":"最好情况下\r\n\r\n冒泡排序 图解： \r\n插入排序 图解： \r\n\r\n平均情况下\r\n\r\n快速排序 图解： 代码：\r\n\r\n最坏情况下\r\n\r\n堆排序 （等我学会之后再填坑）\r\n归并排序 图解： \r\n\r\n","categories":["OI"],"tags":["算法","排序"]}]